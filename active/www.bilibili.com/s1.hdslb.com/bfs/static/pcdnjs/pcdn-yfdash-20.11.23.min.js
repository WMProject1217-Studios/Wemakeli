(function(e) {
    if ("object" == typeof exports && "undefined" != typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var o;
        o = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, o.YFDashIO = e()
    }
})(function() {
    var e, o = Math.ceil,
        t = Math.floor,
        n = Math.pow,
        r = String.fromCharCode;
    return function() {
        function d(s, e, n) {
            function t(g, i) {
                if (!e[g]) {
                    if (!s[g]) {
                        var r = "function" == typeof require && require;
                        if (!i && r) return r(g, !0);
                        if (o) return o(g, !0);
                        var c = new Error("Cannot find module '" + g + "'");
                        throw c.code = "MODULE_NOT_FOUND", c
                    }
                    var a = e[g] = {
                        exports: {}
                    };
                    s[g][0].call(a.exports, function(e) {
                        var o = s[g][1][e];
                        return t(o || e)
                    }, a, a.exports, d, s, e, n)
                }
                return e[g].exports
            }
            for (var o = "function" == typeof require && require, r = 0; r < n.length; r++) t(n[r]);
            return t
        }
        return d
    }()({
        1: [function(e, o, t) {
            "use strict";

            function n(e) {
                var o = e.length;
                if (0 < o % 4) throw new Error("Invalid string. Length must be a multiple of 4");
                var t = e.indexOf("="); - 1 === t && (t = o);
                var n = t === o ? 0 : 4 - t % 4;
                return [t, n]
            }

            function r(e, o, t) {
                return 3 * (o + t) / 4 - t
            }

            function a(e) {
                return c[63 & e >> 18] + c[63 & e >> 12] + c[63 & e >> 6] + c[63 & e]
            }

            function d(e, o, t) {
                for (var n, r = [], d = o; d < t; d += 3) n = (16711680 & e[d] << 16) + (65280 & e[d + 1] << 8) + (255 & e[d + 2]), r.push(a(n));
                return r.join("")
            }
            t.byteLength = function(e) {
                var o = n(e),
                    t = o[0],
                    i = o[1];
                return 3 * (t + i) / 4 - i
            }, t.toByteArray = function(e) {
                for (var o, t = n(e), a = t[0], d = t[1], c = new g(r(e, a, d)), u = 0, f = 0 < d ? a - 4 : a, p = 0; p < f; p += 4) o = s[e.charCodeAt(p)] << 18 | s[e.charCodeAt(p + 1)] << 12 | s[e.charCodeAt(p + 2)] << 6 | s[e.charCodeAt(p + 3)], c[u++] = 255 & o >> 16, c[u++] = 255 & o >> 8, c[u++] = 255 & o;
                return 2 === d && (o = s[e.charCodeAt(p)] << 2 | s[e.charCodeAt(p + 1)] >> 4, c[u++] = 255 & o), 1 === d && (o = s[e.charCodeAt(p)] << 10 | s[e.charCodeAt(p + 1)] << 4 | s[e.charCodeAt(p + 2)] >> 2, c[u++] = 255 & o >> 8, c[u++] = 255 & o), c
            }, t.fromByteArray = function(e) {
                for (var o, t = e.length, n = t % 3, r = [], a = 16383, s = 0, i = t - n; s < i; s += a) r.push(d(e, s, s + a > i ? i : s + a));
                return 1 == n ? (o = e[t - 1], r.push(c[o >> 2] + c[63 & o << 4] + "==")) : 2 == n && (o = (e[t - 2] << 8) + e[t - 1], r.push(c[o >> 10] + c[63 & o >> 4] + c[63 & o << 2] + "=")), r.join("")
            };
            for (var c = [], s = [], g = "undefined" == typeof Uint8Array ? Array : Uint8Array, u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", f = 0, i = u.length; f < i; ++f) c[f] = u[f], s[u.charCodeAt(f)] = f;
            s[45] = 62, s[95] = 63
        }, {}],
        2: [function(e, o, t) {
            (function(o) {
                "use strict";

                function a(e) {
                    if (e > J) throw new RangeError("The value \"" + e + "\" is invalid for option \"size\"");
                    var t = new Uint8Array(e);
                    return t.__proto__ = o.prototype, t
                }

                function o(e, o, t) {
                    if ("number" == typeof e) {
                        if ("string" == typeof o) throw new TypeError("The \"string\" argument must be of type string. Received type number");
                        return s(e)
                    }
                    return i(e, o, t)
                }

                function i(e, t, n) {
                    if ("string" == typeof e) return g(e, t);
                    if (ArrayBuffer.isView(e)) return u(e);
                    if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                    if (V(e, ArrayBuffer) || e && V(e.buffer, ArrayBuffer)) return f(e, t, n);
                    if ("number" == typeof e) throw new TypeError("The \"value\" argument must not be of type number. Received type number");
                    var i = e.valueOf && e.valueOf();
                    if (null != i && i !== e) return o.from(i, t, n);
                    var r = p(e);
                    if (r) return r;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return o.from(e[Symbol.toPrimitive]("string"), t, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
                }

                function d(e) {
                    if ("number" != typeof e) throw new TypeError("\"size\" argument must be of type number");
                    else if (0 > e) throw new RangeError("The value \"" + e + "\" is invalid for option \"size\"")
                }

                function c(e, o, t) {
                    return d(e), 0 >= e ? a(e) : void 0 === o ? a(e) : "string" == typeof t ? a(e).fill(o, t) : a(e).fill(o)
                }

                function s(e) {
                    return d(e), a(0 > e ? 0 : 0 | l(e))
                }

                function g(e, t) {
                    if (("string" != typeof t || "" === t) && (t = "utf8"), !o.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                    var n = 0 | m(e, t),
                        i = a(n),
                        r = i.write(e, t);
                    return r !== n && (i = i.slice(0, r)), i
                }

                function u(e) {
                    for (var o = 0 > e.length ? 0 : 0 | l(e.length), t = a(o), n = 0; n < o; n += 1) t[n] = 255 & e[n];
                    return t
                }

                function f(e, t, n) {
                    if (0 > t || e.byteLength < t) throw new RangeError("\"offset\" is outside of buffer bounds");
                    if (e.byteLength < t + (n || 0)) throw new RangeError("\"length\" is outside of buffer bounds");
                    var i;
                    return i = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), i.__proto__ = o.prototype, i
                }

                function p(e) {
                    if (o.isBuffer(e)) {
                        var t = 0 | l(e.length),
                            n = a(t);
                        return 0 === n.length ? n : (e.copy(n, 0, 0, t), n)
                    }
                    return void 0 === e.length ? "Buffer" === e.type && Array.isArray(e.data) ? u(e.data) : void 0 : "number" != typeof e.length || Q(e.length) ? a(0) : u(e)
                }

                function l(e) {
                    if (e >= J) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
                    return 0 | e
                }

                function m(e, t) {
                    if (o.isBuffer(e)) return e.length;
                    if (ArrayBuffer.isView(e) || V(e, ArrayBuffer)) return e.byteLength;
                    if ("string" != typeof e) throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof e);
                    var n = e.length,
                        i = 2 < arguments.length && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var r = !1;;) switch (t) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return U(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return G(e).length;
                        default:
                            if (r) return i ? -1 : U(e).length;
                            t = ("" + t).toLowerCase(), r = !0;
                    }
                }

                function h(e, o, t) {
                    var n = !1;
                    if ((void 0 === o || 0 > o) && (o = 0), o > this.length) return "";
                    if ((void 0 === t || t > this.length) && (t = this.length), 0 >= t) return "";
                    if (t >>>= 0, o >>>= 0, t <= o) return "";
                    for (e || (e = "utf8");;) switch (e) {
                        case "hex":
                            return A(this, o, t);
                        case "utf8":
                        case "utf-8":
                            return w(this, o, t);
                        case "ascii":
                            return O(this, o, t);
                        case "latin1":
                        case "binary":
                            return I(this, o, t);
                        case "base64":
                            return N(this, o, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return x(this, o, t);
                        default:
                            if (n) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase(), n = !0;
                    }
                }

                function y(e, o, t) {
                    var n = e[o];
                    e[o] = e[t], e[t] = n
                }

                function b(e, t, n, i, r) {
                    if (0 === e.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : 2147483647 < n ? n = 2147483647 : -2147483648 > n && (n = -2147483648), n = +n, Q(n) && (n = r ? 0 : e.length - 1), 0 > n && (n = e.length + n), n >= e.length) {
                        if (r) return -1;
                        n = e.length - 1
                    } else if (0 > n)
                        if (r) n = 0;
                        else return -1;
                    if ("string" == typeof t && (t = o.from(t, i)), o.isBuffer(t)) return 0 === t.length ? -1 : C(e, t, n, i, r);
                    if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : C(e, [t], n, i, r);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function C(e, o, t, n, r) {
                    function a(e, o) {
                        return 1 == d ? e[o] : e.readUInt16BE(o * d)
                    }
                    var d = 1,
                        c = e.length,
                        s = o.length;
                    if (void 0 !== n && (n = (n + "").toLowerCase(), "ucs2" === n || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                        if (2 > e.length || 2 > o.length) return -1;
                        d = 2, c /= 2, s /= 2, t /= 2
                    }
                    var g;
                    if (r) {
                        var i = -1;
                        for (g = t; g < c; g++)
                            if (a(e, g) !== a(o, -1 == i ? 0 : g - i)) - 1 != i && (g -= g - i), i = -1;
                            else if (-1 == i && (i = g), g - i + 1 === s) return i * d
                    } else
                        for (t + s > c && (t = c - s), g = t; 0 <= g; g--) {
                            for (var u = !0, f = 0; f < s; f++)
                                if (a(e, g + f) !== a(o, f)) {
                                    u = !1;
                                    break
                                }
                            if (u) return g
                        }
                    return -1
                }

                function T(e, o, t, n) {
                    t = +t || 0;
                    var r = e.length - t;
                    n ? (n = +n, n > r && (n = r)) : n = r;
                    var a = o.length;
                    n > a / 2 && (n = a / 2);
                    for (var d, c = 0; c < n; ++c) {
                        if (d = parseInt(o.substr(2 * c, 2), 16), Q(d)) return c;
                        e[t + c] = d
                    }
                    return c
                }

                function S(e, o, t, n) {
                    return H(U(o, e.length - t), e, t, n)
                }

                function L(e, o, t, n) {
                    return H(M(o), e, t, n)
                }

                function _(e, o, t, n) {
                    return L(e, o, t, n)
                }

                function v(e, o, t, n) {
                    return H(G(o), e, t, n)
                }

                function F(e, o, t, n) {
                    return H(q(o, e.length - t), e, t, n)
                }

                function N(e, o, t) {
                    return 0 === o && t === e.length ? K.fromByteArray(e) : K.fromByteArray(e.slice(o, t))
                }

                function w(e, o, t) {
                    t = j(e.length, t);
                    for (var n = [], r = o; r < t;) {
                        var i = e[r],
                            a = null,
                            d = 239 < i ? 4 : 223 < i ? 3 : 191 < i ? 2 : 1;
                        if (r + d <= t) {
                            var c, s, g, u;
                            1 == d ? 128 > i && (a = i) : 2 == d ? (c = e[r + 1], 128 == (192 & c) && (u = (31 & i) << 6 | 63 & c, 127 < u && (a = u))) : 3 == d ? (c = e[r + 1], s = e[r + 2], 128 == (192 & c) && 128 == (192 & s) && (u = (15 & i) << 12 | (63 & c) << 6 | 63 & s, 2047 < u && (55296 > u || 57343 < u) && (a = u))) : 4 == d ? (c = e[r + 1], s = e[r + 2], g = e[r + 3], 128 == (192 & c) && 128 == (192 & s) && 128 == (192 & g) && (u = (15 & i) << 18 | (63 & c) << 12 | (63 & s) << 6 | 63 & g, 65535 < u && 1114112 > u && (a = u))) : void 0
                        }
                        null === a ? (a = 65533, d = 1) : 65535 < a && (a -= 65536, n.push(55296 | 1023 & a >>> 10), a = 56320 | 1023 & a), n.push(a), r += d
                    }
                    return E(n)
                }

                function E(e) {
                    var o = e.length;
                    if (o <= X) return r.apply(String, e);
                    for (var t = "", n = 0; n < o;) t += r.apply(String, e.slice(n, n += X));
                    return t
                }

                function O(e, o, t) {
                    var n = "";
                    t = j(e.length, t);
                    for (var a = o; a < t; ++a) n += r(127 & e[a]);
                    return n
                }

                function I(e, o, t) {
                    var n = "";
                    t = j(e.length, t);
                    for (var a = o; a < t; ++a) n += r(e[a]);
                    return n
                }

                function A(e, o, t) {
                    var n = e.length;
                    (!o || 0 > o) && (o = 0), (!t || 0 > t || t > n) && (t = n);
                    for (var r = "", a = o; a < t; ++a) r += W(e[a]);
                    return r
                }

                function x(e, o, t) {
                    for (var n = e.slice(o, t), a = "", d = 0; d < n.length; d += 2) a += r(n[d] + 256 * n[d + 1]);
                    return a
                }

                function z(e, o, t) {
                    if (0 != e % 1 || 0 > e) throw new RangeError("offset is not uint");
                    if (e + o > t) throw new RangeError("Trying to access beyond buffer length")
                }

                function R(e, t, n, i, r, a) {
                    if (!o.isBuffer(e)) throw new TypeError("\"buffer\" argument must be a Buffer instance");
                    if (t > r || t < a) throw new RangeError("\"value\" argument is out of bounds");
                    if (n + i > e.length) throw new RangeError("Index out of range")
                }

                function D(e, o, t, n) {
                    if (t + n > e.length) throw new RangeError("Index out of range");
                    if (0 > t) throw new RangeError("Index out of range")
                }

                function B(e, o, t, n, i) {
                    return o = +o, t >>>= 0, i || D(e, o, t, 4, 3.4028234663852886e38, -3.4028234663852886e38), Y.write(e, o, t, n, 23, 4), t + 4
                }

                function P(e, o, t, n, i) {
                    return o = +o, t >>>= 0, i || D(e, o, t, 8, 1.7976931348623157e308, -1.7976931348623157e308), Y.write(e, o, t, n, 52, 8), t + 8
                }

                function k(e) {
                    if (e = e.split("=")[0], e = e.trim().replace(Z, ""), 2 > e.length) return "";
                    for (; 0 != e.length % 4;) e += "=";
                    return e
                }

                function W(e) {
                    return 16 > e ? "0" + e.toString(16) : e.toString(16)
                }

                function U(e, o) {
                    o = o || Infinity;
                    for (var t, n = e.length, r = null, a = [], d = 0; d < n; ++d) {
                        if (t = e.charCodeAt(d), 55295 < t && 57344 > t) {
                            if (!r) {
                                if (56319 < t) {
                                    -1 < (o -= 3) && a.push(239, 191, 189);
                                    continue
                                } else if (d + 1 === n) {
                                    -1 < (o -= 3) && a.push(239, 191, 189);
                                    continue
                                }
                                r = t;
                                continue
                            }
                            if (56320 > t) {
                                -1 < (o -= 3) && a.push(239, 191, 189), r = t;
                                continue
                            }
                            t = (r - 55296 << 10 | t - 56320) + 65536
                        } else r && -1 < (o -= 3) && a.push(239, 191, 189);
                        if (r = null, 128 > t) {
                            if (0 > (o -= 1)) break;
                            a.push(t)
                        } else if (2048 > t) {
                            if (0 > (o -= 2)) break;
                            a.push(192 | t >> 6, 128 | 63 & t)
                        } else if (65536 > t) {
                            if (0 > (o -= 3)) break;
                            a.push(224 | t >> 12, 128 | 63 & t >> 6, 128 | 63 & t)
                        } else if (1114112 > t) {
                            if (0 > (o -= 4)) break;
                            a.push(240 | t >> 18, 128 | 63 & t >> 12, 128 | 63 & t >> 6, 128 | 63 & t)
                        } else throw new Error("Invalid code point")
                    }
                    return a
                }

                function M(e) {
                    for (var o = [], t = 0; t < e.length; ++t) o.push(255 & e.charCodeAt(t));
                    return o
                }

                function q(e, o) {
                    for (var t, n, r, a = [], d = 0; d < e.length && !(0 > (o -= 2)); ++d) t = e.charCodeAt(d), n = t >> 8, r = t % 256, a.push(r), a.push(n);
                    return a
                }

                function G(e) {
                    return K.toByteArray(k(e))
                }

                function H(e, o, t, n) {
                    for (var r = 0; r < n && !(r + t >= o.length || r >= e.length); ++r) o[r + t] = e[r];
                    return r
                }

                function V(e, o) {
                    return e instanceof o || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === o.name
                }

                function Q(e) {
                    return e !== e
                }
                var j = Math.min,
                    K = e("base64-js"),
                    Y = e("ieee754");
                t.Buffer = o, t.SlowBuffer = function(e) {
                    return +e != e && (e = 0), o.alloc(+e)
                }, t.INSPECT_MAX_BYTES = 50;
                var J = 2147483647;
                t.kMaxLength = J, o.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        var e = new Uint8Array(1);
                        return e.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42
                            }
                        }, 42 === e.foo()
                    } catch (o) {
                        return !1
                    }
                }(), o.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        return o.isBuffer(this) ? this.buffer : void 0
                    }
                }), Object.defineProperty(o.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        return o.isBuffer(this) ? this.byteOffset : void 0
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), o.poolSize = 8192, o.from = function(e, o, t) {
                    return i(e, o, t)
                }, o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, o.alloc = function(e, o, t) {
                    return c(e, o, t)
                }, o.allocUnsafe = function(e) {
                    return s(e)
                }, o.allocUnsafeSlow = function(e) {
                    return s(e)
                }, o.isBuffer = function(e) {
                    return null != e && !0 === e._isBuffer && e !== o.prototype
                }, o.compare = function(e, t) {
                    if (V(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)), V(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(e) || !o.isBuffer(t)) throw new TypeError("The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array");
                    if (e === t) return 0;
                    for (var n = e.length, r = t.length, a = 0, i = j(n, r); a < i; ++a)
                        if (e[a] !== t[a]) {
                            n = e[a], r = t[a];
                            break
                        }
                    return n < r ? -1 : r < n ? 1 : 0
                }, o.isEncoding = function(e) {
                    switch ((e + "").toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1;
                    }
                }, o.concat = function(e, t) {
                    if (!Array.isArray(e)) throw new TypeError("\"list\" argument must be an Array of Buffers");
                    if (0 === e.length) return o.alloc(0);
                    var n;
                    if (t === void 0)
                        for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
                    var i = o.allocUnsafe(t),
                        r = 0;
                    for (n = 0; n < e.length; ++n) {
                        var a = e[n];
                        if (V(a, Uint8Array) && (a = o.from(a)), !o.isBuffer(a)) throw new TypeError("\"list\" argument must be an Array of Buffers");
                        a.copy(i, r), r += a.length
                    }
                    return i
                }, o.byteLength = m, o.prototype._isBuffer = !0, o.prototype.swap16 = function() {
                    var e = this.length;
                    if (0 != e % 2) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var o = 0; o < e; o += 2) y(this, o, o + 1);
                    return this
                }, o.prototype.swap32 = function() {
                    var e = this.length;
                    if (0 != e % 4) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var o = 0; o < e; o += 4) y(this, o, o + 3), y(this, o + 1, o + 2);
                    return this
                }, o.prototype.swap64 = function() {
                    var e = this.length;
                    if (0 != e % 8) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var o = 0; o < e; o += 8) y(this, o, o + 7), y(this, o + 1, o + 6), y(this, o + 2, o + 5), y(this, o + 3, o + 4);
                    return this
                }, o.prototype.toString = function() {
                    var e = this.length;
                    return 0 === e ? "" : 0 === arguments.length ? w(this, 0, e) : h.apply(this, arguments)
                }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(e) {
                    if (!o.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                    return this === e || 0 === o.compare(this, e)
                }, o.prototype.inspect = function() {
                    var e = "",
                        o = t.INSPECT_MAX_BYTES;
                    return e = this.toString("hex", 0, o).replace(/(.{2})/g, "$1 ").trim(), this.length > o && (e += " ... "), "<Buffer " + e + ">"
                }, o.prototype.compare = function(e, t, n, r, a) {
                    if (V(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)), !o.isBuffer(e)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof e);
                    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === a && (a = this.length), 0 > t || n > e.length || 0 > r || a > this.length) throw new RangeError("out of range index");
                    if (r >= a && t >= n) return 0;
                    if (r >= a) return -1;
                    if (t >= n) return 1;
                    if (t >>>= 0, n >>>= 0, r >>>= 0, a >>>= 0, this === e) return 0;
                    for (var d = a - r, c = n - t, s = j(d, c), g = this.slice(r, a), u = e.slice(t, n), f = 0; f < s; ++f)
                        if (g[f] !== u[f]) {
                            d = g[f], c = u[f];
                            break
                        }
                    return d < c ? -1 : c < d ? 1 : 0
                }, o.prototype.includes = function(e, o, t) {
                    return -1 !== this.indexOf(e, o, t)
                }, o.prototype.indexOf = function(e, o, t) {
                    return b(this, e, o, t, !0)
                }, o.prototype.lastIndexOf = function(e, o, t) {
                    return b(this, e, o, t, !1)
                }, o.prototype.write = function(e, o, t, n) {
                    if (void 0 === o) n = "utf8", t = this.length, o = 0;
                    else if (void 0 === t && "string" == typeof o) n = o, t = this.length, o = 0;
                    else if (isFinite(o)) o >>>= 0, isFinite(t) ? (t >>>= 0, void 0 === n && (n = "utf8")) : (n = t, t = void 0);
                    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    var i = this.length - o;
                    if ((void 0 === t || t > i) && (t = i), 0 < e.length && (0 > t || 0 > o) || o > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n || (n = "utf8");
                    for (var r = !1;;) switch (n) {
                        case "hex":
                            return T(this, e, o, t);
                        case "utf8":
                        case "utf-8":
                            return S(this, e, o, t);
                        case "ascii":
                            return L(this, e, o, t);
                        case "latin1":
                        case "binary":
                            return _(this, e, o, t);
                        case "base64":
                            return v(this, e, o, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return F(this, e, o, t);
                        default:
                            if (r) throw new TypeError("Unknown encoding: " + n);
                            n = ("" + n).toLowerCase(), r = !0;
                    }
                }, o.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var X = 4096;
                o.prototype.slice = function(e, t) {
                    var n = this.length;
                    e = ~~e, t = void 0 === t ? n : ~~t, 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), t < e && (t = e);
                    var i = this.subarray(e, t);
                    return i.__proto__ = o.prototype, i
                }, o.prototype.readUIntLE = function(e, o, t) {
                    e >>>= 0, o >>>= 0, t || z(e, o, this.length);
                    for (var n = this[e], r = 1, a = 0; ++a < o && (r *= 256);) n += this[e + a] * r;
                    return n
                }, o.prototype.readUIntBE = function(e, o, t) {
                    e >>>= 0, o >>>= 0, t || z(e, o, this.length);
                    for (var n = this[e + --o], i = 1; 0 < o && (i *= 256);) n += this[e + --o] * i;
                    return n
                }, o.prototype.readUInt8 = function(e, o) {
                    return e >>>= 0, o || z(e, 1, this.length), this[e]
                }, o.prototype.readUInt16LE = function(e, o) {
                    return e >>>= 0, o || z(e, 2, this.length), this[e] | this[e + 1] << 8
                }, o.prototype.readUInt16BE = function(e, o) {
                    return e >>>= 0, o || z(e, 2, this.length), this[e] << 8 | this[e + 1]
                }, o.prototype.readUInt32LE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
                }, o.prototype.readUInt32BE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }, o.prototype.readIntLE = function(e, o, t) {
                    e >>>= 0, o >>>= 0, t || z(e, o, this.length);
                    for (var r = this[e], a = 1, d = 0; ++d < o && (a *= 256);) r += this[e + d] * a;
                    return a *= 128, r >= a && (r -= n(2, 8 * o)), r
                }, o.prototype.readIntBE = function(e, o, t) {
                    e >>>= 0, o >>>= 0, t || z(e, o, this.length);
                    for (var r = o, i = 1, a = this[e + --r]; 0 < r && (i *= 256);) a += this[e + --r] * i;
                    return i *= 128, a >= i && (a -= n(2, 8 * o)), a
                }, o.prototype.readInt8 = function(e, o) {
                    return e >>>= 0, o || z(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                }, o.prototype.readInt16LE = function(e, o) {
                    e >>>= 0, o || z(e, 2, this.length);
                    var t = this[e] | this[e + 1] << 8;
                    return 32768 & t ? 4294901760 | t : t
                }, o.prototype.readInt16BE = function(e, o) {
                    e >>>= 0, o || z(e, 2, this.length);
                    var t = this[e + 1] | this[e] << 8;
                    return 32768 & t ? 4294901760 | t : t
                }, o.prototype.readInt32LE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }, o.prototype.readInt32BE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }, o.prototype.readFloatLE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), Y.read(this, e, !0, 23, 4)
                }, o.prototype.readFloatBE = function(e, o) {
                    return e >>>= 0, o || z(e, 4, this.length), Y.read(this, e, !1, 23, 4)
                }, o.prototype.readDoubleLE = function(e, o) {
                    return e >>>= 0, o || z(e, 8, this.length), Y.read(this, e, !0, 52, 8)
                }, o.prototype.readDoubleBE = function(e, o) {
                    return e >>>= 0, o || z(e, 8, this.length), Y.read(this, e, !1, 52, 8)
                }, o.prototype.writeUIntLE = function(e, o, t, r) {
                    if (e = +e, o >>>= 0, t >>>= 0, !r) {
                        var a = n(2, 8 * t) - 1;
                        R(this, e, o, t, a, 0)
                    }
                    var d = 1,
                        c = 0;
                    for (this[o] = 255 & e; ++c < t && (d *= 256);) this[o + c] = 255 & e / d;
                    return o + t
                }, o.prototype.writeUIntBE = function(e, o, t, r) {
                    if (e = +e, o >>>= 0, t >>>= 0, !r) {
                        var a = n(2, 8 * t) - 1;
                        R(this, e, o, t, a, 0)
                    }
                    var d = t - 1,
                        i = 1;
                    for (this[o + d] = 255 & e; 0 <= --d && (i *= 256);) this[o + d] = 255 & e / i;
                    return o + t
                }, o.prototype.writeUInt8 = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 1, 255, 0), this[o] = 255 & e, o + 1
                }, o.prototype.writeUInt16LE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 2, 65535, 0), this[o] = 255 & e, this[o + 1] = e >>> 8, o + 2
                }, o.prototype.writeUInt16BE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 2, 65535, 0), this[o] = e >>> 8, this[o + 1] = 255 & e, o + 2
                }, o.prototype.writeUInt32LE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 4, 4294967295, 0), this[o + 3] = e >>> 24, this[o + 2] = e >>> 16, this[o + 1] = e >>> 8, this[o] = 255 & e, o + 4
                }, o.prototype.writeUInt32BE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 4, 4294967295, 0), this[o] = e >>> 24, this[o + 1] = e >>> 16, this[o + 2] = e >>> 8, this[o + 3] = 255 & e, o + 4
                }, o.prototype.writeIntLE = function(e, o, t, r) {
                    if (e = +e, o >>>= 0, !r) {
                        var a = n(2, 8 * t - 1);
                        R(this, e, o, t, a - 1, -a)
                    }
                    var d = 0,
                        i = 1,
                        c = 0;
                    for (this[o] = 255 & e; ++d < t && (i *= 256);) 0 > e && 0 == c && 0 !== this[o + d - 1] && (c = 1), this[o + d] = 255 & (e / i >> 0) - c;
                    return o + t
                }, o.prototype.writeIntBE = function(e, o, t, r) {
                    if (e = +e, o >>>= 0, !r) {
                        var a = n(2, 8 * t - 1);
                        R(this, e, o, t, a - 1, -a)
                    }
                    var d = t - 1,
                        i = 1,
                        c = 0;
                    for (this[o + d] = 255 & e; 0 <= --d && (i *= 256);) 0 > e && 0 == c && 0 !== this[o + d + 1] && (c = 1), this[o + d] = 255 & (e / i >> 0) - c;
                    return o + t
                }, o.prototype.writeInt8 = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 1, 127, -128), 0 > e && (e = 255 + e + 1), this[o] = 255 & e, o + 1
                }, o.prototype.writeInt16LE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 2, 32767, -32768), this[o] = 255 & e, this[o + 1] = e >>> 8, o + 2
                }, o.prototype.writeInt16BE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 2, 32767, -32768), this[o] = e >>> 8, this[o + 1] = 255 & e, o + 2
                }, o.prototype.writeInt32LE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 4, 2147483647, -2147483648), this[o] = 255 & e, this[o + 1] = e >>> 8, this[o + 2] = e >>> 16, this[o + 3] = e >>> 24, o + 4
                }, o.prototype.writeInt32BE = function(e, o, t) {
                    return e = +e, o >>>= 0, t || R(this, e, o, 4, 2147483647, -2147483648), 0 > e && (e = 4294967295 + e + 1), this[o] = e >>> 24, this[o + 1] = e >>> 16, this[o + 2] = e >>> 8, this[o + 3] = 255 & e, o + 4
                }, o.prototype.writeFloatLE = function(e, o, t) {
                    return B(this, e, o, !0, t)
                }, o.prototype.writeFloatBE = function(e, o, t) {
                    return B(this, e, o, !1, t)
                }, o.prototype.writeDoubleLE = function(e, o, t) {
                    return P(this, e, o, !0, t)
                }, o.prototype.writeDoubleBE = function(e, o, t) {
                    return P(this, e, o, !1, t)
                }, o.prototype.copy = function(e, t, n, r) {
                    if (!o.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), 0 < r && r < n && (r = n), r === n) return 0;
                    if (0 === e.length || 0 === this.length) return 0;
                    if (0 > t) throw new RangeError("targetStart out of bounds");
                    if (0 > n || n >= this.length) throw new RangeError("Index out of range");
                    if (0 > r) throw new RangeError("sourceEnd out of bounds");
                    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                    var a = r - n;
                    if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, n, r);
                    else if (this === e && n < t && t < r)
                        for (var d = a - 1; 0 <= d; --d) e[d + t] = this[d + n];
                    else Uint8Array.prototype.set.call(e, this.subarray(n, r), t);
                    return a
                }, o.prototype.fill = function(e, t, n, r) {
                    if ("string" == typeof e) {
                        if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string");
                        if ("string" == typeof r && !o.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
                        if (1 === e.length) {
                            var a = e.charCodeAt(0);
                            ("utf8" === r && 128 > a || "latin1" === r) && (e = a)
                        }
                    } else "number" == typeof e && (e &= 255);
                    if (0 > t || this.length < t || this.length < n) throw new RangeError("Out of range index");
                    if (n <= t) return this;
                    t >>>= 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
                    var d;
                    if ("number" == typeof e)
                        for (d = t; d < n; ++d) this[d] = e;
                    else {
                        var i = o.isBuffer(e) ? e : o.from(e, r),
                            c = i.length;
                        if (0 === c) throw new TypeError("The value \"" + e + "\" is invalid for argument \"value\"");
                        for (d = 0; d < n - t; ++d) this[d + t] = i[d % c]
                    }
                    return this
                };
                var Z = /[^+/0-9A-Za-z-_]/g
            }).call(this, e("buffer").Buffer)
        }, {
            "base64-js": 1,
            buffer: 2,
            ieee754: 4
        }],
        3: [function(e, t) {
            function n() {
                this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = b(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
            }

            function i(e) {
                return void 0 === e._maxListeners ? n.defaultMaxListeners : e._maxListeners
            }

            function r(e, o, t) {
                if (o) e.call(t);
                else
                    for (var n = e.length, r = h(e, n), a = 0; a < n; ++a) r[a].call(t)
            }

            function a(e, o, t, n) {
                if (o) e.call(t, n);
                else
                    for (var r = e.length, a = h(e, r), d = 0; d < r; ++d) a[d].call(t, n)
            }

            function d(e, o, t, n, r) {
                if (o) e.call(t, n, r);
                else
                    for (var a = e.length, d = h(e, a), c = 0; c < a; ++c) d[c].call(t, n, r)
            }

            function c(e, o, t, n, r, a) {
                if (o) e.call(t, n, r, a);
                else
                    for (var d = e.length, c = h(e, d), s = 0; s < d; ++s) c[s].call(t, n, r, a)
            }

            function s(e, o, t, n) {
                if (o) e.apply(t, n);
                else
                    for (var r = e.length, a = h(e, r), d = 0; d < r; ++d) a[d].apply(t, n)
            }

            function g(e, o, t, n) {
                var r, a, d;
                if ("function" != typeof t) throw new TypeError("\"listener\" argument must be a function");
                if (a = e._events, a ? (a.newListener && (e.emit("newListener", o, t.listener ? t.listener : t), a = e._events), d = a[o]) : (a = e._events = b(null), e._eventsCount = 0), !d) d = a[o] = t, ++e._eventsCount;
                else if ("function" == typeof d ? d = a[o] = n ? [t, d] : [d, t] : n ? d.unshift(t) : d.push(t), !d.warned && (r = i(e), r && 0 < r && d.length > r)) {
                    d.warned = !0;
                    var c = new Error("Possible EventEmitter memory leak detected. " + d.length + " \"" + (o + "\" listeners added. Use emitter.setMaxListeners() to increase limit."));
                    c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = o, c.count = d.length, "object" == typeof console && console.warn && console.warn("%s: %s", c.name, c.message)
                }
                return e
            }

            function u() {
                if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
                    case 0:
                        return this.listener.call(this.target);
                    case 1:
                        return this.listener.call(this.target, arguments[0]);
                    case 2:
                        return this.listener.call(this.target, arguments[0], arguments[1]);
                    case 3:
                        return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
                    default:
                        for (var e = Array(arguments.length), o = 0; o < e.length; ++o) e[o] = arguments[o];
                        this.listener.apply(this.target, e);
                }
            }

            function f(e, o, t) {
                var n = {
                        fired: !1,
                        wrapFn: void 0,
                        target: e,
                        type: o,
                        listener: t
                    },
                    i = T.call(u, n);
                return i.listener = t, n.wrapFn = i, i
            }

            function p(e, o, t) {
                var n = e._events;
                if (!n) return [];
                var i = n[o];
                return i ? "function" == typeof i ? t ? [i.listener || i] : [i] : t ? y(i) : h(i, i.length) : []
            }

            function l(e) {
                var o = this._events;
                if (o) {
                    var t = o[e];
                    if ("function" == typeof t) return 1;
                    if (t) return t.length
                }
                return 0
            }

            function m(e, o) {
                for (var t = o, i = t + 1, r = e.length; i < r; t += 1, i += 1) e[t] = e[i];
                e.pop()
            }

            function h(e, o) {
                for (var t = Array(o), n = 0; n < o; ++n) t[n] = e[n];
                return t
            }

            function y(e) {
                for (var o = Array(e.length), t = 0; t < o.length; ++t) o[t] = e[t].listener || e[t];
                return o
            }
            var b = Object.create || function(e) {
                    var o = function() {};
                    return o.prototype = e, new o
                },
                C = Object.keys || function(e) {
                    var o = [];
                    for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && o.push(t);
                    return t
                },
                T = Function.prototype.bind || function(e) {
                    var o = this;
                    return function() {
                        return o.apply(e, arguments)
                    }
                };
            t.exports = n, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._maxListeners = void 0;
            var S, L = 10;
            try {
                var _ = {};
                Object.defineProperty && Object.defineProperty(_, "x", {
                    value: 0
                }), S = 0 === _.x
            } catch (e) {
                S = !1
            }
            S ? Object.defineProperty(n, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return L
                },
                set: function(e) {
                    if ("number" != typeof e || 0 > e || e !== e) throw new TypeError("\"defaultMaxListeners\" must be a positive number");
                    L = e
                }
            }) : n.defaultMaxListeners = L, n.prototype.setMaxListeners = function(e) {
                if ("number" != typeof e || 0 > e || isNaN(e)) throw new TypeError("\"n\" argument must be a positive number");
                return this._maxListeners = e, this
            }, n.prototype.getMaxListeners = function() {
                return i(this)
            }, n.prototype.emit = function(e) {
                var o, t, n, g, u, i, f = "error" === e;
                if (i = this._events, i) f = f && null == i.error;
                else if (!f) return !1;
                if (f) {
                    if (1 < arguments.length && (o = arguments[1]), o instanceof Error) throw o;
                    else {
                        var p = new Error("Unhandled \"error\" event. (" + o + ")");
                        throw p.context = o, p
                    }
                    return !1
                }
                if (t = i[e], !t) return !1;
                var l = "function" == typeof t;
                switch (n = arguments.length, n) {
                    case 1:
                        r(t, l, this);
                        break;
                    case 2:
                        a(t, l, this, arguments[1]);
                        break;
                    case 3:
                        d(t, l, this, arguments[1], arguments[2]);
                        break;
                    case 4:
                        c(t, l, this, arguments[1], arguments[2], arguments[3]);
                        break;
                    default:
                        for (g = Array(n - 1), u = 1; u < n; u++) g[u - 1] = arguments[u];
                        s(t, l, this, g);
                }
                return !0
            }, n.prototype.addListener = function(e, o) {
                return g(this, e, o, !1)
            }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(e, o) {
                return g(this, e, o, !0)
            }, n.prototype.once = function(e, o) {
                if ("function" != typeof o) throw new TypeError("\"listener\" argument must be a function");
                return this.on(e, f(this, e, o)), this
            }, n.prototype.prependOnceListener = function(e, o) {
                if ("function" != typeof o) throw new TypeError("\"listener\" argument must be a function");
                return this.prependListener(e, f(this, e, o)), this
            }, n.prototype.removeListener = function(e, o) {
                var t, n, r, a, i;
                if ("function" != typeof o) throw new TypeError("\"listener\" argument must be a function");
                if (n = this._events, !n) return this;
                if (t = n[e], !t) return this;
                if (t === o || t.listener === o) 0 == --this._eventsCount ? this._events = b(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, t.listener || o));
                else if ("function" != typeof t) {
                    for (r = -1, a = t.length - 1; 0 <= a; a--)
                        if (t[a] === o || t[a].listener === o) {
                            i = t[a].listener, r = a;
                            break
                        }
                    if (0 > r) return this;
                    0 === r ? t.shift() : m(t, r), 1 === t.length && (n[e] = t[0]), n.removeListener && this.emit("removeListener", e, i || o)
                }
                return this
            }, n.prototype.removeAllListeners = function(e) {
                var o, t, n;
                if (t = this._events, !t) return this;
                if (!t.removeListener) return 0 === arguments.length ? (this._events = b(null), this._eventsCount = 0) : t[e] && (0 == --this._eventsCount ? this._events = b(null) : delete t[e]), this;
                if (0 === arguments.length) {
                    var i, r = C(t);
                    for (n = 0; n < r.length; ++n) i = r[n], "removeListener" === i || this.removeAllListeners(i);
                    return this.removeAllListeners("removeListener"), this._events = b(null), this._eventsCount = 0, this
                }
                if (o = t[e], "function" == typeof o) this.removeListener(e, o);
                else if (o)
                    for (n = o.length - 1; 0 <= n; n--) this.removeListener(e, o[n]);
                return this
            }, n.prototype.listeners = function(e) {
                return p(this, e, !0)
            }, n.prototype.rawListeners = function(e) {
                return p(this, e, !1)
            }, n.listenerCount = function(e, o) {
                return "function" == typeof e.listenerCount ? e.listenerCount(o) : l.call(e, o)
            }, n.prototype.listenerCount = l, n.prototype.eventNames = function() {
                return 0 < this._eventsCount ? Reflect.ownKeys(this._events) : []
            }
        }, {}],
        4: [function(e, o, i) {
            i.read = function(o, t, r, a, c) {
                var g, e, u = 8 * c - a - 1,
                    f = (1 << u) - 1,
                    p = f >> 1,
                    l = -7,
                    m = r ? c - 1 : 0,
                    i = r ? -1 : 1,
                    d = o[t + m];
                for (m += i, g = d & (1 << -l) - 1, d >>= -l, l += u; 0 < l; g = 256 * g + o[t + m], m += i, l -= 8);
                for (e = g & (1 << -l) - 1, g >>= -l, l += a; 0 < l; e = 256 * e + o[t + m], m += i, l -= 8);
                if (0 === g) g = 1 - p;
                else {
                    if (g === f) return e ? NaN : (d ? -1 : 1) * Infinity;
                    e += n(2, a), g -= p
                }
                return (d ? -1 : 1) * e * n(2, g - a)
            }, i.write = function(o, r, a, g, u, f) {
                var p, l, m, c = 8 * f - u - 1,
                    h = (1 << c) - 1,
                    y = h >> 1,
                    b = 23 === u ? 5.960464477539063e-8 - 6.617444900424222e-24 : 0,
                    C = g ? 0 : f - 1,
                    i = g ? 1 : -1,
                    d = 0 > r || 0 === r && 0 > 1 / r ? 1 : 0;
                for (r = Math.abs(r), isNaN(r) || r === Infinity ? (l = isNaN(r) ? 1 : 0, p = h) : (p = t(Math.log(r) / Math.LN2), 1 > r * (m = n(2, -p)) && (p--, m *= 2), r += 1 <= p + y ? b / m : b * n(2, 1 - y), 2 <= r * m && (p++, m /= 2), p + y >= h ? (l = 0, p = h) : 1 <= p + y ? (l = (r * m - 1) * n(2, u), p += y) : (l = r * n(2, y - 1) * n(2, u), p = 0)); 8 <= u; o[a + C] = 255 & l, C += i, l /= 256, u -= 8);
                for (p = p << u | l, c += u; 0 < c; o[a + C] = 255 & p, C += i, p /= 256, c -= 8);
                o[a + C - i] |= 128 * d
            }
        }, {}],
        5: [function(o, t) {
            (function(o) {
                "use strict";

                function n(e, o) {
                    var t = (65535 & e) + (65535 & o);
                    return (e >> 16) + (o >> 16) + (t >> 16) << 16 | 65535 & t
                }

                function i(e, o) {
                    return e << o | e >>> 32 - o
                }

                function g(e, o, r, a, d, c) {
                    return n(i(n(n(o, e), n(a, c)), d), r)
                }

                function s(e, o, n, i, r, a, d) {
                    return g(o & n | ~o & i, e, o, r, a, d)
                }

                function u(e, o, n, i, r, a, c) {
                    return g(o & i | n & ~i, e, o, r, a, c)
                }

                function f(e, o, n, i, r, a, d) {
                    return g(o ^ n ^ i, e, o, r, a, d)
                }

                function p(e, o, n, i, r, a, c) {
                    return g(n ^ (o | ~i), e, o, r, a, c)
                }

                function a(e, o) {
                    e[o >> 5] |= 128 << o % 32, e[(o + 64 >>> 9 << 4) + 14] = o;
                    var t, i, r, g, l, m = 1732584193,
                        a = -271733879,
                        h = -1732584194,
                        c = 271733878;
                    for (t = 0; t < e.length; t += 16) i = m, r = a, g = h, l = c, m = s(m, a, h, c, e[t], 7, -680876936), c = s(c, m, a, h, e[t + 1], 12, -389564586), h = s(h, c, m, a, e[t + 2], 17, 606105819), a = s(a, h, c, m, e[t + 3], 22, -1044525330), m = s(m, a, h, c, e[t + 4], 7, -176418897), c = s(c, m, a, h, e[t + 5], 12, 1200080426), h = s(h, c, m, a, e[t + 6], 17, -1473231341), a = s(a, h, c, m, e[t + 7], 22, -45705983), m = s(m, a, h, c, e[t + 8], 7, 1770035416), c = s(c, m, a, h, e[t + 9], 12, -1958414417), h = s(h, c, m, a, e[t + 10], 17, -42063), a = s(a, h, c, m, e[t + 11], 22, -1990404162), m = s(m, a, h, c, e[t + 12], 7, 1804603682), c = s(c, m, a, h, e[t + 13], 12, -40341101), h = s(h, c, m, a, e[t + 14], 17, -1502002290), a = s(a, h, c, m, e[t + 15], 22, 1236535329), m = u(m, a, h, c, e[t + 1], 5, -165796510), c = u(c, m, a, h, e[t + 6], 9, -1069501632), h = u(h, c, m, a, e[t + 11], 14, 643717713), a = u(a, h, c, m, e[t], 20, -373897302), m = u(m, a, h, c, e[t + 5], 5, -701558691), c = u(c, m, a, h, e[t + 10], 9, 38016083), h = u(h, c, m, a, e[t + 15], 14, -660478335), a = u(a, h, c, m, e[t + 4], 20, -405537848), m = u(m, a, h, c, e[t + 9], 5, 568446438), c = u(c, m, a, h, e[t + 14], 9, -1019803690), h = u(h, c, m, a, e[t + 3], 14, -187363961), a = u(a, h, c, m, e[t + 8], 20, 1163531501), m = u(m, a, h, c, e[t + 13], 5, -1444681467), c = u(c, m, a, h, e[t + 2], 9, -51403784), h = u(h, c, m, a, e[t + 7], 14, 1735328473), a = u(a, h, c, m, e[t + 12], 20, -1926607734), m = f(m, a, h, c, e[t + 5], 4, -378558), c = f(c, m, a, h, e[t + 8], 11, -2022574463), h = f(h, c, m, a, e[t + 11], 16, 1839030562), a = f(a, h, c, m, e[t + 14], 23, -35309556), m = f(m, a, h, c, e[t + 1], 4, -1530992060), c = f(c, m, a, h, e[t + 4], 11, 1272893353), h = f(h, c, m, a, e[t + 7], 16, -155497632), a = f(a, h, c, m, e[t + 10], 23, -1094730640), m = f(m, a, h, c, e[t + 13], 4, 681279174), c = f(c, m, a, h, e[t], 11, -358537222), h = f(h, c, m, a, e[t + 3], 16, -722521979), a = f(a, h, c, m, e[t + 6], 23, 76029189), m = f(m, a, h, c, e[t + 9], 4, -640364487), c = f(c, m, a, h, e[t + 12], 11, -421815835), h = f(h, c, m, a, e[t + 15], 16, 530742520), a = f(a, h, c, m, e[t + 2], 23, -995338651), m = p(m, a, h, c, e[t], 6, -198630844), c = p(c, m, a, h, e[t + 7], 10, 1126891415), h = p(h, c, m, a, e[t + 14], 15, -1416354905), a = p(a, h, c, m, e[t + 5], 21, -57434055), m = p(m, a, h, c, e[t + 12], 6, 1700485571), c = p(c, m, a, h, e[t + 3], 10, -1894986606), h = p(h, c, m, a, e[t + 10], 15, -1051523), a = p(a, h, c, m, e[t + 1], 21, -2054922799), m = p(m, a, h, c, e[t + 8], 6, 1873313359), c = p(c, m, a, h, e[t + 15], 10, -30611744), h = p(h, c, m, a, e[t + 6], 15, -1560198380), a = p(a, h, c, m, e[t + 13], 21, 1309151649), m = p(m, a, h, c, e[t + 4], 6, -145523070), c = p(c, m, a, h, e[t + 11], 10, -1120210379), h = p(h, c, m, a, e[t + 2], 15, 718787259), a = p(a, h, c, m, e[t + 9], 21, -343485551), m = n(m, i), a = n(a, r), h = n(h, g), c = n(c, l);
                    return [m, a, h, c]
                }

                function d(e) {
                    var o, t = "",
                        n = 32 * e.length;
                    for (o = 0; o < n; o += 8) t += r(255 & e[o >> 5] >>> o % 32);
                    return t
                }

                function c(e) {
                    var o, t = [];
                    for (t[(e.length >> 2) - 1] = void 0, o = 0; o < t.length; o += 1) t[o] = 0;
                    var n = 8 * e.length;
                    for (o = 0; o < n; o += 8) t[o >> 5] |= (255 & e.charCodeAt(o / 8)) << o % 32;
                    return t
                }

                function l(e) {
                    return d(a(c(e), 8 * e.length))
                }

                function m(e, o) {
                    var t, n, i = c(e),
                        r = [],
                        s = [];
                    for (r[15] = s[15] = void 0, 16 < i.length && (i = a(i, 8 * e.length)), t = 0; 16 > t; t += 1) r[t] = 909522486 ^ i[t], s[t] = 1549556828 ^ i[t];
                    return n = a(r.concat(c(o)), 512 + 8 * o.length), d(a(s.concat(n), 640))
                }

                function h(e) {
                    var o, t, n = "0123456789abcdef",
                        i = "";
                    for (t = 0; t < e.length; t += 1) o = e.charCodeAt(t), i += n.charAt(15 & o >>> 4) + n.charAt(15 & o);
                    return i
                }

                function y(e) {
                    return unescape(encodeURIComponent(e))
                }

                function b(e) {
                    return l(y(e))
                }

                function C(e) {
                    return h(b(e))
                }

                function T(e, o) {
                    return m(y(e), y(o))
                }

                function S(e, o) {
                    return h(T(e, o))
                }

                function L(e, o, t) {
                    return o ? t ? T(o, e) : S(o, e) : t ? b(e) : C(e)
                }
                "function" == typeof e && e.amd ? e(function() {
                    return L
                }) : "object" == typeof t && t.exports ? t.exports = L : o.md5 = L
            })(this)
        }, {}],
        6: [function(e, o) {
            o.exports = "function" == typeof Object.create ? function(e, o) {
                e.super_ = o, e.prototype = Object.create(o.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                })
            } : function(e, o) {
                e.super_ = o;
                var t = function() {};
                t.prototype = o.prototype, e.prototype = new t, e.prototype.constructor = e
            }
        }, {}],
        7: [function(e, o) {
            o.exports = {
                name: "yfdashio",
                version: "1.5.4",
                description: "h5 p2p plug",
                main: "./dist/index.yfplayer.js",
                browser: {
                    "fs-chunk-store": "memory-chunk-store",
                    "load-ip-set": !1,
                    net: !1,
                    os: !1,
                    ut_pex: !1
                },
                dependencies: {
                    "binary-search": "^1.3.5",
                    bitfield: "^1.1.2",
                    "blueimp-md5": "^2.10.0",
                    buffer: "^4.9.1",
                    "crypto-js": "^3.1.9-1",
                    "fs-chunk-store": "^1.6.2",
                    "gulp-uglify": "^3.0.1",
                    "immediate-chunk-store": "^1.0.8",
                    inherits: "^2.0.3",
                    "js-base64": "^2.5.2",
                    "memory-chunk-store": "^1.3.0",
                    sha1: "^1.1.1",
                    uint64be: "^2.0.2"
                },
                devDependencies: {
                    babili: "^0.1.4",
                    "babel-loader": "^7.1.1",
                    "babel-polyfill": "^6.26.0",
                    "arraybuffer-equal": "^1.0.4",
                    "babel-core": "^6.25.0",
                    "babel-preset-es2015": "^6.24.1",
                    "babel-register": "^6.24.0",
                    chromedriver: "^2.28.0",
                    "cross-env": "^5.0.2",
                    "deep-strict-equal": "^0.2.0"
                },
                scripts: {
                    "build-io": "browserify ./yfdash-io.js -s YFDashIO > ./dist/yfdashio.js",
                    "uglify-io": "browserify -s YFDashIO -e  ./yfdash-io.js | babili > ./dist/yfdashio.min.js",
                    "pull-from-github": "git pull",
                    "push-to-github": "git add . && git commit -m 'update' && git push",
                    "uglifyjs-player": "uglifyjs ./dist/yfdash-io.js-m -o ./dist/yfdashio.min.js",
                    "npm-publish": "npm publish"
                },
                author: "huangshaochun",
                license: "ISC"
            }
        }, {}],
        8: [function(e, t) {
            function n(e, o, t) {
                var n = this;
                c.call(n), o = o || {}, n.app = t, n.src = e, n.autoplay = !1 !== o.autoplay, n.dispatcher = null, n.nodeList = [], n.oldAppendCount = 0, n.sameAppendCount = 0, n.config = new p, n.config.mediaType = n.app.mediaType, o.version && (n.config.sdkversion = o.version), n.config.conf_v = n.config.sdkversion, n.config.mdebug = o.mdebug;
                n.timeInterval = void 0, "watch" == n.config.mediaType && (n.config.bWatch = !0), n.config.videourl = n.src, n.config.autoplay = o.autoplay || !1, n.config.autoload = o.autoload, n.config.keyurl = i(n.src), n.config.setupTime = new Date().getTime(), n.config.iLastLoadTime = n.config.setupTime, n.config.SdkFristTime = n.config.setupTime, n.config.hasLoadeddata = !1, n.config.videoType = "video", n.firstsize = 131072, n.config.domain = o.domain || "", n.hdNode = void 0;
                var r = n.config.videourl.split("/");
                if (r[2]) {
                    n.config.domain = r[2];
                    var a = n.config.videourl.split(n.config.domain);
                    if (a[1]) {
                        var d = "https://uposdash-302-bilivideo.yfcdn.net:2009/upos-dash-mirrorks3u.bilivideo.com" + a[1];
                        n.hdNode = new u(d, "server", 3, {
                            mediaType: n.config.mediaType,
                            timeout: n.config.cdnTimeout,
                            config: n.config
                        })
                    }
                }
                n._initStatx("/qa.igame"), n.config.stat = n.stat, n.timerFlag = !1, n.destroyed = !1, n.iLastSwitchTime = n.config.setupTime, n.bPlayEnd = !1, n.range_start = 0, n.range_end = 0, n.appendToPlayerPos = 0, n.sillpiece_num = 2, n.oFetchNode = new s(n.config), n.bOnplayEvent = !1, n.count = 0, n.FetchTimeOutId = 0, n.bNoResources = !1, n.hdCdn = void 0, n.requestTimeId = 0, n.requestTimeOutId = 0, n.ReportTimeOutId = 0, n.curLoader = void 0, n.bQueryNode = !1, n.cloudCfg = void 0, n.bFetchSupported = !1, n.scdnSwitchCount = 0, n.bNotNeedQueryNode = !0, n.nodeCount = 1, n.cdnErrReportCount = 0, n.iSeekNum = 0, n.NoDataCount = 0, n.CacheBytes = void 0, n.CacheBufSize = 0, n.curRecvPosition = 0, n.curAppendPosition = 0, n.curCacheStart = 0, n.appendCacheEnd = 0, n.curCacheEnd = 0, n.bytesAvailable = 0, n.appendCacheCount = 0, n.lastRange = {}, n.sameRangeCount = 0, n.cacheCleanCount = 0, n.wasteDataLen = 0, n.CompleteCount = 0, n.Heartbeat = new b(4e3, n.config), n.config.bWatch && (n.config.hasSteupded = !0, clearTimeout(n.requestTimeId), n.hdCdn = new u(n.src, "server", 0, {
                    mediaType: n.config.mediaType,
                    timeout: n.config.cdnTimeout,
                    config: n.config
                }), n._startPlaying(), n.startTimer(), n.requestTimeId = setTimeout(function() {
                    clearTimeout(n.requestTimeId), n.requestTimeId = 0, n._initsingal()
                }, 2e3))
            }

            function i(e) {
                var o = new Date,
                    t = o.getFullYear(),
                    n = "",
                    i = "";
                e = e.split("?")[0];
                var r = e.split("/"),
                    a = r[3].indexOf(t);
                i = 0 <= a ? 5 : 3;
                for (var d = 0; d < i; d++) r.shift();
                return n = r.join("/"), "/" + n
            }

            function r(e) {
                var o = document.cookie.split(";") || [];
                if (!o || !o.length) return "";
                for (var t = 0; t < o.length; t++) {
                    var n = $.trim(o[t]).split("=")[0],
                        i = $.trim(o[t]).split("=")[1];
                    if (n === e) return i
                }
                return ""
            }

            function a() {
                var e = {};
                if (!(navigator && navigator.userAgent)) return {
                    broswer: "",
                    version: "0"
                };
                var o, t = navigator.userAgent.toLowerCase();
                return (o = t.match(/edge\/([\d.]+)/)) ? e.edge = o[1] : (o = t.match(/rv:([\d.]+)\) like gecko/)) ? e.ie = o[1] : (o = t.match(/msie ([\d.]+)/)) ? e.ie = o[1] : (o = t.match(/firefox\/([\d.]+)/)) ? e.firefox = o[1] : (o = t.match(/chrome\/([\d.]+)/)) ? e.chrome = o[1] : (o = t.match(/opera.([\d.]+)/)) ? e.opera = o[1] : (o = t.match(/version\/([\d.]+).*safari/)) ? e.safari = o[1] : 0, e.edge ? {
                    broswer: "edge",
                    version: e.edge
                } : e.ie ? {
                    broswer: "ie",
                    version: e.ie
                } : e.firefox ? {
                    broswer: "firefox",
                    version: e.firefox
                } : e.chrome ? {
                    broswer: "chrome",
                    version: e.chrome
                } : e.opera ? {
                    broswer: "opera",
                    version: e.opera
                } : e.safari ? {
                    broswer: "safari",
                    version: e.safari
                } : {
                    broswer: "",
                    version: "0"
                }
            }
            t.exports = n;
            var d = e("inherits"),
                c = e("events").EventEmitter,
                s = e("../loader/fetchLoader"),
                g = e("../loader/toGetNodes"),
                u = e("../loader/xhrLoader"),
                f = e("./dispatcher-xhr"),
                p = e("./config"),
                l = e("../stat/statx"),
                m = e("../stat/log-report"),
                h = e("../loader/cloud-cfg"),
                y = e("../util/dateFtt"),
                b = e("../stat/Heartbeat");
            d(n, c);
            var C = 0,
                T = 1,
                S = 1,
                L = 2,
                _ = 0,
                v = {
                    ok: 0,
                    errRecoverable: 1,
                    errUnrecoverable: 2
                };
            String.prototype.format = function(e) {
                var o = this;
                if (1 > arguments.length) return o;
                var t = arguments;
                for (var n in 1 == arguments.length && "object" == typeof e && (t = e), t) {
                    var i = t[n];
                    void 0 != i && (o = o.replace("{" + n + "}", i))
                }
                return o
            }, n.prototype._initStatx = function() {
                var e = this;
                if (!e.destroyed) {
                    e.stat = new l;
                    var o = e.config.keyurl.split("/");
                    if (e.stat.appname = o[o.length - 2], e.stat.streamname = o[o.length - 1], e.stat.streamname = e.stat.streamname.split(".")[0], e.stat.open_ts = e.config.setupTime, e.stat.init(e.config.domain, e.config), e.withCredentials = !1, e.config.logReport = new m(e.config), e.config.playSessid = e.stat.device_vid, window && window.player && window.player.getSession && (e.config.playSessid = window.player.getSession()), window && window.player && window.player.getSession && document && document.cookie && r("buvid3") && (e.config.playDevId = r("buvid3")), 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                        var t = "[{0}][{1}]IOController._initStatx >>uuid[{2}] vid[{3}] Sessid[{4}] DevId[{5}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.stat.vid, e.stat.device_vid, e.config.playSessid, e.config.playDevId);
                        e.config.mdebug && console.log(t), e.config.debugger(t)
                    }
                }
            }, n.prototype._start = function(e, o) {
                var t = this;
                t.destroyed || (t.config.activeTimercount = 0, t.hdCdn = new u(t.src, "server", 0, {
                    mediaType: t.config.mediaType,
                    timeout: t.config.cdnTimeout,
                    config: t.config
                }), t.config.hasSteupded = !0, t.withCredentials = o, t.withCredentials && (t.hdCdn && (t.hdCdn.withCredentials = t.withCredentials), t.oFetchNode && (t.oFetchNode.withCredentials = t.withCredentials)), t.bFetchSupported = t.oFetchNode.isSupported(), t.bFetchSupported && t.checkBroswer(), t.readCfgFromLocal(), t.range_start = e.from, t.range_end = e.to, 0 < e.from && (t.bOnplayEvent = !0), t.appendToPlayerPos = t.range_start, t._startPlaying(), "video" == t.config.mediaType ? t.queryNodeFromVideoLocal(t.config.mediaType) : t.queryNodeFromAudioLocal(t.config.mediaType), !t.config.bFetchSupported && (t.bFetchSupported = !1), t.config.bCurFetchSupported = t.bFetchSupported, t.app && t.app.updateBufferLen(!0), t.oFetchNode && t.bFetchSupported ? (t.oFetchNode.loader = t.hdCdn, t.oFetchNode.cdnType = C, t.ToFetch(t.src, S, e, 0)) : (t.stat.download_type = 2, t.ToLoadCtr(S, !1)))
            }, n.prototype.ToFetch = function(e, t, n) {
                var i = this;
                if (!(!0 == i.destroyed || i.oFetchNode.isWorking() || i.config.bWatch)) {
                    i.scdnSwitchCount = 0, i.appendCacheCount = 0;
                    var r = new Date().getTime();
                    0 < i.requestTimeId && (clearTimeout(i.requestTimeId), i.requestTimeId = 0);
                    var a = e,
                        d = i.config.fetchCdnSize;
                    if (0 < i.oFetchNode.cdnType && 1024 < i.config.fetchScdnSize && (d = i.config.fetchScdnSize), t == S && (d = i.config.fetchFirstSize), "video" != i.config.mediaType && d > i.config.AudioFetchBufSize && (d = i.config.AudioFetchBufSize), 0 < n.to) {
                        var c = n.to - n.from + 1;
                        c < d && 0 < c && (d = c), i.config.bCtrRagneSize && 0 < i.config.LoadRangeSize && d > i.config.LoadRangeSize && (d = i.config.LoadRangeSize)
                    }
                    var s = parseInt(i.config.bufferLen - i.config.bufLenCtr.a);
                    if ("video" == i.config.mediaType && i.oFetchNode.cdnType == T && 7 < s) {
                        var g = 0;
                        i.oFetchNode.loader && (g = i.oFetchNode.loader.speed);
                        var u = 1024 * parseInt(g * (s - 1));
                        409600 < u && d > u && (d = u)
                    }
                    if (0 < i.config.filesize && n.from + d > i.config.filesize && (d = i.config.filesize - n.from), 1 > d) {
                        if (0 < i.config.iSaveWaitLog || i.config.mdebug) {
                            var f = "[{0}][{1}]#IOController.ToFetch() cdnType[{2}] bufferLen[{3}] filesize[{4}] tmpFetchSize[{5}] error".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, i.config.bufferLen.toFixed(2), i.config.filesize, d);
                            i.config.mdebug && console.log(f), i.config.debugger(f)
                        }
                        return i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("IOController.ToFetch()"))
                    }
                    var p = i.config.fetchCdnFirstTimeOut;
                    if (i.oFetchNode.cdnType == T && (p = i.config.fetchScdnFirstTimeOut), i.oFetchNode._onContentLengthKnown = function(e) {
                            i.clearFetchTimeout(), i.destroyed || 0 == i.config.filesize && (i.config.filesize = e, 0 == i.config.bitrate && 20 < i.config.duration && (i.config.bitrate = 8 * o(i.config.filesize / i.config.duration / 1024), i.config.bitrateLimit()))
                        }, i.oFetchNode._onURLRedirect = void 0, i.oFetchNode._onDataArrival = function(e, o, t) {
                            if (i.clearFetchTimeout(), !0 == i.destroyed || !0 == i.config.stopLoadedFlag) return void(i.oFetchNode.isWorking() && i.oFetchNode.abort());
                            if (i.NoDataCount = 0, 1 > i.config.appendCount && (0 < i.config.iSaveWaitLog || i.config.mdebug)) {
                                var n = "[{0}][{1}]IOController.ToFetch() _onDataArrival cdnType[{2}] bufferLen[{3}] byteStart[{4}] receivedLength[{5}] size[{6}] contentLength[{7}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, i.config.bufferLen.toFixed(2), o, t, i.oFetchNode._size, i.oFetchNode._contentLength);
                                i.config.mdebug && console.log(n), i.config.debugger(n)
                            }
                            if (i.dispatcher && i.oFetchNode.loader) {
                                var r = 0;
                                r = i.oFetchNode.loader.downbytes - i.oFetchNode.loader.syncdownbytes, 0 < r && (i.oFetchNode.loader.syncdownbytes = i.oFetchNode.loader.downbytes, 0 < i.oFetchNode.loader.nodetype ? i.dispatcher.loadInfo.scdnLoaded += r : i.dispatcher.loadInfo.cdnLoaded += r)
                            }
                            i.appendBuffer(o, e), i.app && 0 == i.config.appendCount % 15 && i.oFetchNode.cdnType == C && i.dispatcher && 1 < i.dispatcher.length && 40 > i.scdnSwitchCount && 262144 < d && (i.app.updateBufferLen(!0), i.config.bufferLen > i.config.bufLenCtr.b + 1 && (i.scdnSwitchCount++, i.ToLoadCtr(_, !0)))
                        }, i.oFetchNode._onError = function(e, o, t) {
                            if (i.clearFetchTimeout(), !i.destroyed && i.oFetchNode && i.oFetchNode.loader) {
                                if (i.config.ErrCount++, i.oFetchNode.loader.nCompleteCount = 0, i.oFetchNode.cdnType == C && i.config.AllErrCount++, 3 < i.config.iSaveWaitLog && (i.config.iSaveLogCount = 0), i.app && i.app.updateBufferLen(!0) && i.EmptyBuffer(i.oFetchNode.loader, 15, 0), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                                    var n = "[{0}][{1}]##IOController.ToFetch() _onError cdnType[{2}] TimeOut[{3}] bufferLen[{4}] range[{5}] waitNum[{6}] sCancelNum[{7}] size[{8}]  ErrCount[{9}] _status[{10}] errType[{11}] errinfo[{12}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, p, i.config.bufferLen.toFixed(2), i.oFetchNode.strRange, i.config.waitNum, i.config.sCanceNum, i.oFetchNode._size, i.config.ErrCount, i.oFetchNode._status, e, JSON.stringify(o));
                                    i.config.mdebug && console.log(n), i.config.debugger(n)
                                }
                                if (0 == i.config.filesize && o.code && 416 == o.code && i.config.RangeErrCount++, i.oFetchNode.loader) {
                                    i.oFetchNode.loader.weight -= 0.3, i.oFetchNode.loader.code = i.oFetchNode._status, i.oFetchNode.loader.downfails++;
                                    var r = i.oFetchNode._contentLength + "/" + i.oFetchNode.strRange;
                                    if (i.oFetchNode.loader.AddErrMsgArry({
                                            err_code: o.code,
                                            err_msg: o.msg,
                                            err_pos: t,
                                            node_type: i.oFetchNode.loader.nodetype,
                                            sCanceNum: i.config.sCanceNum,
                                            send_length: i.oFetchNode._receivedLength,
                                            waitNum: i.config.waitNum,
                                            bufferLen: i.config.bufferLen.toFixed(2),
                                            pull_type: "fetch",
                                            range: r,
                                            rangeSize: i.oFetchNode._size,
                                            timeout: p,
                                            useTime: i.oFetchNode.loader.Onedowntimes,
                                            usetimes: i.oFetchNode.loader.usetimes,
                                            url: i.oFetchNode.loader.uri
                                        }), i.oFetchNode.loader.type == T && o && 399 < o.code && (i.oFetchNode.loader.weight = 0), 0.11 > i.oFetchNode.loader.weight && i.oFetchNode.loader.type == T) {
                                        var a = i.oFetchNode.loader.uri;
                                        if (i.dispatcher) {
                                            var d = i.oFetchNode.loader.downbytes - i.oFetchNode.loader.reportdownbytes;
                                            0 < d && i.dispatcher.FlowReport(0), i.dispatcher.removeObj(i.oFetchNode.loader, i.dispatcher.downloaders), i.oFetchNode.loader = void 0, i.nodeCount = i.dispatcher.downloaders.length
                                        }(0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]##Dispatcher.removeDownLoader new loader.length[{2}] HTTP_SDN_TYPE>> removeObj url[{3}] ".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.nodeCount, a), i.config.mdebug && console.log(n), i.config.debugger(n)), i.bNotNeedQueryNode = !0, i.queryNode()
                                    }
                                }
                                return 0 == i.config.filesize && o.code && 416 == o.code && (i.config.RangeErrCount++, 1 < i.config.RangeErrCount && -1 == i.oFetchNode._size) ? (i.oFetchNode.loader && (i.oFetchNode.loader.errMsgArry = []), (0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]##IOController.ToFetch() >>filesize==0 RangeErrCount[{2}] _size[{3}] onComplete".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.config.RangeErrCount, i.oFetchNode._size), i.config.mdebug && console.log(n), i.config.debugger(n)), i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("oFetchNode._onError()"))) : o && o.msg && 0 < o.msg.indexOf("buffer allocation") ? (i.config.iSaveWaitLog = 0, i.config.cleanLogReport(), i.ClearCache(!0), i.config.bSdkCache = !1, i.config.stopLoadedFlag = !0, i.cdnErrReportCount++, void i.ErrorQuitActively("oFetchNode._onError()", o.msg)) : i.oFetchNode.cdnType == C && 0 == i.oFetchNode.loader.nodetype && 403 == o.code && i.hdNode && 1 == i.config.iErr403 ? (i.oFetchNode.loader.iUrlErrStatus = v.errUnrecoverable, (0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]#IOController.ToFetch() errinfo[{2}}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, JSON.stringify(o)), i.config.mdebug && console.log(n), i.config.debugger(n)), void i.ToLoadCtr(L, !0)) : i.oFetchNode.cdnType == C && 0 == i.oFetchNode.loader.nodetype && (1 == i.config.iFailToFetch || 2 == i.config.iFailToFetch || 3 == i.config.iFailToFetch) && i.hdNode && 0 < i.nodeCount && o.msg && (-1 < o.msg.indexOf("\u6CD5 fetch") || -1 < o.msg.indexOf("ailed to fetch")) ? ((1 == i.config.iFailToFetch || 2 == i.config.iFailToFetch) && (i.bFetchSupported = !1, i.config.bCurFetchSupported = !1), (2 == i.config.iFailToFetch || 3 == i.config.iFailToFetch) && (i.oFetchNode.loader.iUrlErrStatus = v.errUnrecoverable), (0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]#IOController.ToFetch() error msg[{2}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, o.msg), i.config.mdebug && console.log(n), i.config.debugger(n)), void i.ToLoadCtr(L, !0)) : o.msg && -1 < o.msg.indexOf("undefined is not an object (evaluating 'o.body.getReader") ? (i.bFetchSupported = !1, i.config.bCurFetchSupported = !1, i.oFetchNode.loader = void 0, (0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]#IOController.ToFetch() _onError not supported fetch to xhr".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType), i.config.mdebug && console.log(n), i.config.debugger(n)), void i.ToLoadCtr(L, !0)) : 5120 < i.oFetchNode._receivedLength && (1 == i.config.iErrEarlyEOF || 2 == i.config.iErrEarlyEOF || 3 == i.config.iErrEarlyEOF) && o.msg && -1 < o.msg.indexOf("Fetch stream meet Early-EOF") ? (i.oFetchNode.loader.weight += 0.3, i.oFetchNode.loader.errTime = 0, i.appendToPlayerPos >= i.range_end && 0 < i.range_end) ? ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]#IOController.ToFetch() _onError >>one Range End onComplete() appendToPlayerPos[{2}] range_end[{3}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.appendToPlayerPos, i.range_end), i.config.mdebug && console.log(n), i.config.debugger(n)), i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("oFetchNode._onError()"))) : (2 == i.config.iErrEarlyEOF && i.oFetchNode.cdnType == C && (i.oFetchNode.loader.iUrlErrStatus = v.errUnrecoverable), i.oFetchNode.loader = void 0, 3 == i.config.iErrEarlyEOF && (i.bFetchSupported = !1, i.config.bCurFetchSupported = !1), i.CacheRangeComplete(), void i.ToLoadCtr(L, !0)) : i.app && null != i.app.onError && i.oFetchNode.cdnType == C ? 0 == i.config.filesize && o.code && 416 == o.code && 2 > i.config.RangeErrCoun ? (i.oFetchNode.loader = void 0, void i.ToLoadCtr(_, !0)) : ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]##IOController.ToFetch() >>CDN _onError() ".format(y("hh:mm:ss:S", new Date), i.config.mediaType), i.config.mdebug && console.log(n), i.config.debugger(n)), i.config.stopLoadedFlag = !0, i.cdnErrReportCount++, void(2 < i.cdnErrReportCount || 400 < o.code ? i.ErrorQuitActively("oFetchNode._onError()", o.msg) : 0 != i.range_end && i.app && i.app.Error("oFetchNode._onError()", o.code, o.msg))) : void(i.oFetchNode.loader = void 0, i.ToLoadCtr(_, !0))
                            }
                        }, i.oFetchNode._onComplete = function(e, o) {
                            if (i.clearFetchTimeout(), !0 != i.destroyed && i.app) {
                                if (i.oFetchNode.loader && 0 < i.oFetchNode.loader.nTimeOutCount && (i.oFetchNode.loader.nTimeOutCount = 0), i.app.updateBufferLen(!0), i.dispatcher && 0 < i.config.filesize && 0 < i.appendToPlayerPos && (i.dispatcher.progressed = (i.appendToPlayerPos / i.config.filesize).toFixed(2)), i.oFetchNode && i.oFetchNode.cdnType == T && i.UpdateTimeToSessionInfo(i.config.mediaType), i.oFetchNode.loader && 10 < i.config.bufferLen) {
                                    var t = i.oFetchNode.loader.downbytes - i.oFetchNode.loader.reportdownbytes;
                                    t > i.config.ReportMinSize && i.dispatcher && i.dispatcher.UploadFlowReport(0)
                                }
                                var n = 0,
                                    a = 0,
                                    d = 0;
                                if (i.oFetchNode.loader && (i.oFetchNode.loader.nCompleteCount++, 3 < i.oFetchNode.loader.nCompleteCount && 0 < i.oFetchNode.loader.weight && (i.oFetchNode.loader.weight = 1), 15 < i.oFetchNode.loader.nCompleteCount && (i.oFetchNode.loader.timeoutCnt = 0, i.oFetchNode.loader.timeoutDown = 0), 10 < i.oFetchNode.loader.nCompleteCount && 0 < i.cdnErrReportCount && (i.cdnErrReportCount = 0), n = i.oFetchNode.loader.Onedowntimes, a = i.oFetchNode.loader.speed, d = i.oFetchNode.loader.nodetype), (0 < i.config.iSaveWaitLog || i.config.mdebug) && i.dispatcher) {
                                    var c = i.dispatcher.loadInfo;
                                    0 < c.cdnLoaded && 0 < c.scdnLoaded && (i.config.fShare = (c.scdnLoaded / (c.cdnLoaded + c.scdnLoaded)).toFixed(2));
                                    var s = "[{0}][{1}]#IOController.ToFetch() onComplete NodeType[{2}] useTime[{3}]ms speed[{4}]KB/s  appendCount[{5}] byteStart[{6}] byteEnd[{7}] size[{8}][{9}] bufferLen[{10}] loadinfo.cdn[{11}] loadinfo.scdn[{12}] fShare[{13}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, d, n, a, i.config.appendCount, e, o, i.oFetchNode._size, i.oFetchNode._contentLength, i.config.bufferLen.toFixed(2), c.cdnLoaded, c.scdnLoaded, i.config.fShare);
                                    i.config.mdebug && console.log(s), i.config.debugger(s)
                                }
                                return (i.CacheRangeComplete(), 0 == i.stat.first_cdn_time && (i.stat.first_cdn_time = new Date().getTime() - r), 0 < i.config.filesize && o >= i.config.filesize - 1) ? ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (s = "[{0}][{1}]#IOController.ToFetch() >>callback file onComplete() filesize[{2}] fShare[{3}] byteEnd[{4}] appendToPlayerPos[{5}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.config.filesize, i.config.fShare, o, i.appendToPlayerPos), i.config.mdebug && console.log(s), i.config.debugger(s)), i.bPlayEnd = !0, i.dispatcher && i.dispatcher.FlowReport(0), i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("oFetchNode._onComplete()"))) : (i.oFetchNode.loader && i.oFetchNode.loader.nodetype == T && i.oFetchNode.loader.responseURL && 0 < i.oFetchNode.loader.responseURL.length && (i.config.mdebug && console.log("[%s][%s]IOController.ToFetch() scdn return 302 remove node", y("hh:mm:ss:S", new Date), i.config.mediaType), i.dispatcher && i.dispatcher.removeObj(i.oFetchNode.loader, i.dispatcher.downloaders), i.oFetchNode.loader = void 0, i.bNotNeedQueryNode = !0, i.queryNode()), 0 == i.config.filesize && i.oFetchNode._receivedLength < i.oFetchNode._size ? ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (s = "[{0}][{1}]##IOController.ToFetch() >>filesize==0 _receivedLength[{2}][{3}] onComplete()".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode._receivedLength, i.oFetchNode._size), i.config.mdebug && console.log(s), i.config.debugger(s)), i.dispatcher && i.dispatcher.FlowReport(0), i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("oFetchNode._onComplete()"))) : 0 == i.config.filesize && -1 == i.oFetchNode._size && 0 < i.config.RangeErrCount ? ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (s = "[{0}][{1}]##IOController.ToFetch() >>filesize==0 _size[{2}] onComplete()".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode._size), i.config.mdebug && console.log(s), i.config.debugger(s)), i.dispatcher && i.dispatcher.FlowReport(0), i.config.stopLoadedFlag = !0, void(i.app && i.app.Complete("oFetchNode._onComplete()"))) : i.appendToPlayerPos >= i.range_end && 0 < i.range_end ? ((0 < i.config.iSaveWaitLog || i.config.mdebug) && (s = "[{0}][{1}]#IOController.ToFetch() one Range End onComplete() appendToPlayerPos[{2}] range_end[{3}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.appendToPlayerPos, i.range_end), i.config.mdebug && console.log(s), i.config.debugger(s)), i.config.stopLoadedFlag = !0, i.CheckSameRange(), void(i.app && i.app.Complete("oFetchNode._onComplete()"))) : void((7 == i.config.iFastReply || 10 == i.config.iFastReply) && !i.oFetchNode.bSignalAbort && (i.bFetchSupported = !1), i.config.appendCount = 0, i.requestTimeId = setTimeout(function() {
                                    clearTimeout(i.requestTimeId), i.requestTimeId = 0, i.ToLoadCtr(_, !0)
                                }, 50)))
                            }
                        }, i.oFetchNode._onCance = function() {
                            if (i.clearFetchTimeout(), !i.destroyed && i.oFetchNode) {
                                if (i.sameAppendCount = 0, i.dispatcher && i.oFetchNode.loader) {
                                    var e = 0;
                                    e = i.oFetchNode.loader.downbytes - i.oFetchNode.loader.syncdownbytes, 0 < e && (i.oFetchNode.loader.syncdownbytes = i.oFetchNode.loader.downbytes, i.oFetchNode.loader.type == T ? i.dispatcher.loadInfo.scdnLoaded += e : i.dispatcher.loadInfo.cdnLoaded += e)
                                }
                                if (i.app && i.app.updateBufferLen(!0), i.dispatcher && 0 < i.config.filesize && 0 < i.appendToPlayerPos && (i.dispatcher.progressed = (i.appendToPlayerPos / i.config.filesize).toFixed(2)), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                                    var o = "[{0}][{1}]#IOController.ToFetch() _onCancel() cdnType[{2}] from[{3}] size[{4}] byteEnd[{5}] bufferLen[{6}] stopLoadedFlag[{7}] fetchCreateTime[{8}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, i.oFetchNode._range.from, i.oFetchNode._size, i.oFetchNode._range.from + i.oFetchNode._receivedLength - 1, i.config.bufferLen.toFixed(2), i.config.stopLoadedFlag, i.oFetchNode.fetchCreateTime);
                                    i.config.mdebug && console.log(o), i.config.debugger(o)
                                }
                                i.oFetchNode.cdnType == T && 1 < i.config.appendCount && i.UpdateTimeToSessionInfo(i.config.mediaType), !0 == i.config.stopLoadedFlag || (clearTimeout(i.requestTimeOutId), i.requestTimeOutId = setTimeout(function() {
                                    clearTimeout(i.requestTimeOutId), i.requestTimeOutId = 0, i.ToLoadCtr(_, !0)
                                }, 50))
                            }
                        }, i.config.appendCount = 0, 0 < i.config.filesize && (i.oFetchNode._onContentLengthKnown = void 0), 0 == i.config.filesize && 0 < i.config.RangeErrCount && 0 < n.from && 1 > n.to && (d = 0), i.oFetchNode.cdnType == C && i.config.bTimeOutAddTime && i.oFetchNode.loader) {
                        var l = i.oFetchNode.loader.nTimeOutCount;
                        4 < l && (l = 4), p += 1e3 * l
                    }
                    if (0 < i.config.iSaveWaitLog || i.config.mdebug) {
                        g = 0;
                        var m = 0,
                            h = 0;
                        i.oFetchNode.loader && (g = i.oFetchNode.loader.speed, m = i.oFetchNode.loader.updatePreUseTime(d), h = i.oFetchNode.loader.nCompleteCount), f = "[{0}][{1}]IOController.ToFetch() cdnType[{2}] preUseTime[{3}]ms nTimeOut[{4}]ms nodeCount[{5}] currentTime[{6}]s  bufferLen[{7}] range_end[{8}] from[{9}] end[{10}] tmpFetchSize[{11}] fileSize[{12}] bitrate[{13}]kb speed[{14}]KB/s DangerAwayTime[{15}] nCompleteCount[{16}] bTimeOutAddTime[{17}] nTimeOutCount[{18}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, m, p, i.nodeCount, i.config.currentTime.toFixed(2), i.config.bufferLen.toFixed(2), i.range_end, n.from, n.from + d - 1, d, i.config.filesize, i.config.bitrate, g, s, h, i.config.bTimeOutAddTime, i.oFetchNode.loader.nTimeOutCount), i.config.mdebug && console.log(f), i.config.debugger(f)
                    }
                    i.dispatcher && (i.dispatcher.updateSendLen(), i.dispatcher.loadInfo.curUrl = a), i.clearFetchTimeout(), i.sameAppendCount = 0, i.oFetchNode.nTimeOut = p, i.oFetchNode.open(a, d - 1, n.from, 5e3), 0 == i.stat.first_cdn_byte && (i.stat.first_cdn_byte = d), i.EmptyBuffer(i.oFetchNode.loader, 15, 1), i.FetchTimeOutId = setTimeout(function() {
                        if (0 != i.FetchTimeOutId) {
                            if (3 < i.config.iSaveWaitLog && (i.config.iSaveLogCount = 0), 5 < i.config.iSaveWaitLog && i.config.ErrCount++, i.clearFetchTimeout(), i.oFetchNode.abort(), i.app && i.app.updateBufferLen(!0), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                                var o = "[{0}][{1}]##IOController.ToFetch()>>self.NodeTimeOut()  cdnType[{2}] TimeOut[{3}] bufferLen[{4}] DangerAwayTime[{5}] range[{6}] waitNum[{7}] sCancelNum[{8}] size[{9}] ErrCount[{10}] url[{11}]".format(y("hh:mm:ss:S", new Date), i.config.mediaType, i.oFetchNode.cdnType, p, i.config.bufferLen.toFixed(2), s, i.oFetchNode.strRange, i.config.waitNum, i.config.sCanceNum, i.oFetchNode._size, i.config.ErrCount, e);
                                i.config.mdebug && console.log(o), i.config.debugger(o)
                            }(t == S || t == L) && i.oFetchNode.loader && i.oFetchNode.loader.sdkTimeout++, i.EmptyBuffer(i.oFetchNode.loader, 10, 0), i.NodeTimeOut(p), clearTimeout(i.requestTimeOutId), i.requestTimeOutId = setTimeout(function() {
                                clearTimeout(i.requestTimeOutId), i.requestTimeOutId = 0, i.ToLoadCtr(_, !0)
                            }, 50)
                        }
                    }, p)
                }
            }, n.prototype.EmptyBuffer = function(e, o, t) {
                var n = this;
                if (e && n.app && 0 != n.range_end && 0 != n.NoDataCount && (n.config.bufferLen > o && n.config.iFastReply > t && e.type == T || 20 < n.config.bufferLen && 5 < n.config.iFastReply || 4 < n.config.bufferLen && 6 < n.config.iFastReply || 8 < n.config.iFastReply)) {
                    if (0 < n.config.iSaveWaitLog || n.config.mdebug) {
                        var i = "[{0}][{1}]##IOController.EmptyBuffer() nodeTpye[{2}] bufferLen[{3}] appendToPlayerPos[{4}]".format(y("hh:mm:ss:S", new Date), n.config.mediaType, e.nodetype, n.config.bufferLen.toFixed(2), n.appendToPlayerPos);
                        n.config.mdebug && console.log(i), n.config.debugger(i)
                    }
                    n.NoDataCount = 0, n.app.DataArrival("EmptyBuffer()", "", n.appendToPlayerPos)
                }
            }, n.prototype.appendBuffer = function(e, o) {
                var t = this;
                if (t.app) {
                    if (t.config.appendCount++, 0 > t.range_end) return void t.app.DataArrival("IOController.appendBuffer()", o, e);
                    var n = e + o.length;
                    if (t.config.bSdkCache && 0 < t.CacheBufSize) {
                        if (t.appendCacheCount++, 0 < t.range_end && t.app.DataArrival("IOController.appendBuffer()", "", t.appendToPlayerPos), n <= t.curCacheEnd + 1 && 0 < t.curCacheEnd) return t.config.mdebug && 2 > t.appendCacheCount && console.log("[%s][%s]IOController.appendBuffer() start Add To Cache CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] curCacheEnd[%d] appendCacheEnd[%d] bytesAvailable[%d] tmpFetchSize[%d] chunk.length[%d]", y("hh:mm:ss:S", new Date), t.config.mediaType, t.CacheBufSize, t.curRecvPosition, t.curCacheStart, t.curCacheEnd, t.appendCacheEnd, t.bytesAvailable, t.curCacheEnd - t.appendCacheEnd + 1, o.length), 0 == t.curCacheStart && (t.curCacheStart = e), t.CacheBytes.set(o, t.curRecvPosition), t.curRecvPosition += o.length, t.bytesAvailable += o.length, t.appendCacheEnd = e + o.length, void((!(0 < t.config.waitNum && 0 == t.config.bufferLen && 0 < t.config.delayLevel) || 0 < t.range_end && t.bytesAvailable > (t.config.delayLevel + 1) * (t.range_end - t.range_start) || t.bytesAvailable > t.CacheBufSize / 2) && t.CheckBufferCache());
                        if (n > t.curCacheEnd && e <= t.curCacheEnd) {
                            0 == t.curCacheStart && (t.curCacheStart = e), t.appendCacheEnd = e + r.length;
                            var i = t.curCacheEnd - e + 1,
                                r = o.subarray(0, i);
                            return t.CacheBytes.set(r, t.curRecvPosition), t.curRecvPosition += r.length, t.bytesAvailable += r.length, t.config.mdebug && console.log("[%s][%s]IOController.appendBuffer() End1 CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] appendCacheEnd[%d] bytesAvailable[%d] chunk.length[%d]", y("hh:mm:ss:S", new Date), t.config.mediaType, t.CacheBufSize, t.curRecvPosition, t.curCacheStart, t.appendCacheEnd, t.bytesAvailable, o.length), void t.CheckBufferCache()
                        }
                        t.config.mdebug && console.log("[%s][%s]IOController.appendBuffer() End2 CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] appendCacheEnd[%d] bytesAvailable[%d] chunk.length[%d]", y("hh:mm:ss:S", new Date), t.config.mediaType, t.CacheBufSize, t.curRecvPosition, t.curCacheStart, t.appendCacheEnd, t.bytesAvailable, o.length)
                    } else {
                        if (n <= t.range_end + 1 && 0 < t.range_end) return void t.app.DataArrival("IOController.appendBuffer()", o, e);
                        if (n > t.range_end && e <= t.range_end) return i = t.range_end - e + 1, r = o.subarray(0, i), void t.app.DataArrival("IOController.appendBuffer()", o, e)
                    }
                    t.config.mdebug && console.log("[%s][%s]IOController.appendBuffer() End CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] curCacheEnd[%d] appendCacheEnd[%d] bytesAvailable[%d] chunk.length[%d]", y("hh:mm:ss:S", new Date), t.config.mediaType, t.CacheBufSize, t.curRecvPosition, t.curCacheStart, t.curCacheEnd, t.appendCacheEnd, t.bytesAvailable, o.length), t.config.stopLoadedFlag = !0, t.ClearLoader("IOController.appendBuffer()")
                }
            }, n.prototype.CacheRangeComplete = function() {
                var e = this;
                if (e.config.bSdkCache && 0 < e.curCacheStart) {
                    if (e.appendCacheEnd >= e.curCacheEnd && 0 < e.curCacheEnd) return e.config.stopLoadedFlag = !0, e.config.bSdkCache && 0 < e.range_end && e.CheckBufferCache(), void((0 < e.config.iSaveWaitLog || e.config.mdebug) && e.dispatcher && (o = "[{0}][{1}]#IOController.CacheRangeComplete() onComplete One Cache End start[{2}] end[{3}] appendToPlayerPos[{4}] appendCacheEnd[{5}] curCacheStart[{6}] curCacheEnd[{7}] bytesAvailable[{8}] ".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.range_start, e.range_end, e.appendToPlayerPos, e.appendCacheEnd, e.curCacheStart, e.curCacheEnd, e.bytesAvailable), e.config.mdebug && console.log(o), e.config.debugger(o)));
                    if ((0 < e.config.iSaveWaitLog || e.config.mdebug) && e.dispatcher) {
                        var o = "[{0}][{1}]#IOController.CacheRangeComplete() onComplete start[{2}] end[{3}] appendToPlayerPos[{4}] appendCacheEnd[{5}] curCacheStart[{6}] curCacheEnd[{7}] bytesAvailable[{8}] CacheBufSize[{9}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.range_start, e.range_end, e.appendToPlayerPos, e.appendCacheEnd, e.curCacheStart, e.curCacheEnd, e.bytesAvailable, e.CacheBufSize);
                        e.config.mdebug && console.log(o), e.config.debugger(o)
                    }
                }
            }, n.prototype.CheckBufferCache = function() {
                var e = this;
                e.appendCacheEnd >= e.range_end && 0 < e.range_end && e.range_start >= e.curCacheStart && e.GetBufferFromCache()
            }, n.prototype.InitCache = function(e) {
                var o = this;
                if (2 * e > o.CacheBufSize && 0 < o.CacheBufSize) {
                    var t = o.CacheBytes.subarray(o.curAppendPosition, o.curAppendPosition + o.bytesAvailable);
                    o.config.CacheBufSize = parseInt(2.1 * e), o.CacheBytes = void 0, o.CacheBytes = new Uint8Array(o.config.CacheBufSize), o.CacheBufSize = o.config.CacheBufSize, o.CacheBytes.set(t, 0), o.curAppendPosition = 0, o.curRecvPosition = o.bytesAvailable, o.curCacheEnd = o.curCacheStart + o.CacheBufSize - 1, t = void 0, o.config.mdebug && console.log("[%s][%s]IOController.InitCache()1 CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] curCacheEnd[%d] appendCacheEnd[%d]", y("hh:mm:ss:S", new Date), o.config.mediaType, o.CacheBufSize, o.curRecvPosition, o.curCacheStart, o.curCacheEnd, o.appendCacheEnd)
                }
                return o.config.bSdkCache && 0 == o.CacheBufSize ? (o.ClearCache(!1), 0 < o.config.bitrate && (o.config.CacheBufSize = parseInt(1024 * o.config.CacheTimeSize * (o.config.bitrate / 8)), "audio" == o.config.mediaType && (o.config.CacheBufSize *= 2, 1048576 > o.config.CacheBufSize ? o.config.CacheBufSize = 1048576 : 2097152 < o.config.CacheBufSize && (o.config.CacheBufSize = 2097152))), o.config.CacheBufSize < 2.6 * e && (o.config.CacheBufSize = parseInt(2.6 * e)), o.CacheBytes = new Uint8Array(o.config.CacheBufSize), o.CacheBufSize = o.config.CacheBufSize, o.curCacheEnd = o.range_start + o.CacheBufSize - 1, o.appendCacheEnd = o.range_start, void(o.config.mdebug && console.log("[%s][%s]IOController.InitCache()2 CacheBufSize[%d] curRecvPosition[%d] curCacheStart[%d] curCacheEnd[%d] appendCacheEnd[%d]", y("hh:mm:ss:S", new Date), o.config.mediaType, o.CacheBufSize, o.curRecvPosition, o.curCacheStart, o.curCacheEnd, o.appendCacheEnd))) : void 0
            }, n.prototype.ClearCache = function(e) {
                var o = this;
                if (e && (o.CacheBytes = void 0, o.CacheBufSize = 0), 0 < o.config.iSaveWaitLog || o.config.mdebug) {
                    var t = "[{0}][{1}]IOController.prototype.ClearCache() bClean[{2}]activeTimercount[{3}]".format(y("hh:mm:ss:S", new Date), o.config.mediaType, e, o.config.activeTimercount);
                    o.config.mdebug && console.log(t), o.config.debugger(t)
                }
                o.curRecvPosition = 0, o.curAppendPosition = 0, o.curCacheStart = 0, o.appendCacheEnd = 0, o.curCacheEnd = 0, o.bytesAvailable = 0, o.appendCacheCount = 0, o.ClearLoader("IOController.ClearCache()")
            }, n.prototype.ClearLoader = function(e) {
                var o = this;
                if (o.oFetchNode && o.oFetchNode.isWorking()) {
                    o.clearFetchTimeout(), o.oFetchNode.abort();
                    var t = new Date().getTime();
                    if (!1 == o.config.bCurSignalAbort && 0 == o.oFetchNode._receivedLength && 2500 < t - o.iLastSwitchTime && (o.iLastSwitchTime = t, o.switchFetch()), 0 < o.config.iSaveWaitLog || o.config.mdebug) {
                        var n = "[{0}][{1}]{2} bufferLen[{3}] cdnType[{4}]  fetchCreateTime[{5}] FetchNode.isWorking() FetchNode.abort() receivedLength[{6}] intervalTime[{7}]ms".format(y("hh:mm:ss:S", new Date), o.config.mediaType, e, o.config.bufferLen.toFixed(2), o.oFetchNode.cdnType, o.oFetchNode.fetchCreateTime, o.oFetchNode._receivedLength, t - o.iLastSwitchTime);
                        o.config.mdebug && console.log(n), o.config.debugger(n)
                    }
                }
                o.curLoader && !o.curLoader.httpIdel() && o.curLoader.abort()
            }, n.prototype.ErrorQuitActively = function(e, o) {
                var t = this;
                if (t.config.stopLoadedFlag = !0, 0 < t.config.iSaveWaitLog || t.config.mdebug) {
                    var n = "[{0}][{1}]##IOController.ErrorQuitActively() {2} sdk quit msg[{3}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, e, o);
                    t.config.mdebug && console.log(n), t.config.debugger(n)
                }
                var i = "fetch";
                t.bFetchSupported || (i = "xhr"), t.hdCdn.AddErrMsgArry({
                    err_code: 4203,
                    err_msg: o,
                    err_pos: 27,
                    node_type: t.hdCdn.nodetype,
                    sCanceNum: t.hdCdn.timeoutCnt,
                    send_length: t.config.send_length,
                    waitNum: t.config.waitNum,
                    bufferLen: t.config.bufferLen.toFixed(2),
                    pull_type: i,
                    range: "",
                    rangeSize: 0,
                    timeout: 0,
                    useTime: 0,
                    usetimes: t.hdCdn.usetimes,
                    url: t.hdCdn.uri
                }), 0 != t.range_end && t.app && t.app.Error(e, 4203, o)
            }, n.prototype.clearFetchTimeout = function() {
                var e = this;
                0 < e.FetchTimeOutId && (clearTimeout(e.FetchTimeOutId), e.FetchTimeOutId = 0)
            }, n.prototype.NodeTimeOut = function(e) {
                var o = this;
                if (o.oFetchNode && void 0 != o.oFetchNode) {
                    if (o.oFetchNode.loader && (o.oFetchNode.loader.downfails++, o.oFetchNode.loader.timeoutCnt++, o.oFetchNode.loader.nCompleteCount = 0, o.oFetchNode.loader.nTimeOutCount++), o.oFetchNode.loader) {
                        o.oFetchNode.loader.weight -= 100 < o.oFetchNode.loader.downbytes ? 0.2 : 0.3, o.oFetchNode.loader.code = o.oFetchNode._status;
                        var t = o.oFetchNode._contentLength + "/" + o.oFetchNode.strRange;
                        if (o.oFetchNode.loader.AddErrMsgArry({
                                err_code: 10,
                                err_msg: "fetch connect TimeOut",
                                err_pos: 24,
                                node_type: o.oFetchNode.loader.nodetype,
                                sCanceNum: o.config.sCanceNum,
                                send_length: o.config.send_length,
                                waitNum: o.config.waitNum,
                                bufferLen: o.config.bufferLen.toFixed(2),
                                pull_type: "fetch",
                                range: t,
                                rangeSize: o.oFetchNode._size,
                                timeout: e,
                                useTime: o.oFetchNode.loader.Onedowntimes,
                                usetimes: o.oFetchNode.loader.usetimes,
                                url: o.oFetchNode.loader.uri
                            }), (0.11 > o.oFetchNode.loader.weight || o.oFetchNode.loader.timeoutCnt > o.config.ScdnMaxTimeOutNum || o.oFetchNode.loader.timeoutDown > o.config.ScdnMaxTimeOutNum) && o.oFetchNode.loader.type == T) {
                            o.dispatcher && 3 < o.config.bufferLen && o.dispatcher.ErrLogReport();
                            var n = o.oFetchNode.loader.uri;
                            if (o.dispatcher) {
                                var i = o.oFetchNode.loader.downbytes - o.oFetchNode.loader.reportdownbytes;
                                0 < i && o.dispatcher.FlowReport(0), o.dispatcher.removeObj(o.oFetchNode.loader, o.dispatcher.downloaders), o.oFetchNode.loader = void 0, o.nodeCount = o.dispatcher.downloaders.length
                            }
                            if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                                var r = "[{0}][{1}]##IOController.NodeTimeOut() new loader.length[{2}]  remove scdnNode url[{3}]".format(y("hh:mm:ss:S", new Date), o.config.mediaType, o.nodeCount, n);
                                o.config.mdebug && console.log(r), o.config.debugger(r)
                            }
                        } else if (o.oFetchNode.cdnType == C && o.config.bufferLen < o.config.ExitMinBufLen && (0.11 > o.oFetchNode.loader.weight && o.config.bTimeOutReport || 3 < o.oFetchNode.loader.nTimeOutCount || o.oFetchNode.loader.timeoutCnt > o.config.CdnMaxTimeOutNum)) return (0 < o.config.iSaveWaitLog || o.config.mdebug) && (r = "[{0}][{1}]##IOController.NodeTimeOut() >>CDN timeOut()  nTimeOutCount[{2}] timeoutCnt[{3}]".format(y("hh:mm:ss:S", new Date), o.config.mediaType, o.oFetchNode.loader.nTimeOutCount, o.oFetchNode.loader.timeoutCnt), o.config.mdebug && console.log(r), o.config.debugger(r)), !1 == o.config.bCurSignalAbort && o.switchFetch(), o.config.stopLoadedFlag = !0, void o.ErrorQuitActively("IOController.NodeTimeOut()", "CDN time out too many");
                        o.bNotNeedQueryNode = !0, o.queryNode()
                    }!1 == o.config.bCurSignalAbort && o.switchFetch()
                }
            }, n.prototype.switchFetch = function() {
                var e = this;
                e.oFetchNode && e.oFetchNode.FetchClean(), e.clearFetchTimeout(), e.oFetchNode = void 0, e.oFetchNode = new s(e.config), e.withCredentials && e.oFetchNode && (e.oFetchNode.withCredentials = e.withCredentials)
            }, n.prototype.queryNode = function() {
                var e = this;
                if (!(e.destroyed || e.bPlayEnd || null == e.dispatcher || !0 == e.bQueryNode || e.config.bWatch || !e.config.bUseScdn) && !(e.stat.req_dispatch_num > e.config.MaxGetNodesNum - 1 || 1 < e.dispatcher.downloaders.length)) {
                    if (1 == e.dispatcher.downloaders.length && 0 < e.config.NodesTime) {
                        var o = (new Date().getTime() - e.config.NodesTime) / 1e3;
                        o > e.config.noScdnSesTimeOut && (e.bNotNeedQueryNode = !0)
                    }
                    if (e.bNotNeedQueryNode) {
                        e.bQueryNode = !0, e.stat.req_dispatch_num++;
                        var t = new Date().getTime();
                        e.config.NodesTime = t, e.UpdateGetNodeTimeToSessionInfo(e.config.mediaType), g(e.config, function(o) {
                            e.bQueryNode = !1, 0 == e.stat.first_dispatch_msecs && (e.stat.first_dispatch_msecs = new Date().getTime() - t, e.stat.first_dispatch_nodes = o.length), o ? (e.parseNodes(o), e.WriteNodeToSessionInfo(e.config.mediaType, o)) : null != e.dispatcher && void 0 != e.dispatcher && (e.dispatcher.noMoreNodes = !0), e.destroyed || e.bPlayEnd
                        })
                    }
                }
            }, n.prototype.parseNodes = function(e) {
                var o = this;
                if (o.config.bUseScdn) {
                    if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                        var t = "[{0}][{1}]IOController.parseNodes nodes[{2}] ".format(y("hh:mm:ss:S", new Date), o.config.mediaType, JSON.stringify(e));
                        o.config.mdebug && console.log(t), o.config.debugger(t)
                    }
                    for (var n = 0; n < e.length; ++n) {
                        var i = e[n],
                            r = i.uri.split("?")[0];
                        if (-1 === o.nodeList.indexOf(r) && i.uri) {
                            o.nodeList.push(r);
                            var a = new u(i.uri, i.type, i.nodetype, {
                                mediaType: o.config.mediaType,
                                config: o.config
                            });
                            null != o.dispatcher && void 0 != o.dispatcher && (o.dispatcher.addNode(a), o.nodeCount = o.dispatcher.downloaders.length)
                        }
                    }
                    o.app && o.app.updateBufferLen(!0)
                }
            }, n.prototype.readCfgFromLocal = function() {
                var e = this;
                if (window.localStorage && window.localStorage.objcfg && 10 < window.localStorage.objcfg.length) {
                    var o = JSON.parse(window.localStorage.objcfg),
                        t = new Date().getTime();
                    o && o.local_ts && o.data && o.data.conf && (o && 0 < o.server_ts && (e.config.server_ts = o.server_ts + (t - o.local_ts)), e.parseConfig(o)), o.local_ts && (t - o.local_ts) / 1e3 > 900 && (e.config.server_ts = 0, e.config.bInitConfig = !1)
                } else if (!window.localStorage && (0 < e.config.iSaveWaitLog || e.config.mdebug)) {
                    var n = "[{0}][{1}]IOController.readCfgFromLocal fail not Supported localStorage".format(y("hh:mm:ss:S", new Date), e.config.mediaType);
                    e.config.mdebug && console.log(n), e.config.debugger(n)
                }
            }, n.prototype.reqcloudcfg = function() {
                var e = this;
                e.config.bInitConfig || e.readCfgFromLocal(), e.config.bInitConfig && e.queryNode();
                e.destroyed || e.bPlayEnd || void 0 != e.cloudCfg || e.config.bInitConfig || (this.cloudCfg = new h(function(o, t) {
                    if (e.config.server_ts = e.cloudCfg.server_ts, !e.destroyed) {
                        if (e.queryNode(), 0 !== o) {
                            if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                                var n = "[{0}][{1}]IOController.reqcloudcfg  errorcode[{2}] ".format(y("hh:mm:ss:S", new Date), e.config.mediaType, o);
                                e.config.mdebug && console.log(n), e.config.debugger(n)
                            }
                            return
                        }
                        if (t && 1 < t.length) {
                            var i = JSON.parse(t);
                            i.ok && (i.server_ts = e.config.server_ts, i.local_ts = new Date().getTime(), e.parseConfig(i), window.localStorage && window.localStorage.setItem("objcfg", JSON.stringify(i)))
                        }
                    }
                }, 4e3, e.config))
            }, n.prototype.parseConfig = function(e) {
                var o = this,
                    t = e.data.conf;
                if (t && (o.config.bInitConfig = !0, t.lmrtc && 0 < t.lmrtc && (o.config.limitrtc = t.lmrtc), t.xhrCdnSize && 7 < t.xhrCdnSize && (2097152 > t.xhrCdnSize ? o.config.xhrCdnSize = parseInt(t.xhrCdnSize) : o.config.xhrCdnSize = 2097152), t.cdnTimeout && 5e3 < t.cdnTimeout && (o.config.cdnTimeout = t.cdnTimeout), t.MaxWaitLogNum && 100 < t.MaxWaitLogNum && (o.config.MaxWaitLogNum = t.MaxWaitLogNum), t.MinCacheTime && 0 < t.MinCacheTime && (o.config.MinCacheTime = t.MinCacheTime), t.MidCacheTime && 0 < t.MidCacheTime && (o.config.MidCacheTime = t.MidCacheTime), t.GoodCacheTime && 0 < t.GoodCacheTime && (o.config.GoodCacheTime = t.GoodCacheTime), (!0 == t.UploadLog || !1 == t.UploadLog) && "video" == o.config.mediaType && (o.config.UploadLog = t.UploadLog), t.UploadLogInterval && 0 < t.UploadLogInterval && (o.config.UploadLogInterval = t.UploadLogInterval), t.UploadQualityInterval && 0 < t.UploadQualityInterval && (o.config.UploadQualityInterval = t.UploadQualityInterval), t.UploadFlowInterval && 0 < t.UploadFlowInterval && (o.config.UploadFlowInterval = t.UploadFlowInterval), t.MaxGetNodesNum && 0 < t.MaxGetNodesNum && (o.config.MaxGetNodesNum = t.MaxGetNodesNum), (!0 == t.bUseScdn || !1 == t.bUseScdn) && (o.config.bUseScdn = t.bUseScdn), t.scdnSizeCtr && (204800 < t.scdnSizeCtr.b && (o.config.scdnSizeCtr.b = parseInt(t.scdnSizeCtr.b)), 1024000 < t.scdnSizeCtr.c && (o.config.scdnSizeCtr.c = parseInt(t.scdnSizeCtr.c))), t.scdnTimeOutCtr && (t.scdnTimeOutCtr.b && (o.config.scdnTimeOutCtr.b = t.scdnTimeOutCtr.b), t.scdnTimeOutCtr.c && (o.config.scdnTimeOutCtr.c = t.scdnTimeOutCtr.c), 19000 < t.scdnTimeOutCtr.d && (o.config.scdnTimeOutCtr.d = t.scdnTimeOutCtr.d), 15000 < t.scdnTimeOutCtr.e && (o.config.scdnTimeOutCtr.e = t.scdnTimeOutCtr.e), 1e4 < t.scdnTimeOutCtr.f && (o.config.scdnTimeOutCtr.f = t.scdnTimeOutCtr.f)), t.bufLenCtr && (t.bufLenCtr.a && (o.config.bufLenCtr.a = t.bufLenCtr.a), t.bufLenCtr.b && 4 < t.bufLenCtr.b && (o.config.bufLenCtr.b = t.bufLenCtr.b), t.bufLenCtr.c && 15 < t.bufLenCtr.b && (o.config.bufLenCtr.c = t.bufLenCtr.c)), t.fetchCdnSize && 1048576 < t.fetchCdnSize && (o.config.fetchCdnSize = parseInt(t.fetchCdnSize)), t.fetchScdnSize && 1048576 < t.fetchScdnSize && (o.config.fetchScdnSize = parseInt(t.fetchScdnSize)), t.AudioFetchBufSize && 261120 < t.AudioFetchBufSize && (o.config.AudioFetchBufSize = t.AudioFetchBufSize), t.QueryNodeInterval && 29 < t.QueryNodeInterval && (o.config.QueryNodeInterval = t.QueryNodeInterval), t.ReportMinSize && 2097152 < t.ReportMinSize && 104857600 > t.ReportMinSize && (o.config.ReportMinSize = t.ReportMinSize), t.fetchCdnFirstTimeOut && 800 < t.fetchCdnFirstTimeOut && 8e3 > t.fetchCdnFirstTimeOut && (o.config.fetchCdnFirstTimeOut = t.fetchCdnFirstTimeOut), t.fetchScdnFirstTimeOut && 800 < t.fetchScdnFirstTimeOut && 8e3 > t.fetchScdnFirstTimeOut && (o.config.fetchScdnFirstTimeOut = t.fetchScdnFirstTimeOut), t.scdnSesTimeOut && 0 < t.scdnSesTimeOut && (o.config.scdnSesTimeOut = t.scdnSesTimeOut), t.noScdnSesTimeOut && 0 < t.noScdnSesTimeOut && (o.config.noScdnSesTimeOut = t.noScdnSesTimeOut), t.iSaveWaitLog && 0 < t.iSaveWaitLog && !o.config.bWatch && (o.config.iSaveWaitLog = t.iSaveWaitLog), t.UploadWaitLogInterval && 9 < t.UploadWaitLogInterval && (o.config.UploadWaitLogInterval = t.UploadWaitLogInterval), (!0 == t.UploadWaitLog || !1 == t.UploadWaitLog) && ("video" == o.config.mediaType || "watch" == o.config.mediaType) && (o.config.UploadWaitLog = t.UploadWaitLog), t.fetchFirstSize && 153600 < t.fetchFirstSize && (o.config.fetchFirstSize = t.fetchFirstSize), t.xhrFirstSize && 64512 < t.xhrFirstSize && (o.config.xhrFirstSize = t.xhrFirstSize), t.xhrPartitionSize && 262144 < t.xhrPartitionSize && (o.config.xhrPartitionSize = t.xhrPartitionSize), (!0 == t.bFetchSupported || !1 == t.bFetchSupported) && (o.config.bFetchSupported = t.bFetchSupported), o.config.bFetchSupported || (o.bFetchSupported = !1, o.config.bCurFetchSupported = !1), (1 == t.iErr403 || 0 == t.iErr403) && (o.config.iErr403 = t.iErr403), (0 == t.iFailToFetch || 1 == t.iFailToFetch || 2 == t.iFailToFetch || 3 == t.iFailToFetch) && (o.config.iFailToFetch = t.iFailToFetch), (0 == t.iErrEarlyEOF || 1 == t.iErrEarlyEOF || 2 == t.iErrEarlyEOF || 3 == t.iErrEarlyEOF) && (o.config.iErrEarlyEOF = t.iErrEarlyEOF), e.data && e.data.ver && (o.config.conf_v = e.data.ver), 1048576 < t.xhrMaxBufSize && (o.config.xhrMaxBufSize = t.xhrMaxBufSize), 12000 < t.preMaxUseTime && (o.config.preMaxUseTime = t.preMaxUseTime), (!1 == t.bTimeOutReport || !0 == t.bTimeOutReport) && (o.config.bTimeOutReport = t.bTimeOutReport), (!1 == t.bTimeOutAddTime || !0 == t.bTimeOutAddTime) && (o.config.bTimeOutAddTime = t.bTimeOutAddTime), !1 == o.config.bSdkCache && (!1 == t.bSdkCache || !0 == t.bSdkCache) && (o.config.bSdkCache = t.bSdkCache), t.CacheBufSize && 1047552 < t.CacheBufSize && (o.config.CacheBufSize = t.CacheBufSize, "audio" == o.config.mediaType && (o.config.CacheBufSize = 1048576)), t.CacheTimeSize && 3 < t.CacheTimeSize && (o.config.CacheTimeSize = t.CacheTimeSize, 0 < o.config.bitrate && (o.config.CacheBufSize = parseInt(1024 * t.CacheTimeSize * (o.config.bitrate / 8)))), (0 == t.delayLevel || 1 == t.delayLevel || 2 == t.delayLevel) && (o.config.delayLevel = t.delayLevel), t.allowMaxWaitNum && 1 < t.allowMaxWaitNum && (o.config.allowMaxWaitNum = t.allowMaxWaitNum), t.CdnMaxTimeOutNum && 1 < t.CdnMaxTimeOutNum && (o.config.CdnMaxTimeOutNum = t.CdnMaxTimeOutNum), t.ScdnMaxTimeOutNum && 1 < t.ScdnMaxTimeOutNum && (o.config.ScdnMaxTimeOutNum = t.ScdnMaxTimeOutNum), t.FetchNotSupportMark && 0 < t.FetchNotSupportMark.length && (o.config.FetchNotSupportMark = t.FetchNotSupportMark), t.LowBroswerVer && 0 < t.LowBroswerVer.length && (o.config.LowBroswerVer = t.LowBroswerVer), (!1 == t.bSdkAbort || !0 == t.bSdkAbort) && (o.config.bSdkAbort = t.bSdkAbort), (!1 == t.UploadFlowData || !0 == t.UploadFlowData) && (o.config.UploadFlowData = t.UploadFlowData), (!1 == t.UploadErrLog || !0 == t.UploadErrLog) && (o.config.UploadErrLog = t.UploadErrLog), (!1 == t.bFetchSignalAbort || !0 == t.bFetchSignalAbort) && (o.config.bFetchSignalAbort = t.bFetchSignalAbort), (!1 == t.bCtrRagneSize || !0 == t.bCtrRagneSize) && (o.config.bCtrRagneSize = t.bCtrRagneSize), (!1 == t.bHeartbeat || !0 == t.bHeartbeat) && "audio" == o.config.mediaType && (o.config.bHeartbeat = t.bHeartbeat), 3 < t.ExitMinBufLen && (o.config.ExitMinBufLen = t.ExitMinBufLen), 0 < t.iFastReply && (o.config.iFastReply = t.iFastReply), t.ToReplaceDomain && 0 < t.ToReplaceDomain.length && (o.config.ToReplaceDomain = t.ToReplaceDomain), o.checkBroswer(), o.config.bCurFetchSupported = o.bFetchSupported, 0 < o.config.iSaveWaitLog || o.config.mdebug)) {
                    var n = "[{0}][{1}]IOController.parseConfig  bFetchSupported[{2}] objConf[{3}] ".format(y("hh:mm:ss:S", new Date), o.config.mediaType, o.bFetchSupported, JSON.stringify(e));
                    o.config.mdebug && console.log(n), o.config.debugger(n)
                }
            }, n.prototype.checkBroswer = function() {
                var e = this;
                if (e.bFetchSupported && navigator && navigator.userAgent) {
                    var o = navigator.userAgent.toLowerCase();
                    if (e.config.FetchNotSupportMark && 0 < e.config.FetchNotSupportMark.length)
                        for (var t = 0; t < e.config.FetchNotSupportMark.length; t++)
                            if (-1 < o.indexOf(e.config.FetchNotSupportMark[t])) return void(e.bFetchSupported = !1);
                    var n = a();
                    if (n && n.broswer && e.config.LowBroswerVer && 0 < e.config.LowBroswerVer.length) {
                        if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                            var i = "[{0}][{1}]IOController.checkBroswer()  bFetchSupported[{2}] Broswer[{3}] ua[{4}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.bFetchSupported, JSON.stringify(n), o);
                            e.config.mdebug && console.log(i), e.config.debugger(i)
                        }
                        for (t = 0; t < e.config.LowBroswerVer.length; t++)
                            if (n.broswer == e.config.LowBroswerVer[t].broswer && parseInt(n.version) <= e.config.LowBroswerVer[t].version) return void(e.bFetchSupported = !1)
                    }
                }
            }, n.prototype.startTimer = function() {
                var e = this;
                e.timerFlag || (e.timerFlag = !0, e.timeInterval = setInterval(function() {
                    if (!(e.destroyed || e.bPlayEnd || !1 == e.config.hasSteupded || !e.dispatcher)) {
                        if (e.config.activeTimercount++, e.config.timercount++, e.app && 0 < e.CacheBufSize && 70 < e.config.activeTimercount && (e.ClearCache(!0), e.config.stopLoadedFlag = !0), e.app) {
                            if (!e.config.bWatch && !e.app.onDataArrival) return;
                            e.app.updateBufferLen(!0)
                        }
                        if (3 > e.dispatcher.FlowReportCount && (e.config.bufferLen < e.config.MinCacheTime ? e.stat.mincache_times++ : e.config.bufferLen < e.config.MidCacheTime ? e.stat.midcache_times++ : e.stat.goodcache_times++), 0 == e.config.timercount % e.config.UploadWaitLogInterval && e.config.UploadWaitData(), !e.config.bWatch) {
                            if (e.config.bHeartbeat && 30 < e.config.bufferLen && e.Heartbeat && 0 == e.config.timercount % e.Heartbeat.next_interval && e.Heartbeat.start(), 0 == e.config.timercount % 300 && (e.nodeList = []), 0 == e.stat.req_dispatch_num && 0 < e.CompleteCount && e.reqcloudcfg(), e.config.bUseScdn && 1 == e.dispatcher.downloaders.length && 0 == e.config.timercount % e.config.QueryNodeInterval && 4 < e.config.timercount && 50 > e.config.activeTimercount && 0 < e.CompleteCount && e.stat.req_dispatch_num < e.config.MaxGetNodesNum && (e.config.mdebug && console.log("[%s][%s]IOController.startTimer()>>queryNode() setupTime[%d] req_dispatch_num[%d]", y("hh:mm:ss:S", new Date), e.config.mediaType, e.config.setupTime, e.stat.req_dispatch_num), e.bNotNeedQueryNode = !1, e.queryNode()), e.config.UploadFlowData && 0 == e.config.timercount % e.config.UploadFlowInterval) {
                                var o = 5;
                                if (e.dispatcher && 0.85 < e.dispatcher.progressed && (o = 1), 0 == e.config.timercount % (e.config.UploadFlowInterval * o)) e.dispatcher.FlowReport(0);
                                else {
                                    var t = e.dispatcher.loadInfo.cdnLoaded + e.dispatcher.loadInfo.scdnLoaded - e.dispatcher.loadInfo.reportdownbytes;
                                    t > e.config.ReportMinSize && e.dispatcher.FlowReport(0)
                                }
                                e.dispatcher.ErrLogReport()
                            }
                            0 == e.config.timercount % 15 && 0 < e.config.waitNum && 0 < e.config.iSaveWaitLog && 1 > e.config.iSaveLogCount && 3 > e.config.iAllSaveLogCount && (e.config.timercount - e.config.iLastSaveLogTime > e.config.UploadLogInterval || 0 == e.config.iLastSaveLogTime) && (e.config.logReport.saveLog(), e.config.iSaveLogCount++, e.config.iAllSaveLogCount++, e.config.iLastSaveLogTime = e.config.timercount), 0 == e.config.timercount % 15 && 0 < e.config.ErrCount && 3 < e.config.iSaveWaitLog && 1 > e.config.iSaveLogCount && 3 > e.config.iAllSaveLogCount && (e.config.timercount - e.config.iLastSaveLogTime > e.config.UploadLogInterval || 0 == e.config.iLastSaveLogTime) && (e.config.logReport.saveLog(), e.config.iSaveLogCount++, e.config.iAllSaveLogCount++, e.config.iLastSaveLogTime = e.config.timercount), !0 == e.config.UploadLog && 3 > e.dispatcher.FlowReportCount && (e.dispatcher && e.dispatcher.updateSendLen(), 0 == e.config.timercount % e.config.UploadQualityInterval && e.config.bufferLen > e.config.MinCacheTime && 512000 < e.config.send_length && e.stat.send(e.stat.SCDN_DASHSDK_QUALITY, {
                                upload_type: 1
                            })), !0 == e.config.stopLoadedFlag || (e.ToLoadCtr(_, !0), e.NoDataCount++)
                        }
                    }
                }, 1e3))
            }, n.prototype._initsingal = function() {
                var e = this;
                if (!(e.destroyed || e.bPlayEnd)) {
                    if (0 == e.stat.req_dispatch_num && 0 < e.CompleteCount && e.reqcloudcfg(), 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                        var o = "[{0}][{1}]IOController._initsingal() end loader.length[{2}] setupTime[{3}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.nodeCount, e.config.setupTime);
                        e.config.mdebug && console.log(o), e.config.debugger(o)
                    }
                    e.config.UploadWaitData(), 0 < e.stat.first_screen && e.config.UploadLog && !e.config.bWatch && (e.dispatcher && e.dispatcher.updateSendLen(), !e.config.bWatch && e.config.UploadLog && !e.stat.bSendQuality && e.stat.send(e.stat.SCDN_DASHSDK_QUALITY, {
                        upload_type: 0
                    }))
                }
            }, n.prototype._startPlaying = function() {
                var e = this,
                    o = 40,
                    t = [];
                t.push(e.hdCdn);
                var n = new f(t, e.config);
                e.dispatcher = n, e.dispatcher.app = e.app, e.config.bufferLen = e.app.buffering(), e.hdNode && (e.dispatcher._setupHttp(e.hdNode), e.dispatcher.hdNode = e.hdNode), n.on("error", function(o, t) {
                    e.app && (e.cdnErrReportCount++, 2 < e.cdnErrReportCount && e.ErrorQuitActively("dispatcher.on('error'", t))
                }), n.on("needmorenodes", function() {
                    e.queryNode()
                }), n.on("needsource", function() {}), n.on("hdError", function(o, t, n) {
                    if (!(!0 == e.config.stopLoadedFlag || e.destroyed)) {
                        if (3 < e.config.iSaveWaitLog && (e.config.iSaveLogCount = 0), e.config.ErrCount++, o.type == C && e.config.AllErrCount++, e.EmptyBuffer(o, 15, 0), 0 == e.config.filesize && 416 == t && (e.config.RangeErrCount++, e.config.xhrioPreEnd)) {
                            if (e.bPlayEnd = !0, o.errMsgArry = [], 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                                var i = "[{0}][{1}]IOController._startPlaying()>>'hdError' app.Complete()".format(y("hh:mm:ss:S", new Date), e.config.mediaType);
                                e.config.mdebug && console.log(i), e.config.debugger(i)
                            }
                            return e.config.stopLoadedFlag = !0, void(e.app && e.app.Complete("dispatcher.on('hdError')"))
                        }
                        return o.type == C && e.app ? ((0 < e.config.iSaveWaitLog || e.config.mdebug) && (i = "[{0}][{1}]##IOController._startPlaying() on('hdError'>>app.Error()".format(y("hh:mm:ss:S", new Date), e.config.mediaType), e.config.mdebug && console.log(i), e.config.debugger(i)), 0 == o.nodetype && 403 == t && e.hdNode && 1 == e.config.iErr403) ? void(o.iUrlErrStatus = v.errUnrecoverable) : (e.config.stopLoadedFlag = !0, e.cdnErrReportCount++, void(2 < e.cdnErrReportCount || 400 < t ? e.ErrorQuitActively("dispatcher.on('hdError'", n) : 0 != e.range_end && e.app && e.app.Error("dispatcher.on('hdError'", t, n))) : void e.ToLoadCtr(_, !0)
                    }
                }), n.on("timeout", function(t) {
                    if (!(!0 == e.config.stopLoadedFlag || e.destroyed)) {
                        if (3 < e.config.iSaveWaitLog && (e.config.iSaveLogCount = 0), 5 < e.config.iSaveWaitLog && e.config.ErrCount++, 0 < e.requestTimeOutId && (clearTimeout(e.requestTimeOutId), e.requestTimeOutId = 0), e.EmptyBuffer(t, 15, 0), t.type == C && e.app && e.config.bufferLen < e.config.ExitMinBufLen && (0.11 > t.weight && e.config.bTimeOutReport || 3 < t.nTimeOutCount || t.timeoutCnt > e.config.CdnMaxTimeOutNum || t.timeoutDown > e.config.CdnMaxTimeOutNum)) {
                            if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                                var n = "[{0}][{1}]##IOController._startPlaying() on('timeout'>>app.Error()".format(y("hh:mm:ss:S", new Date), e.config.mediaType);
                                e.config.mdebug && console.log(n), e.config.debugger(n)
                            }
                            e.config.stopLoadedFlag = !0, e.ErrorQuitActively("dispatcher.on('timeout'", "CDN time out too many")
                        }
                        e.requestTimeOutId = setTimeout(function() {
                            clearTimeout(e.requestTimeOutId), e.requestTimeOutId = 0, e.ToLoadCtr(_, !0)
                        }, o)
                    }
                }), n.on("onprogress", function(o, t, n) {
                    !0 == e.config.stopLoadedFlag || e.destroyed || 0 < n && 0 < e.range_end && (e.NoDataCount = 0, e.app && e.app.DataArrival("dispatcher.on('onprogress'", "", t))
                }), n.on("data", function(t, n, i) {
                    if (0 < e.requestTimeOutId && (clearTimeout(e.requestTimeOutId), e.requestTimeOutId = 0), !0 != e.config.stopLoadedFlag && !e.destroyed && e.app && t) {
                        e.NoDataCount = 0, e.appendBuffer(n, t), e.appendCacheCount = 0, e.dispatcher && e.dispatcher.updateSendLen(), e.app && e.app.updateBufferLen(!0);
                        if (0 == e.config.filesize && i - n + 1 > t.length && 0 < n && (e.config.xhrioPreEnd = !0), e.curLoader.type == T && e.UpdateTimeToSessionInfo(e.config.mediaType), 15 < e.curLoader.nCompleteCount && 0 < e.cdnErrReportCount && (e.cdnErrReportCount = 0), 0 < e.config.filesize && e.appendToPlayerPos >= e.config.filesize) {
                            if (e.bPlayEnd = !0, 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                                var r = "[{0}][{1}]IOController._startPlaying()>>IOController._startPlaying()>>app.Complete() filesize[{2}] fshare[{3}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.config.filesize, e.config.fShare);
                                e.config.mdebug && console.log(r), e.config.debugger(r)
                            }
                            return e.dispatcher && e.dispatcher.FlowReport(0), e.config.stopLoadedFlag = !0, void(e.app && e.app.Complete("dispatcher.on('data')"))
                        }
                        return e.appendToPlayerPos >= e.range_end + 1 && 0 < e.range_end ? ((0 < e.config.iSaveWaitLog || e.config.mdebug) && (r = "[{0}][{1}]IOController._startPlaying()>>one Range end Complete()  appendToPlayerPos[{2}}] range_end[{3}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.appendToPlayerPos, e.range_end), e.config.mdebug && console.log(r), e.config.debugger(r)), e.config.stopLoadedFlag = !0, void(e.app && e.app.Complete("dispatcher.on('data')"))) : void(e.CacheRangeComplete(), e.requestTimeOutId = setTimeout(function() {
                            clearTimeout(e.requestTimeOutId), e.requestTimeOutId = 0, e.ToLoadCtr(_, !0)
                        }, o))
                    }
                }), e.bOnplayEvent && e.app && e.app.onplayEvent()
            }, n.prototype.GetBufferFromCache = function() {
                var e = this;
                if (e.range_end < e.curCacheStart || e.range_start < e.curCacheStart || e.range_start > e.appendCacheEnd || e.range_end > e.curCacheEnd) {
                    if (e.cacheCleanCount++, e.wasteDataLen += e.bytesAvailable, e.ClearCache(!1), e.curCacheEnd = e.range_start + e.CacheBufSize - 1, e.appendCacheEnd = e.range_start, 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                        var o = "[{0}][{1}]#IOController.GetBufferFromCache() return start[{2}] curCacheStart[{3}]  end[{4}] appendCacheEnd[{5}] appendToPlayerPos[{6}] self.appendCacheEnd[{7}] bytesAvailable[{8}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.range_start, e.curCacheStart, e.range_end, e.appendCacheEnd, e.appendToPlayerPos, e.appendCacheEnd, e.bytesAvailable);
                        e.config.mdebug && console.log(o), e.config.debugger(o)
                    }
                    return
                }
                if (0 < e.curCacheStart && e.range_start >= e.curCacheStart) {
                    (0 < e.config.iSaveWaitLog || e.config.mdebug) && (o = "[{0}][{1}]#IOController.GetBufferFromCache() start[{2}] end[{3}]  appendToPlayerPos[{4}] bytesAvailable[{5}] LoadRangeSize[{6}] curCacheStart[{7}] appendCacheEnd[{8}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.range_start, e.range_end, e.appendToPlayerPos, e.bytesAvailable, e.config.LoadRangeSize, e.curCacheStart, e.appendCacheEnd), e.config.mdebug && console.log(o), e.config.debugger(o));
                    var t = 0;
                    if (e.range_start > e.curCacheStart) {
                        t = e.range_start - e.curCacheStart, e.curAppendPosition += t, e.bytesAvailable -= t, e.curCacheStart += t, e.curCacheEnd += t, e.wasteDataLen += t;
                        var n = e.CacheBytes.subarray(e.curAppendPosition, e.curAppendPosition + e.bytesAvailable);
                        e.CacheBytes.set(n, 0), e.curAppendPosition = 0, e.curRecvPosition = e.bytesAvailable
                    }
                    if (e.range_end <= e.appendCacheEnd) {
                        t = e.range_end - e.range_start + 1;
                        var i = e.CacheBytes.subarray(e.curAppendPosition, e.curAppendPosition + t);
                        if (e.curAppendPosition += t, e.bytesAvailable -= t, e.curCacheStart += t, e.curCacheEnd += t, e.curCacheEnd >= e.config.filesize && 0 < e.config.filesize && (e.curCacheEnd = e.config.filesize - 1), e.app && e.app.DataArrival("IOController.GetBufferFromCache()", i, e.range_start), i = void 0, n = e.CacheBytes.subarray(e.curAppendPosition, e.curAppendPosition + e.bytesAvailable), e.CacheBytes.set(n, 0), e.curAppendPosition = 0, e.curRecvPosition = e.bytesAvailable, 0 < e.config.iSaveWaitLog || e.config.mdebug) {
                            var r = 0;
                            e.dispatcher && e.dispatcher.loadInfo && (r = e.dispatcher.loadInfo.cdnLoaded + e.dispatcher.loadInfo.scdnLoaded), o = "[{0}][{1}]#player.onComplete bufferlen[{2}] start[{3}] end[{4}] size[{5}] appendToPlayerPos[{6}] CacheBufSize[{7}] bytesAvailable[{8}] curCacheStart[{9}] appendCacheEnd[{10}] curCacheEnd[{11}] waitNum[{12}] abortCount[{13}] iSeekNum[{14}] uuid[{15}] cacheCleanCount[{16}] wasteDataLen[{17}] currentTime[{18}] downbytes[{19}] nodeCount[{20}] fShare[{21}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.config.bufferLen.toFixed(2), e.range_start, e.range_end, t, e.appendToPlayerPos, e.CacheBufSize, e.bytesAvailable, e.curCacheStart, e.appendCacheEnd, e.curCacheEnd, e.config.waitNum, e.config.abortCount, e.iSeekNum, e.config.stat.vid, e.cacheCleanCount, e.wasteDataLen, e.config.currentTime.toFixed(2), r, e.nodeCount, e.config.fShare), e.config.mdebug && console.log(o), e.config.debugger(o)
                        }
                        return e.range_end >= e.curCacheEnd && (e.config.stopLoadedFlag = !0), e.CheckSameRange(), e.range_end = 0, void(e.app && e.app.onComplete && e.app.onComplete())
                    }
                } else e.ClearCache(!1), e.cacheCleanCount++, e.curCacheEnd = e.range_start + e.CacheBufSize - 1, e.appendCacheEnd = e.range_start
            }, n.prototype.CheckSameRange = function() {
                var e = this;
                if (!(1 > e.range_end || 10 < e.config.bufferLen)) {
                    var o = {
                        from: e.range_start,
                        to: e.range_end
                    };
                    return e.lastRange.from == o.from && e.lastRange.to == o.to && 0 < e.range_end ? e.sameRangeCount++ : (e.sameRangeCount = 0, e.lastRange = o), 1 < e.sameRangeCount && 0 == e.sameRangeCount % 3 && 15 > e.sameRangeCount ? void e.ErrorQuitActively("IOController.CheckSameRange()", "repeatedly same Range") : void(e.range_end = 0)
                }
            }, n.prototype.load = function(e) {
                var t = this;
                if (!(t.destroyed || t.config.bWatch || t.config.stopLoadedFlag || !e)) {
                    if (t.bPlayEnd = !1, t.config.activeTimercount = 0, t.config.iLastLoadTime = new Date().getTime(), 0 == t.config.bitrate && 0 < t.config.filesize && 20 < t.config.duration && (t.config.bitrate = 8 * o(t.config.filesize / t.config.duration / 1024), t.config.bitrateLimit()), t.appendToPlayerPos = e.from, t.range_start = e.from, t.range_end = e.to, t.sameAppendCount = 0, t.withCredentials != t.oFetchNode.withCredentials && (t.oFetchNode.withCredentials = t.withCredentials), t.withCredentials != t.hdCdn.withCredentials && (t.hdCdn.withCredentials = t.withCredentials), t.app && t.app.updateBufferLen(!0), t.config.bSdkCache && 0 < t.range_end) {
                        if (t.InitCache(t.range_end - t.range_start), t.GetBufferFromCache(), (t.bFetchSupported && t.oFetchNode && !t.oFetchNode.isWorking() || !t.bFetchSupported && t.curLoader && t.curLoader.httpIdel()) && ("audio" == t.config.mediaType ? t.bytesAvailable > t.CacheBufSize / 2 && !t.config.bCtrRagneSize && (t.config.stopLoadedFlag = !0) : 45 < t.config.bufferLen && t.bytesAvailable > t.CacheBufSize / 2 && !t.config.bCtrRagneSize && (t.config.stopLoadedFlag = !0)), 0 < t.range_end && (0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                            var n = "[{0}][{1}]#IOController.load() start[{2}] end[{3}]  appendToPlayerPos[{4}] curRecvPosition[{5}] bytesAvailable[{6}] curCacheStart[{7}] curCacheEnd[{8}] appendCacheEnd[{9}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.range_start, t.range_end, t.appendToPlayerPos, t.curRecvPosition, t.bytesAvailable, t.curCacheStart, t.curCacheEnd, t.appendCacheEnd);
                            t.config.mdebug && console.log(n), t.config.debugger(n)
                        }
                        return void t.ToLoadCtr(L, !1)
                    }
                    t.ClearLoader("IOController.load()"), !0 == t.config.stopLoadedFlag || t.ToLoadCtr(L, !1)
                }
            }, n.prototype.abort = function() {
                var e = this;
                if (!(e.destroyed || e.config.bWatch)) {
                    var o = new Date().getTime();
                    if (1e3 < o - e.config.SdkFristTime && 1900 > o - e.config.iLastLoadTime && e.config.abortCount++, e.range_end = 0, e.app && (e.app.updateBufferLen(!0), (0 < e.config.iSaveWaitLog || e.config.mdebug) && e.dispatcher)) {
                        var t = "[{0}][{1}]IOController.abort() bufferLen[{2}] abortCount[{3}] appendToPlayerPos[{4}] loadinfo.cdn[{5}] loadinfo.scdn[{6}] bSdkAbort[{7}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.config.bufferLen.toFixed(2), e.config.abortCount, e.appendToPlayerPos, e.dispatcher.loadInfo.cdnLoaded, e.dispatcher.loadInfo.scdnLoaded, e.config.bSdkAbort);
                        e.config.mdebug && console.log(t), e.config.debugger(t)
                    }!e.config.bSdkAbort && 0 < e.CacheBufSize || (e.config.stopLoadedFlag = !0, e.clearFetchTimeout(), clearTimeout(e.requestTimeId), e.ClearLoader("IOController.abort()"), e.dispatcher && (0 < e.config.filesize && 0 < e.appendToPlayerPos && (e.dispatcher.progressed = (e.appendToPlayerPos / e.config.filesize).toFixed(2)), e.dispatcher.abort()))
                }
            }, n.prototype.ToLoadCtr = function(e, o) {
                var t = this;
                if (!(t.destroyed || !t.dispatcher || !0 == t.config.stopLoadedFlag || t.bPlayEnd || t.config.bWatch)) {
                    t.dispatcher && t.nodeCount != t.dispatcher.downloaders.length && (t.nodeCount = t.dispatcher.downloaders.length), !0 == o && t.app && t.app.updateBufferLen(!0);
                    var n = {
                        from: t.appendToPlayerPos,
                        to: -1
                    };
                    if (!(t.config.bSdkCache && 0 < t.CacheBufSize)) 0 < t.range_end && (n.to = t.range_end);
                    else if (n.from = t.appendCacheEnd, n.to = t.curCacheEnd, n.to < n.from) return;
                    if (!(t.oFetchNode && t.bFetchSupported)) {
                        if (t.oFetchNode && t.oFetchNode.isWorking() && (t.clearFetchTimeout(), t.oFetchNode.abort(), t.config.mdebug && console.log("[%s][%s]IOController.ToLoadCtr()  from fetch to xhr", y("hh:mm:ss:S", new Date), t.config.mediaType)), 2 != t.stat.download_type && (t.stat.download_type = 2), !t.curLoader) t.curLoader = t.dispatcher.GetLoader();
                        else if (t.curLoader.httpIdel()) t.curLoader.bUse = !1, t.curLoader = t.dispatcher.GetLoader();
                        else if (!t.curLoader.httpIdel() && t.config.bufferLen < t.config.bufLenCtr.a && t.curLoader.type == T) t.config.sCanceNum++, t.curLoader.bUse = !1, t.curLoader.abort(), t.curLoader.advanceTimeOut(), t.curLoader = t.dispatcher.GetLoader();
                        else if (!t.curLoader.httpIdel()) {
                            if (t.oldAppendCount == t.config.appendCount && 0 < t.config.appendCount ? t.sameAppendCount++ : (t.sameAppendCount = 0, t.oldAppendCount = t.config.appendCount), (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() bufferLen[{2}] appendCount[{3}][{4}] nodeType[{5}] nodeCount[{6}] fDownLoad[{7}] appendToPlayerPos[{8}] waitNum[{9}] ".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.config.appendCount, t.sameAppendCount, t.curLoader.nodetype, t.nodeCount, t.curLoader.fDownLoad, t.appendToPlayerPos, t.config.waitNum), t.config.mdebug && console.log(f), t.config.debugger(f)), 4 < t.sameAppendCount && 0 < t.config.appendCount) {
                                if (t.curLoader.timeoutDown++, t.curLoader.abort(), t.curLoader.type == T) t.curLoader.updateErrTime(), t.EmptyBuffer(t.curLoader, 15, 0);
                                else if (t.curLoader.type == C && t.config.bufferLen < t.config.bufferLen < t.config.ExitMinBufLen && t.curLoader.timeoutDown > t.config.CdnMaxTimeOutNum) return void t.ErrorQuitActively("IOController.ToLoadCtr()", "CDN time out too many");
                                return t.sameAppendCount = 0, void t.ToLoadCtr(L, !0)
                            }
                            return void t.EmptyBuffer(t.curLoader, 20, 2)
                        }
                        if (!t.curLoader)
                            if (t.hdCdn.httpIdel()) t.curLoader = t.hdCdn, (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() switch scdn fail nodeType[{2}] nodeCount[{3}] currentTime[{4}]s bufferLen[{5}] appendToPlayerPos[{8}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.curLoader.nodetype, t.nodeCount, t.config.currentTime.toFixed(2), t.config.bufferLen.toFixed(2), t.appendToPlayerPos), t.config.mdebug && console.log(f), t.config.debugger(f));
                            else return;
                        0 == t.curLoader.nodetype && 0 < t.curLoader.iUrlErrStatus && t.hdNode && (t.curLoader = t.hdNode);
                        var i = 0,
                            r = 0;
                        0 < n.to && (r = n.to - n.from + 1, 0 < t.config.LoadRangeSize && "video" == t.config.mediaType && r > t.config.LoadRangeSize && (r = t.config.LoadRangeSize), t.curLoader && 0 < t.curLoader.speed && 0 == t.curLoader.nTimeOutCount && 0 == t.curLoader.timeoutDown && 6 > r / (1e3 * t.curLoader.speed) && r < t.config.xhrMaxBufSize && (i = r), e == L && 0 == i && (i = t.config.xhrFirstSize, r < t.config.xhrPartitionSize && (i = r))), (0 == i || "video" != t.config.mediaType) && (i = t.dispatcher.GetLoadBufSize(t.curLoader.type, t.config.bufferLen));
                        var a = parseInt(t.config.bufferLen - t.config.bufLenCtr.a);
                        if ("video" == t.config.mediaType && t.curLoader.type == T && 7 < a && 0 < t.curLoader.speed) {
                            var d = 1024 * parseInt(t.curLoader.speed * (a - 1));
                            409600 < d && i > d && (i = d)
                        }
                        t.curLoader.type == T && i > t.config.scdnSizeCtr.b && (0 < t.curLoader.speed && 160 > t.curLoader.speed || 0 < t.curLoader.timeoutDown) && (i = t.config.scdnSizeCtr.b), i > t.config.xhrMaxBufSize && (i = t.config.xhrMaxBufSize), i > r && 0 < r && 0 < n.to && (i = r), t.config.bCtrRagneSize && 0 < t.config.LoadRangeSize && i > t.config.LoadRangeSize && (i = t.config.LoadRangeSize);
                        var c = t.dispatcher.GetTimeOut(i);
                        l = t.curLoader.updatePreUseTime(i), l > c && 23000 > l && (c = l + 1e3);
                        var s = n.from,
                            g = n.from + i - 1;
                        if (g > n.to && 0 < n.to && (g = n.to), g > t.config.filesize && 0 < t.config.filesize && (g = t.config.filesize - 1), t.curLoader.bUse = !0, 0 == t.config.filesize && 2 < t.curLoader.sameRangeCount && 0 > n.to) return t.cdnErrReportCount++, void(t.app && t.app.Error("IOController.ToLoadCtr()", -1, "cdn error"));
                        (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() nodeType[{2}] nTimeOut[{3}] preUseTime[{4}] nodeCount[{5}] bufferLen[{6}] range_end[{7}] from[{8}] end[{9}] DangerAwayTime[{10}] fileSize[{11}] LoadRangeSize[{12}]KB loadBufSize[{13}]KB bitrate[{14}]kb waitNum[{15}] addWaitNum[{16}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.curLoader.nodetype, c, l, t.nodeCount, t.config.bufferLen.toFixed(2), t.range_end, t.appendToPlayerPos, g, a, t.config.filesize, parseInt(t.config.LoadRangeSize / 1024), parseInt(i / 1024), t.config.bitrate, t.config.waitNum, t.config.addWaitNum), t.config.mdebug && console.log(f), t.config.debugger(f)), (g > s || g == s) && (0 < t.requestTimeOutId && (clearTimeout(t.requestTimeOutId), t.requestTimeOutId = 0), t.dispatcher && (t.dispatcher.updateSendLen(), t.dispatcher.loadInfo.curUrl = t.curLoader.uri), t.sameAppendCount = 0, t.curLoader.open(s, g, c), t.EmptyBuffer(t.curLoader, 15, 1))
                    } else if (t.curLoader && !t.curLoader.httpIdel() && (t.curLoader.bUse = !1, t.curLoader.abort(), t.config.mdebug && console.log("[%s][%s]IOController.ToLoadCtr()  from xhr to fetch", y("hh:mm:ss:S", new Date), t.config.mediaType)), 1 != t.stat.download_type && (t.stat.download_type = 1), !t.oFetchNode.isWorking()) {
                        t.oFetchNode.cdnType = C, t.oFetchNode.loader = t.hdCdn;
                        var u = t.dispatcher.getNodeFromType(T);
                        2 > t.dispatcher.downloaders.length || t.config.bufferLen < t.config.bufLenCtr.b - 1 || !u ? (0 < t.hdCdn.iUrlErrStatus && t.hdNode && (t.oFetchNode.cdnType = C, t.oFetchNode.loader = t.hdNode), t.ToFetch(t.oFetchNode.loader.uri, e, n)) : (t.oFetchNode.cdnType = T, t.oFetchNode.loader = t.dispatcher.getNodeFromType(t.oFetchNode.cdnType), t.oFetchNode.loader && t.ToFetch(t.oFetchNode.loader.uri, e, n))
                    } else if (t.oFetchNode.cdnType == C && 1 < t.dispatcher.downloaders.length && t.config.bufferLen > t.config.bufLenCtr.b && 36 < t.config.appendCount) {
                        if (u = t.dispatcher.getNodeFromType(T), !u) {
                            if (2 > t.scdnSwitchCount && (0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                                var f = "[{0}][{1}]IOController.ToLoadCtr() Switch scdn fail bufferLen[{2}] appendCount[{3}] cdnType[{4}] ".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.config.appendCount, t.oFetchNode.cdnType);
                                t.config.mdebug && console.log(f), t.config.debugger(f)
                            }
                            return
                        }
                        t.clearFetchTimeout(), t.oFetchNode.isWorking() && (t.clearFetchTimeout(), t.oFetchNode.abort()), (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() Switch scdn >>oFetchNode.abort()  bufferLen[{2}] url[{3}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.oFetchNode.loader.uri), t.config.mdebug && console.log(f), t.config.debugger(f))
                    } else if (t.oFetchNode.cdnType == T && t.config.bufferLen < t.config.bufLenCtr.a) {
                        if (!t.oFetchNode.loader) return t.config.mdebug && console.log("[%s][%s]IOController.ToLoadCtr()   Switch cdn loader is undefine", y("hh:mm:ss:S", new Date), t.config.mediaType), void(t.oFetchNode.isWorking() && t.switchFetch());
                        if (t.clearFetchTimeout(), t.config.sCanceNum++, t.oFetchNode.loader.updateErrTime(), (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() Switch cdn >>oFetchNode.abort() sCanceNum[{2}] bufferLen[{3}] url[{4}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.sCanceNum, t.config.bufferLen.toFixed(2), t.oFetchNode.loader.uri), t.config.mdebug && console.log(f), t.config.debugger(f)), 0 == t.sameAppendCount || !0 == t.config.bCurSignalAbort) return void t.oFetchNode.abort();
                        t.switchFetch(), t.oFetchNode.cdnType = C, t.oFetchNode.loader = t.hdCdn, 0 < t.hdCdn.iUrlErrStatus && t.hdNode && (t.oFetchNode.cdnType = C, t.oFetchNode.loader = t.hdNode), t.ToFetch(t.oFetchNode.loader.uri, !1, n)
                    } else {
                        if (!t.oFetchNode.loader) return;
                        var p = 0;
                        0 < t.oFetchNode.loader.startTime && (p = new Date().getTime() - t.oFetchNode.loader.startTime);
                        var l = t.oFetchNode.loader.preUseTime;
                        if (t.oldAppendCount == t.config.appendCount && 0 < t.config.appendCount ? t.sameAppendCount++ : (t.sameAppendCount = 0, t.oldAppendCount = t.config.appendCount), 3 < t.sameAppendCount && 0 < t.config.appendCount || 2 > t.config.waitNum && 0 < l && p > l + 1e4 || 22000 < p && 0 < t.oFetchNode._size && 1572864 > t.oFetchNode._size) {
                            if (4 < t.sameAppendCount) return t.EmptyBuffer(t.oFetchNode.loader, 15, 0), t.sameAppendCount = 0, t.switchFetch(), void t.ToLoadCtr(L, !0);
                            (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() Cancel fetch bufferLen[{2}] appendCount[{3}][{4}] cdnType[{5}] nodeCount[{6}] _receivedLength[{7}] appendToPlayerPos[{8}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.config.appendCount, t.sameAppendCount, t.oFetchNode.cdnType, t.nodeCount, t.oFetchNode._receivedLength, t.appendToPlayerPos), t.config.mdebug && console.log(f), t.config.debugger(f)), t.clearFetchTimeout(), t.oFetchNode.abort();
                            var m = t.oFetchNode._contentLength + "/" + t.oFetchNode.strRange;
                            if (t.oFetchNode.loader && (t.oFetchNode.loader.timeoutDown++, t.oFetchNode.loader.weight -= 0.3, t.EmptyBuffer(t.oFetchNode.loader, 15, 0), t.oFetchNode.loader.AddErrMsgArry({
                                    err_code: 9,
                                    err_msg: "fetch download TimeOut",
                                    err_pos: 25,
                                    node_type: t.oFetchNode.loader.nodetype,
                                    sCanceNum: t.config.sCanceNum,
                                    send_length: t.config.send_length,
                                    waitNum: t.config.waitNum,
                                    bufferLen: t.config.bufferLen.toFixed(2),
                                    pull_type: "fetch",
                                    range: m,
                                    rangeSize: t.oFetchNode._size,
                                    timeout: t.oFetchNode.nTimeOut,
                                    useTime: t.oFetchNode.loader.Onedowntimes,
                                    usetimes: t.oFetchNode.loader.usetimes,
                                    url: t.oFetchNode.loader.uri
                                })), t.clearFetchTimeout(), t.oFetchNode.loader && t.oFetchNode.loader.type == T && (0.11 > t.oFetchNode.loader.weight || t.oFetchNode.loader.timeoutCnt > t.config.ScdnMaxTimeOutNum || t.oFetchNode.loader.timeoutDown > t.config.ScdnMaxTimeOutNum)) {
                                t.sameAppendCount = 0, t.dispatcher && 3 < t.config.bufferLen && t.dispatcher.ErrLogReport();
                                var h = t.oFetchNode.loader.uri;
                                if (t.dispatcher) {
                                    var b = t.oFetchNode.loader.downbytes - t.oFetchNode.loader.reportdownbytes;
                                    0 < b && t.dispatcher.FlowReport(0), t.dispatcher.removeObj(t.oFetchNode.loader, t.dispatcher.downloaders), t.oFetchNode.loader = void 0, t.nodeCount = t.dispatcher.downloaders.length
                                }
                                return void((0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]##IOController.NodeTimeOut() new loader.length[{2}]  remove scdnNode url[{3}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.nodeCount, h), t.config.mdebug && console.log(f), t.config.debugger(f)))
                            }
                            return t.oFetchNode.cdnType == C && t.oFetchNode.loader.timeoutDown > t.config.CdnMaxTimeOutNum && t.config.bufferLen < t.config.bufferLen < t.config.ExitMinBufLen ? (t.sameAppendCount = 0, void t.ErrorQuitActively("IOController.ToLoadCtr()", "CDN time out too many")) : void(1 < t.sameAppendCount && !1 == t.config.bCurSignalAbort && (t.sameAppendCount = 0, t.switchFetch(), t.ToLoadCtr(L, !0)))
                        }
                        t.EmptyBuffer(t.oFetchNode.loader, 20, 2), (0 < t.config.iSaveWaitLog || t.config.mdebug) && (f = "[{0}][{1}]IOController.ToLoadCtr() bufferLen[{2}] appendCount[{3}][{4}] cdnType[{5}] nodeCount[{6}] _receivedLength[{7}] appendToPlayerPos[{8}] waitNum[{9}] appendCacheEnd[{10}] bytesAvailable[{11}][{12}]".format(y("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.config.appendCount, t.sameAppendCount, t.oFetchNode.cdnType, t.nodeCount, t.oFetchNode._receivedLength, t.appendToPlayerPos, t.config.waitNum, t.appendCacheEnd, t.CacheBufSize, t.bytesAvailable), t.config.mdebug && console.log(f), t.config.debugger(f))
                    }
                }
            }, n.prototype.destroy = function() {
                var e = this;
                if (!e.destroyed) {
                    if ((0 < e.config.iSaveWaitLog || e.config.mdebug) && e.dispatcher) {
                        var o = e.dispatcher.loadInfo;
                        0 < o.cdnLoaded && 0 < o.scdnLoaded && (e.config.fShare = (o.scdnLoaded / (o.cdnLoaded + o.scdnLoaded)).toFixed(2));
                        var t = "[{0}][{1}]IOController.destroy() setupTime[{2}] fileName[{3}] loadinfo.cdn[{4}] loadinfo.scdn[{5}] fShare[{6}]".format(y("hh:mm:ss:S", new Date), e.config.mediaType, e.config.setupTime, e.stat.streamname, o.cdnLoaded, o.scdnLoaded, e.config.fShare);
                        e.config.mdebug && console.log(t), e.config.debugger(t)
                    }
                    0 < e.CacheBufSize && e.ClearCache(!0), e.config.stopLoadedFlag = !0, e.destroyed = !0, e.hdCdn = void 0, e.hdNode = void 0, e.Heartbeat = void 0, 0 < e.ReportTimeOutId && clearTimeout(e.ReportTimeOutId), e.timeInterval && clearInterval(e.timeInterval), e.clearFetchTimeout(), e.requestTimeId && clearTimeout(e.requestTimeId), e.oFetchNode && (e.oFetchNode.FetchClean(), e.oFetchNode = void 0), e.timeInterval = void 0, e.dispatcher && (e.dispatcher.destroy(), e.app = null, e.dispatcher = null, e.cloudCfg && e.cloudCfg.abort(), e.cloudCfg = void 0)
                }
            }, n.prototype.queryNodeFromAudioLocal = function() {
                var e = this;
                if (e.config && e.config.videourl) {
                    var o = e.config.videourl.split("?")[0];
                    if (window.localStorage && window.localStorage.AudioGetNodesTime && window.localStorage.AudioUrl && o == window.localStorage.AudioUrl && (e.config.NodesTime = window.localStorage.AudioGetNodesTime), window.sessionStorage && window.localStorage && window.sessionStorage.AudioScdnNodes && window.localStorage.AudioUrl && window.sessionStorage.AudioNodesTime && window.localStorage.AudioGetNodesTime) {
                        var t = (new Date().getTime() - window.sessionStorage.AudioNodesTime) / 1e3,
                            n = (new Date().getTime() - window.localStorage.AudioGetNodesTime) / 1e3,
                            i = "";
                        if (20 < window.sessionStorage.AudioScdnNodes.length && (i = JSON.parse(window.sessionStorage.AudioScdnNodes)), e.config.mdebug && console.log("[%s][%s]IOController.queryNodeFromAudioLocal  TimeInterval[%d] scdnSesTimeOut[%s] noScdnSesTimeOut[%s] tmpScdnNodes.length[%d] localStorage.AudioUrl[%s] uri[%s] sessionStorage.scdnNodes[%s]", y("hh:mm:ss:S", new Date), e.config.mediaType, t, e.config.scdnSesTimeOut, e.config.noScdnSesTimeOut, i.length, window.localStorage.AudioUrl, o, window.sessionStorage.AudioScdnNodes), t < e.config.scdnSesTimeOut && window.localStorage.AudioUrl == o && i && 0 < i.length && (e.parseNodes(i), e.dispatcher && 1 < e.dispatcher.downloaders.length)) return 0 == e.config.stat.first_dispatch_msecs && (e.config.stat.first_dispatch_nodes = e.dispatcher.downloaders.length - 1), void(e.bNotNeedQueryNode = !1);
                        if (n < e.config.noScdnSesTimeOut && window.localStorage.AudioUrl == o) return e.bNotNeedQueryNode = !1, void(e.config.NodesTime = window.localStorage.AudioGetNodesTime)
                    }
                }
            }, n.prototype.queryNodeFromVideoLocal = function() {
                var e = this;
                if (e.config && e.config.videourl) {
                    var o = e.config.videourl.split("?")[0];
                    if (window.localStorage && window.localStorage.VideoGetNodesTime && window.localStorage.VideoUrl && o == window.localStorage.VideoUrl && (e.config.NodesTime = window.localStorage.VideoGetNodesTime), window.sessionStorage && window.localStorage && window.sessionStorage.VideoScdnNodes && window.localStorage.VideoUrl && window.sessionStorage.VideoNodesTime && window.localStorage.VideoGetNodesTime) {
                        var t = (new Date().getTime() - window.sessionStorage.VideoNodesTime) / 1e3,
                            n = (new Date().getTime() - window.localStorage.VideoGetNodesTime) / 1e3,
                            i = "";
                        if (20 < window.sessionStorage.VideoScdnNodes.length && (i = JSON.parse(window.sessionStorage.VideoScdnNodes)), e.config.mdebug && console.log("[%s][%s]IOController.queryNodeFromVideoLocal TimeInterval[%d] scdnSesTimeOut[%s] noScdnSesTimeOut[%s] tmpScdnNodes.length[%d] localStorage.VideoUrl[%s] uri[%s] sessionStorage.VideoScdnNodes[%s]", y("hh:mm:ss:S", new Date), e.config.mediaType, t, e.config.scdnSesTimeOut, e.config.noScdnSesTimeOut, i.length, window.localStorage.VideoUrl, o, window.sessionStorage.VideoScdnNodes), t < e.config.scdnSesTimeOut && window.localStorage.VideoUrl == o && i && 0 < i.length && (e.parseNodes(i), e.dispatcher && 1 < e.dispatcher.downloaders.length)) return 0 == e.config.stat.first_dispatch_msecs && (e.config.stat.first_dispatch_nodes = e.dispatcher.downloaders.length), void(e.bNotNeedQueryNode = !1);
                        if (n < e.config.noScdnSesTimeOut && window.localStorage.VideoUrl == o) return e.bNotNeedQueryNode = !1, e.config.NodesTime = window.localStorage.VideoGetNodesTime, void(e.config.mdebug && console.log("[%s][%s]IOController.queryNodeFromVideoLocal bNotNeedQueryNode[%s] videourl[%s]", y("hh:mm:ss:S", new Date), e.config.mediaType, e.bNotNeedQueryNode, o))
                    }
                }
            }, n.prototype.WriteNodeToSessionInfo = function(e, o) {
                var t = this;
                if (window.sessionStorage) {
                    var n = t.config.videourl.split("?")[0];
                    t.config.mdebug && console.log("[%s][%s]IOController.WriteNodeToSessionInfo  nodes[%s] videourl[%s]", y("hh:mm:ss:S", new Date), e, JSON.stringify(o), n);
                    var i = new Date().getTime();
                    "video" == e ? (window.sessionStorage.setItem("VideoScdnNodes", JSON.stringify(o)), window.sessionStorage.setItem("VideoNodesTime", i)) : (window.sessionStorage.setItem("AudioScdnNodes", JSON.stringify(o)), window.sessionStorage.setItem("AudioNodesTime", i))
                }
            }, n.prototype.UpdateTimeToSessionInfo = function(e) {
                window.sessionStorage && ("video" == e ? window.sessionStorage.setItem("VideoNodesTime", new Date().getTime()) : window.sessionStorage.setItem("AudioNodesTime", new Date().getTime()))
            }, n.prototype.UpdateGetNodeTimeToSessionInfo = function(e) {
                var o = this;
                if (window.localStorage) {
                    var t = o.config.videourl.split("?")[0],
                        n = new Date().getTime();
                    "video" == e ? (window.localStorage.setItem("VideoUrl", t), window.localStorage.setItem("VideoGetNodesTime", n)) : (window.localStorage.setItem("AudioUrl", t), window.localStorage.setItem("AudioGetNodesTime", n))
                }
            }
        }, {
            "../loader/cloud-cfg": 11,
            "../loader/fetchLoader": 12,
            "../loader/toGetNodes": 13,
            "../loader/xhrLoader": 14,
            "../stat/Heartbeat": 15,
            "../stat/log-report": 16,
            "../stat/statx": 17,
            "../util/dateFtt": 19,
            "./config": 9,
            "./dispatcher-xhr": 10,
            events: 3,
            inherits: 6
        }],
        9: [function(e, o) {
            function t() {
                var e = this;
                e.limitrtc = 200, e.max_block_num = 128, e.STAT_POST_URL = "https://sdk-log-scdn.yfdts.net/s.gif", e.GET_EDGE_NODES_ADDR = "https://api.yfscdn.net/v1/node/get_nodes", e.GET_EDGE_NODES_URI = "/v1/node/get_nodes", e.accessKey = "bilibili11hjgHGJH3ghy78gG", e.secretKey = "bilibili33JKH324Bhjbjhdsu32hU", e.RangeErrCount = 0, e.xhrioPreEnd = !1, e.ErrCount = 0, e.AllErrCount = 0, e.close_ts = 0, e.domain = "vod.h5.bilibili.com", e.queryNodeDomain = "upos-dash-mirrorks3u.bilivideo.com", e.sdkversion = "1.5.4", e.cfgversion = ".20", e.conf_v = e.sdkversion, e.sdk_channel = "billiblili", e.scdnNodeParam = "yfpm=1", e.bWatch = !1, e.videourl = "", e.keyurl = "", e.bufferLen = 0, e.filesize = 0, e.duration = 0, e.bitrate = 0, e.stat = null, e.autoplay = !0, e.autoload = !0, e.stopLoadedFlag = !1, e.setupTime = 0, e.mdebug = !1, e.hasLoadeddata = !1, e.hasSteupded = !1, e.global_cache_time = 0, e.xhrCdnSize = 1048576, e.cdnTimeout = 9e3, e.MinCacheTime = 2, e.MidCacheTime = 5, e.GoodCacheTime = 10, e.UploadLog = !1, e.UploadLogInterval = 60, e.UploadQualityInterval = 120, e.UploadFlowData = !1, e.UploadFlowInterval = 60, e.UploadErrLog = !1, e.scdnSizeCtr = {
                    b: 1048576,
                    c: 2097152
                }, e.scdnTimeOutCtr = {
                    b: 1e4,
                    c: 2e4,
                    d: 26000,
                    e: 22000,
                    f: 18000
                }, e.bufLenCtr = {
                    a: 10,
                    b: 20,
                    c: 30
                }, e.scdnSesTimeOut = 300, e.noScdnSesTimeOut = 59, e.vid = "", e.server_ts = 0, e.timercount = 0, e.fetchScdnSize = 5242880, e.fetchCdnSize = 5242880, e.mediaType = "video", e.QueryNodeInterval = 60, e.MaxGetNodesNum = 5, e.NodesTime = 0, e.AudioFetchBufSize = 1048576, e.ReportMinSize = 15728640, e.fetchCdnFirstTimeOut = 1900, e.fetchScdnFirstTimeOut = 1900, e.logReport = void 0, e.iSaveWaitLog = 0, e.MaxWaitLogNum = 600, e.iSaveLogCount = 0, e.iAllSaveLogCount = 0, e.iLastSaveLogTime = 0, e.waitNum = 0, e.addWaitNum = 0, e.LastWaitVideoTime = 0, e.sCanceNum = 0, e.bInitConfig = !1, e.send_length = 0, e.iWaitReportCount = 0, e.UploadWaitLogInterval = 30, e.UploadWaitLog = !1, e.bHeartbeat = !1, e.fetchFirstSize = 819200, e.xhrFirstSize = 921600, e.SdkFristTime = 0, e.xhrPartitionSize = 1048576, e.xhrMaxBufSize = 2621440, e.playSessid = "", e.playDevId = "", e.bUseScdn = !0, e.abortCount = 0, e.iLastLoadTime = 0, e.bFetchSupported = !0, e.fShare = 0, e.currentTime = 0, e.iErr403 = 0, e.iFailToFetch = 0, e.iErrEarlyEOF = 1, e.LoadRangeSize = 0, e.appendCount = 0, e.preMaxUseTime = 15000, e.bTimeOutReport = !0, e.bTimeOutAddTime = !1, e.activeTimercount = 0, e.bSdkCache = !1, e.CacheBufSize = 3145728, e.CacheTimeSize = 9, e.bCurFetchSupported = !0, e.delayLevel = 0, e.allowMaxWaitNum = 5, e.CdnMaxTimeOutNum = 7, e.ScdnMaxTimeOutNum = 7, e.FetchNotSupportMark = ["dingtalk"], e.LowBroswerVer = [{
                    broswer: "edge",
                    version: 18
                }, {
                    broswer: "chrome",
                    version: 66
                }], e.bSdkAbort = !0, e.bFetchSignalAbort = !1, e.bCurSignalAbort = !1, e.bCtrRagneSize = !1, e.ExitMinBufLen = 9, e.iFastReply = 0, e.ToReplaceDomain = []
            }
            o.exports = t, t.prototype.debugger = function() {
                var e = this;
                e.logReport && 0 < e.iSaveWaitLog && e.logReport.debugger(arguments)
            }, t.prototype.cleanLogReport = function() {
                var e = this;
                e.logReport && e.logReport.clean()
            }, t.prototype.UploadWaitData = function() {
                var e = this;
                if (e.UploadWaitLog) {
                    if (0 == e.iWaitReportCount) {
                        var o = [];
                        o.push({
                            upload_type: 0,
                            mincache_times: e.stat.mincache_times,
                            midcache_times: e.stat.midcache_times,
                            goodcache_times: e.stat.goodcache_times,
                            bufferLen: parseInt(e.bufferLen),
                            waitNum: e.waitNum,
                            errorNum: e.AllErrCount,
                            abortCount: e.abortCount,
                            addWaitNum: e.addWaitNum,
                            TimeOutNum: 0,
                            cntTimeOutNum: 0
                        }), 0 < o.length && (e.iWaitReportCount++, e.stat.send(e.stat.SCDN_DASHSDK_WAIT, o))
                    }
                    0 < e.stat.WaitMsgArry.length && (0 < e.stat.WaitMsgArry.length && (e.iWaitReportCount++, e.stat.send(e.stat.SCDN_DASHSDK_WAIT, e.stat.WaitMsgArry), e.addWaitNum = 0), e.stat.WaitMsgArry = [])
                }
            }, t.prototype.bitrateLimit = function() {
                var e = this;
                0 == e.bitrate || ("video" == e.mediaType && (8e3 < e.bitrate && (e.bitrate = 8e3), 1e3 > e.bitrate && (e.bitrate = 1e3)), "audio" == e.mediaType && (1e3 < e.bitrate && (e.bitrate = 1e3), 64 > e.bitrate && (e.cbitrate = 64)))
            }
        }, {}],
        10: [function(e, o) {
            function t(e, o) {
                i.call(this);
                var t = this;
                t.destroyed = !1, t.noMoreNodes = !1, t.startTime = new Date().getTime(), t.downloaders = [], t.config = o, t.timercount = 0, t.loadInfo = {
                    reportdownbytes: 0,
                    cdnLoaded: 0,
                    scdnLoaded: 0,
                    curUrl: ""
                }, t.progressed = 0, t.urierrors = [], t.requestTimeId = 0, t.destoryTimeId = 0, t.FlowReportCount = 0, t.AllFlowReportCount = 0, t.abortReportTimeOutId = 0, t.app = void 0, t.hdNode = void 0, t.downloaders = e.map(function(e) {
                    return t._setupHttp(e), e
                })
            }
            o.exports = t;
            var n = e("../util/dateFtt"),
                i = e("events").EventEmitter,
                r = e("inherits");
            r(t, i);
            var a = 0,
                d = 1;
            t.prototype.getNodeFromType = function(e) {
                for (var o = this, t = void 0, n = 0; n < o.downloaders.length; ++n)
                    if ((t = o.downloaders[n], !(0 < t.errTime && 1 < o.downloaders.length && t.type == d && parseInt(new Date().getTime()) < t.errTime)) && t.type == e) return t
            }, t.prototype.GetLoader = function() {
                var e = this,
                    o = void 0;
                if (!(!0 == e.config.stopLoadedFlag || e.destroyed)) {
                    if (1 == e.downloaders.length) return e.downloaders[0];
                    for (var t = 0; t < e.downloaders.length; t++)
                        if ((o = e.downloaders[t], !!o.httpIdel()) && !(0 < o.errTime && 1 < e.downloaders.length && o.type == d && parseInt(new Date().getTime()) < o.errTime) && !e._limitDownload(o.type, e.config.bufferLen)) return o
                }
            }, t.prototype.GetTimeOut = function(e) {
                var o = this,
                    t = o.config.cdnTimeout;
                return t = e == o.config.scdnSizeCtr.b ? o.config.scdnTimeOutCtr.b : e == o.config.scdnSizeCtr.c ? o.config.scdnTimeOutCtr.c : 2067152 < e ? o.config.scdnTimeOutCtr.d : 1472864 < e ? o.config.scdnTimeOutCtr.e : 1028576 < e ? o.config.scdnTimeOutCtr.f : o.config.cdnTimeout, t
            }, t.prototype.sortNodes = function() {
                var e = this;
                e.downloaders.sort(function(e, o) {
                    return e.weight - o.weight
                })
            }, t.prototype.GetLoadBufSize = function(e, o) {
                var t = this,
                    n = 1048576;
                return "audio" == t.config.mediaType ? o < t.config.bufLenCtr.b ? n = 307200 : n = 614400 : (e == a || e == d) && (o < t.config.bufLenCtr.b ? e == a && (4 > o ? n = 716800 : 8 > o ? n = 921600 : 512000 < t.config.xhrCdnSize ? n = t.config.xhrCdnSize : n = 1048576) : o < t.config.bufLenCtr.c ? e == d ? n = t.config.scdnSizeCtr.b : e == a && (1048576 > t.config.xhrCdnSize ? n = 1048576 : n = t.config.xhrCdnSize) : e == d ? n = t.config.scdnSizeCtr.c : e == a && (n = t.config.xhrCdnSize, 128 > t.config.xhrCdnSize && (n = 1048576))), n
            }, t.prototype._limitDownload = function(e, o) {
                var t = this,
                    i = 0,
                    r = !1;
                if (t.config.stopLoadedFlag ? (i = 1, r = !0) : o < t.config.bufLenCtr.b ? e == d && 1 < t.downloaders.length && (i = 2, r = !0) : o < t.config.limitrtc ? e == a && 1 < t.downloaders.length && (i = 3, r = !0) : (i = 4, r = !0), (0 < t.config.iSaveWaitLog || t.config.mdebug) && 0 < i) {
                    var c = "[{0}][{1}]Dispatcher._limitDownload() limit is true cdnType[{2}] ilimitFlag[{3}] bufferLen[{4}] limitrtc[{5}] stopLoadedFlag[{6}]".format(n("hh:mm:ss:S", new Date), t.config.mediaType, e, i, parseInt(t.config.bufferLen), t.config.limitrtc, t.config.stopLoadedFlag);
                    t.config.mdebug && console.log(c), t.config.debugger(c)
                }
                return r
            }, t.prototype._setupHttp = function(e) {
                var o = this;
                return e.on("error", function(t, i) {
                    if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                        var r = "[{0}][{1}]##Dispatcher._setupHttp>> hd.on('error' cdnType[{2}] TimeOut[{3}] bufferLen[{4}] range[{5}] waitNum[{6}] sCanceNum[{7}] size[{8}] error[{9}] errMsg[{10}] weight[{11}] useTime[{12}] hd.uri[{13}]".format(n("hh:mm:ss:S", new Date), o.config.mediaType, e.nodetype, e.timeout, parseInt(o.config.bufferLen), e.range, o.config.waitNum, o.config.sCanceNum, e.rangeSize, t, i, e.weight, e.Onedowntimes, e.uri);
                        o.config.mdebug && console.log(r), o.config.debugger(r)
                    }
                    e.nCompleteCount = 0, o.urierrors[e.uri] ? o.urierrors[e.uri] += 1 : o.urierrors[e.uri] = 1, e.abort(), o.sortNodes(), o.emit("hdError", e, t, i), e.type == d && 399 < t && (e.weight = 0), o.removeDownLoader(e, t, i)
                }), e.on("timeout", function() {
                    if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                        var t = "[{0}][{1}]##Dispatcher._setupHttp>> hd.on('timeout'>>cdnType[{2}] TimeOut[{3}] bufferLen[{4}] range[{5}] waitNum[{6}] sCanceNum[{7}] size[{8}]  useTime[{9}]ms fDownLoad[{10}] weight[{11}] uri[{12}] ".format(n("hh:mm:ss:S", new Date), o.config.mediaType, e.nodetype, e.timeout, parseInt(o.config.bufferLen), e.range, o.config.waitNum, o.config.sCanceNum, e.rangeSize, e.Onedowntimes, e.fDownLoad, e.weight, e.uri);
                        o.config.mdebug && console.log(t), o.config.debugger(t)
                    }
                    e.nCompleteCount = 0, e && e.loadedLen < e.rangeSize && (o.downbytes += e.loadedLen, 0 < e.nodetype ? o.loadInfo.scdnLoaded += e.loadedLen : o.loadInfo.cdnLoaded += e.loadedLen), o.urierrors[e.uri] ? o.urierrors[e.uri] += 1 : o.urierrors[e.uri] = 1, e.abort(), o.sortNodes(), o.emit("timeout", e), o._timeoutLoader(e)
                }), e.on("onprogress", function(t, n) {
                    o.emit("onprogress", e, t, n)
                }), e.on("data", function(t, i, r) {
                    if (!o.destroyed) {
                        o.urierrors[e.uri] = 0, e.nCompleteCount++, 3 < e.nCompleteCount && e.weight && (e.weight = 1), 10 < e.nCompleteCount && (e.timeoutCnt = 0, e.timeoutDown = 0);
                        var a = r - i + 1;
                        if (t.length < a && (a = t.length), 0 < e.nodetype ? o.loadInfo.scdnLoaded += a : o.loadInfo.cdnLoaded += a, 0 < o.loadInfo.cdnLoaded && 0 < o.loadInfo.scdnLoaded && (o.config.fShare = (o.loadInfo.scdnLoaded / (o.loadInfo.scdnLoaded + o.loadInfo.cdnLoaded)).toFixed(2)), 0 < o.config.iSaveWaitLog || o.config.mdebug) {
                            var c = "[{0}][{1}]##Dispatcher._setupHttp>> hd.on('data' cdnType[{2}] bufferLen[{3}] size[{4}] start[{5}] end[{6}] useTime[{7}]ms fShare[{8}]".format(n("hh:mm:ss:S", new Date), o.config.mediaType, e.nodetype, parseInt(o.config.bufferLen), t.length, i, r, e.Onedowntimes, o.config.fShare);
                            o.config.mdebug && console.log(c), o.config.debugger(c)
                        }
                        if (o.emit("data", t, i, r), 10 < o.config.bufferLen && o.config.UploadFlowData) {
                            var s = e.downbytes - e.reportdownbytes;
                            s > o.config.ReportMinSize && o.UploadFlowReport(0)
                        }
                        e.nodetype == d && e.responseURL && 0 < e.responseURL.length && ((0 < o.config.iSaveWaitLog || o.config.mdebug) && (c = "[{0}][{1}]Dispatcher._setupHttp scdn return 302 remove node".format(n("hh:mm:ss:S", new Date), o.config.mediaType), o.config.mdebug && console.log(c), o.config.debugger(c)), o.removeObj(e, o.downloaders))
                    }
                }), e
            }, t.prototype.FlowReport = function(e) {
                var o = this;
                if (o.config.UploadFlowData) {
                    var t = [],
                        n = e;
                    if ((0.82 < o.progressed || 0 == o.AllFlowReportCount % 10) && (n = 0), o.hdNode) {
                        var i = o.hdNode,
                            r = i.downbytes - i.reportdownbytes,
                            a = 0;
                        0 < i.downtimes && (a = i.downtimes - i.reportdowntimes), r > n && (t.push({
                            nodeip: i.uri,
                            nodeport: 80,
                            nodetype: i.nodetype,
                            downbytes: r,
                            all_downbytes: i.downbytes,
                            downtimes: a,
                            usetimes: i.usetimes,
                            downfails: i.downfails,
                            timeout: i.timeoutCnt,
                            code: i.code,
                            err_code: i.err_code,
                            sdkTimeout: i.sdkTimeout,
                            dataType: i.dataType
                        }), i.reportdownbytes = i.downbytes, i.reportdowntimes = i.downtimes)
                    }
                    for (var d = 0; d < o.downloaders.length; d++) i = this.downloaders[d], r = i.downbytes - i.reportdownbytes, a = 0, 0 < i.downtimes && (a = i.downtimes - i.reportdowntimes), r > n && (t.push({
                        nodeip: i.uri,
                        nodeport: 80,
                        nodetype: i.nodetype,
                        downbytes: r,
                        all_downbytes: i.downbytes,
                        downtimes: a,
                        usetimes: i.usetimes,
                        downfails: i.downfails,
                        timeout: i.timeoutCnt,
                        code: i.code,
                        err_code: i.err_code,
                        sdkTimeout: i.sdkTimeout,
                        dataType: i.dataType
                    }), i.reportdownbytes = i.downbytes, i.reportdowntimes = i.downtimes);
                    0 < t.length ? (o.loadInfo.reportdownbytes = o.loadInfo.cdnLoaded + o.loadInfo.scdnLoaded, o.config.stat.send(o.config.stat.SCDN_DASHSDK_NODE, t), o.FlowReportCount = 0, o.AllFlowReportCount++) : o.FlowReportCount++
                }
            }, t.prototype.ErrLogReport = function() {
                var e = this,
                    o = [];
                if (e.hdNode) {
                    var t = e.hdNode;
                    if (0 < t.errMsgArry.length) {
                        for (var i = 0; i < t.errMsgArry.length; i++) o.push(t.errMsgArry[i]);
                        t.errMsgArry = []
                    }
                }
                for (var r = 0; r < e.downloaders.length; r++)
                    if (t = e.downloaders[r], 0 < t.errMsgArry.length) {
                        for (i = 0; i < t.errMsgArry.length; i++) o.push(t.errMsgArry[i]);
                        t.errMsgArry = []
                    }
                if (0 < o.length) {
                    if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                        var a = "[{0}][{1}]Dispatcher.ErrLogReport nodesErrMsg.length[{2}] ".format(n("hh:mm:ss:S", new Date), e.config.mediaType, o.length);
                        e.config.mdebug && console.log(a), e.config.debugger(a)
                    }
                    e.config.stat.send(e.config.stat.SCDN_DASHSDK_ERROR, o)
                }
            }, t.prototype.removeDownLoader = function(e, o, t) {
                var i = this;
                if (e.type == d) {
                    if (2 <= i.urierrors[e.uri] || 0.11 > e.weight) {
                        var r = e.downbytes - e.reportdownbytes;
                        if (e.nodetype == d && i.config && (r = parseInt(r)), 0 < r && i.FlowReport(0), i.ErrLogReport(), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                            var c = "[{0}][{1}]Dispatcher.removeDownLoader HTTP_SDN_TYPE>> this.removeObj(loader, this.downloaders)".format(n("hh:mm:ss:S", new Date), i.config.mediaType);
                            i.config.mdebug && console.log(c), i.config.debugger(c)
                        }
                        i.removeObj(e, i.downloaders)
                    }
                    i.requestMoreNodes()
                } else e.type === a && 3 <= i.urierrors[e.uri] && i.config.bufferLen < i.config.ExitMinBufLen && (i.config.stopLoadedFlag = !0, i.emit("error", o, t))
            }, t.prototype._timeoutLoader = function(e) {
                var o = this;
                if (e.type == d) {
                    if ((2 <= o.urierrors[e.uri] || 0.11 > e.weight || e.timeoutCnt > o.config.ScdnMaxTimeOutNum || e.timeoutDown > o.config.ScdnMaxTimeOutNum) && (o.ErrLogReport(), 0 < e.downbytes - e.reportdownbytes && o.FlowReport(0), o.removeObj(e, o.downloaders), 0 < o.config.iSaveWaitLog || o.config.mdebug)) {
                        var t = "[{0}][{1}]Dispatcher._timeoutLoader HTTP_SDN_TYPE>> this.removeObj(loader, this.downloaders)".format(n("hh:mm:ss:S", new Date), o.config.mediaType);
                        o.config.mdebug && console.log(t), o.config.debugger(t)
                    }
                    o.requestMoreNodes()
                }
            }, t.prototype.addNode = function(e) {
                var o = this;
                if (e.type == d)
                    for (var t, n = 0; n < o.downloaders.length; n++)
                        if (t = o.downloaders[n], t.uri === e.uri && t.type === e.type) return;
                o._setupHttp(e), o.downloaders.push(e)
            }, t.prototype.requestMoreNodes = function() {
                0 < this.downloaders.length && 1 >= this.downloaders.length && !this.noMoreNodes && this.emit("needmorenodes")
            }, t.prototype.abort = function() {
                var e = this;
                if (!e.destroyed) {
                    for (var o, t = 0; t < e.downloaders.length; ++t) o = e.downloaders[t], (o.type === d || o.type == a) && o.downloading && o.abort();
                    e.UploadFlowReport(e.config.ReportMinSize)
                }
            }, t.prototype.UploadFlowReport = function(e) {
                var o = this;
                if (!o.destroyed && o.config.UploadFlowData) {
                    var t = 19;
                    0.8 < o.progressed && (t = 10), o.config.bufferLen > t && (0 < o.abortReportTimeOutId && clearTimeout(o.abortReportTimeOutId), o.abortReportTimeOutId = setTimeout(function() {
                        clearTimeout(o.abortReportTimeOutId), o.abortReportTimeOutId = 0, o.FlowReport(e)
                    }, 10))
                }
            }, t.prototype.destroy = function() {
                var e = this;
                if (!e.destroyed) {
                    if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                        var o = "[{0}][{1}]Dispatcher.destroy() downloaders.length[{2}]".format(n("hh:mm:ss:S", new Date), e.config.mediaType, e.downloaders.length);
                        e.config.mdebug && console.log(o), e.config.debugger(o)
                    }
                    e.destroyed = !0, e.app = void 0;
                    for (var t = 0; t < e.downloaders.length; ++t) e.downloaders[t].destroy();
                    e.destoryTimeId = setTimeout(function() {
                        clearTimeout(e.destoryTimeId), e.config.UploadWaitData(), e.config.bWatch || (e.updateSendLen(), !0 == e.config.UploadLog && 0 == e.config.close_ts && (e.config.close_ts = new Date().getTime(), e.config.stat.send(e.config.stat.SCDN_DASHSDK_QUALITY, {
                            upload_type: 100
                        })), e.FlowReport(0), e.ErrLogReport(), e.downloaders.length = 0, 0 < e.config.waitNum && 1 < e.config.iSaveWaitLog && 1 > e.config.iSaveLogCount && 3 > e.config.iAllSaveLogCount && (e.config.logReport.saveLog(), e.config.iSaveLogCount++, e.config.iAllSaveLogCount++), 0 < e.config.ErrCount && 4 < e.config.iSaveWaitLog && 1 > e.config.iSaveLogCount && 3 > e.config.iAllSaveLogCount && (e.config.logReport.saveLog(), e.config.iSaveLogCount++, e.config.iAllSaveLogCount++), e.config.cleanLogReport())
                    }, 3e3)
                }
            }, t.prototype.updateSendLen = function() {
                var e = this;
                e.config.send_length = e.loadInfo.cdnLoaded + e.loadInfo.scdnLoaded
            }, t.prototype.removeObj = function(e, o) {
                for (var t = o.length, n = 0; n < t; n++)
                    if (o[n] == e) {
                        o.splice(n, 1);
                        break
                    }
            }
        }, {
            "../util/dateFtt": 19,
            events: 3,
            inherits: 6
        }],
        11: [function(e, o) {
            function t(e, o, t) {
                var n = this;
                n.cb = e, n.xhr = void 0, n.abortFlag = !1, n.timerId = -1, n.config = t, n.server_ts = 0, n.start(o)
            }
            o.exports = t;
            var n = e("../util/dateFtt");
            t.prototype.start = function(e) {
                function o() {
                    var e = i.xhr = new XMLHttpRequest,
                        o = "https://cloudcfg.yfp2p.net/sdk/config" + "?app=h5_dash_bilibili&ver=" + i.config.sdkversion + i.config.cfgversion;
                    if (e.open("GET", o, !0), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                        var r = "[{0}][{1}]CloudCfg.start() send url[{2}] ".format(n("hh:mm:ss:S", new Date), i.config.mediaType, o);
                        i.config.mdebug && console.log(r), i.config.debugger(r)
                    }
                    e.onreadystatechange = function() {
                        if (2 === e.readyState || 3 === e.readyState) i.abortFlag && i.abort();
                        else if (4 == e.readyState && !i.abortFlag) {
                            if (a++, 200 <= e.status && 300 > e.status || 304 == e.status) {
                                try {
                                    d = 0, g = e.response
                                } catch (o) {
                                    d = 1
                                }
                                var o = e.getResponseHeader("date");
                                i.server_ts = new Date(o).getTime()
                            } else d = 404 == e.status ? 2 : 403 == e.status ? 3 : 5;
                            e.onerror = null, t()
                        }
                    }, e.ontimeout = function() {
                        a++, d = 4, t()
                    }, e.onerror = function() {
                        d = 5, a++, t()
                    }, e.send()
                }

                function t() {
                    s || (clearTimeout(i.timerId), 0 != d && a < c ? o() : (s = !0, r && r(d, g)))
                }
                var i = this,
                    r = i.cb,
                    a = 0,
                    d = 0,
                    c = 0,
                    s = !1,
                    g = void 0;
                o(), i.timerId = setTimeout(function() {
                    d = 4, t()
                }, e)
            }, t.prototype.abort = function() {
                var e = this;
                e.xhr && (2 == e.xhr.readyState || 3 == e.xhr.readyState) && e.xhr.abort(), clearTimeout(e.timerId), e.xhr.onreadystatechange = null, e.xhr.ontimeout = null, e.xhr.onerror = null, e.cb = null, e.abortFlag = !0
            }
        }, {
            "../util/dateFtt": 19
        }],
        12: [function(e, o) {
            function t(e) {
                this.timeout = 8e3, this.timeoutId = 0, this._receivedLength = 0, this._range = {
                    from: 0,
                    to: 0,
                    contentLength: 0,
                    fileLength: 0
                }, this.doneCount = 0, this.errorcode = 0, this.retryTime = 0, this.hasReturn = !1, this.startTime = 0, this.endTime = 0, this.nTimeOut = 1e3, this.response = void 0, this._status = d.kIdle, this.cdnType = 0, this._size = 0, this._onURLRedirect = null, this._onDataArrival = null, this._onError = null, this._onComplete = null, this._onContentLengthKnown = null, this._onCance = null, this._contentLength = 0, this.withCredentials = !1, this._requestAbort = !1, this.loader = void 0, this.strRange = "", this.fetchCreateTime = new Date().getTime(), this.config = e, this.controller = void 0, this.bSignalAbort = !0;
                var o = this;
                if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                    var t = "[{0}][{1}]fetchLoader create fetchCreateTime[{2}]".format(a("hh:mm:ss:S", new Date), o.config.mediaType, o.fetchCreateTime);
                    o.config.mdebug && console.log(t), o.config.debugger(t)
                }
            }
            o.exports = t;
            var n = e("events").EventEmitter,
                i = e("inherits"),
                r = e("../util/browser.js"),
                a = e("../util/dateFtt"),
                d = {
                    kIdle: 0,
                    kConnecting: 1,
                    kBuffering: 2,
                    kError: 3,
                    kComplete: 4
                },
                c = {
                    OK: "OK",
                    EXCEPTION: "Exception",
                    HTTP_STATUS_CODE_INVALID: "HttpStatusCodeInvalid",
                    CONNECTING_TIMEOUT: "ConnectingTimeout",
                    EARLY_EOF: "EarlyEof",
                    UNRECOVERABLE_EARLY_EOF: "UnrecoverableEarlyEof"
                };
            i(t, n), t.prototype.open = function(e, o, t, n) {
                var i = this;
                if (i.isWorking() || -1 > o) return void(i.config.mdebug && console.log("[%s][%s]fetchLoader.open() cdnType[%d]  fetch is busy! or size[%d] error", a("hh:mm:ss:S", new Date), i.config.mediaType, i.cdnType, o));
                i.startTime = new Date().getTime(), i.loader && (i.loader.startTime = i.startTime, ++i.loader.usetimes, i.loader.Onedowntimes = 0), i.endTime = i.startTime, i.timeout = n, i._receivedLength = 0, i._contentLength = 0, i._size = o + 1, i.strRange = "bytes=0-" + o, 0 < t && 0 <= o ? (i.strRange = "bytes=" + t + "-" + (t + o), i._contentLength = o + 1) : 0 < t && -1 == o && (i.strRange = "bytes=" + t + "-"), i._range = {
                    from: t,
                    to: t + o
                };
                var r = new Headers;
                r.append("Range", i.strRange), 3 == i.loader.nodetype && r.append("X-CDN-UserAgent", "PCDN-SDK");
                var s = "";
                if (s = {
                        method: "GET",
                        headers: r,
                        mode: "cors",
                        cache: "no-store",
                        redirect: "follow",
                        referrerPolicy: "no-referrer-when-downgrade",
                        signal: void 0
                    }, i.controller = void 0, i.config.bFetchSignalAbort) try {
                    i.controller = new AbortController, i.controller && i.controller.signal ? s.signal = i.controller.signal : (i.bSignalAbort = !1, i.controller = void 0, i.config.bFetchSignalAbort = !1)
                } catch (e) {
                    i.controller = void 0, i.config.bFetchSignalAbort = !1, i.bSignalAbort = !1
                }
                if (i.withCredentials && 0 == i.cdnType && (s.credentials = "include"), 0 < i.config.iSaveWaitLog || i.config.mdebug) {
                    var g = "[{0}][{1}]fetchLoader.open() >>fetch() fetchCreateTime[{2}] cdnType[{3}] range[{4}]".format(a("hh:mm:ss:S", new Date), i.config.mediaType, i.fetchCreateTime, i.cdnType, JSON.stringify(i.strRange));
                    i.config.mdebug && console.log(g), i.config.debugger(g)
                }
                return i._status = d.kConnecting, void fetch(e, s).then(function(o) {
                    if (o.ok && 200 <= o.status && 299 >= o.status) {
                        if (o.url && o.url !== e && (i._onURLRedirect && 0 == i.cdnType && i._onURLRedirect(o.url), 0 < o.url.length && i.loader && 1 == i.loader.nodetype && (i.loader.responseURL = o.url)), i._requestAbort) {
                            i._requestAbort = !1, i._status = d.kIdle;
                            var t = o.body.getReader().cancel();
                            if (i._onCance) i._onCance();
                            else if (0 < i.config.iSaveWaitLog || i.config.mdebug) {
                                var n = "[{0}][{1}]fetchLoader.open() >>fetch cancel() fetchCreateTime[{2}] cdnType[{3}] range[{4}]".format(a("hh:mm:ss:S", new Date), i.config.mediaType, i.fetchCreateTime, i.cdnType, JSON.stringify(i.strRange));
                                i.config.mdebug && console.log(n), i.config.debugger(n)
                            }
                            return t
                        }
                        var r = o.headers.get("Content-Length");
                        if (null != r && (i._contentLength = parseInt(r)), i._onContentLengthKnown) {
                            var s = o.headers.get("Content-Range");
                            if (s && null != s) {
                                var g = +s.split(" ", 2)[1].split("/", 2)[1];
                                i._onContentLengthKnown(g)
                            }
                        }
                        return i._pump.call(i, o.body.getReader())
                    }
                    i.updateLoaderTime(), i._status = d.kError, i._requestAbort = !1, (0 < i.config.iSaveWaitLog || i.config.mdebug) && (n = "[{0}][{1}]fetchLoader.fetch() cdnType[{2}] status[{3}] statusText[{4}]".format(a("hh:mm:ss:S", new Date), i.config.mediaType, i.cdnType, o.status, o.statusText), i.config.mdebug && console.log(n), i.config.debugger(n));
                    var u = {
                        code: o.status,
                        msg: o.statusText
                    };
                    o && 403 == o.status && (u.msg = "Forbidden"), i._onError && !i._requestAbort ? i._onError(c.HTTP_STATUS_CODE_INVALID, u, 20) : i.config.mdebug && console.log("[%s][%s]fetchLoader.open() cdnType[%d]  erro info1[%s]", a("hh:mm:ss:S", new Date), i.config.mediaType, i.cdnType, JSON.stringify(u))
                }).catch(function(o) {
                    if (i.updateLoaderTime(), i._status = d.kError, "AbortError" === o.name) return i.controller = void 0, i.config.bCurSignalAbort = !0, void(!0 == i._requestAbort && (i._requestAbort = !1, i.config.mdebug && console.log("[%s][%s]fetchLoader.fetch() fetchCreateTime[%d] fetch cancel ok Msg[%s] ", a("hh:mm:ss:S", new Date), i.config.mediaType, i.fetchCreateTime, o.message), i._onCance && i._onCance()));
                    i._requestAbort = !1;
                    var e = {
                        code: -1,
                        msg: o.message
                    };
                    i.withCredentials && 0 == i.cdnType && e.msg && (e.msg += "_withCredentials is true"), i._onError && !i._requestAbort ? i._onError(c.EXCEPTION, e, 21) : i.config.mdebug && console.log("[%s][%s]fetchLoader.open() cdnType[%d]  fetchCreateTime[%d] erro info2[%s]", a("hh:mm:ss:S", new Date), i.config.mediaType, i.cdnType, i.fetchCreateTime, JSON.stringify(e))
                })
            }, t.prototype._pump = function(e) {
                var o = this;
                return e.read().then(function(t) {
                    if (t.done) {
                        if (o.updateLoaderTime(), o._receivedLength == o._size && 0 < o._size) return o._status = d.kComplete, void(o._onComplete && !o._requestAbort ? o._onComplete(o._range.from, o._range.from + o._receivedLength - 1) : o.config.mdebug && console.log("[%s][%s]fetchLoader._pump() cdnType[%d]  is  Download complete1 from[%s]", a("hh:mm:ss:S", new Date), o.config.mediaType, o.cdnType, o._range.from));
                        if (null !== o._contentLength && o._receivedLength < o._contentLength && 0 < o._contentLength) {
                            o._status = d.kError;
                            var n = c.EARLY_EOF,
                                i = {
                                    code: -2,
                                    msg: "Fetch stream meet Early-EOF"
                                };
                            if (0 < o.config.iSaveWaitLog || o.config.mdebug) {
                                var r = "[{0}][{1}]fetchLoader._pump() cdnType[{2}]  _receivedLength[{3}] _contentLength[{4}] erro info1[{5}]".format(a("hh:mm:ss:S", new Date), o.config.mediaType, o.cdnType, o._receivedLength, o._contentLength, JSON.stringify(i));
                                o.config.mdebug && console.log(r), o.config.debugger(r)
                            }
                            o._onError && !o._requestAbort && o._onError(n, i, 22)
                        } else o._status = d.kComplete, o._onComplete && !o._requestAbort ? o._onComplete(o._range.from, o._range.from + o._receivedLength - 1) : o.config.mdebug && console.log("[%s][%s]fetchLoader._pump() cdnType[%d]  is  Download complete from[%s]", a("hh:mm:ss:S", new Date), o.config.mediaType, o.cdnType, o._range.from)
                    } else {
                        o._onDataArrival && void 0 != o._onDataArrival || (o._requestAbort = !0);
                        var s = t.value,
                            g = o._range.from + o._receivedLength;
                        if (o._receivedLength += s.byteLength, o.loader && (o.loader.downbytes += s.byteLength), o._status = d.kBuffering, o._onDataArrival && !o._requestAbort ? o._onDataArrival(s, g, o._receivedLength) : o.config.mdebug && o._requestAbort && console.log("[%s][%s]fetchLoader._pump() cdnType[%d] can not _onDataArrival size[%d]", a("hh:mm:ss:S", new Date), o.config.mediaType, o.cdnType, s.byteLength), !0 === o._requestAbort) {
                            o._requestAbort = !1, o._status = d.kIdle, o.loader && (o.loader.downbytes += s.byteLength);
                            var u = e.cancel();
                            return o._onCance ? o._onCance() : (0 < o.config.iSaveWaitLog || o.config.mdebug) && (r = "[{0}][{1}]fetchLoader._pump() >>fetch cancel() fetchCreateTime[{2}] cdnType[{3}] range[{4}] receivedLength[{5}] byteStart[{6}] chunk.byteLength[{7}]".format(a("hh:mm:ss:S", new Date), o.config.mediaType, o.fetchCreateTime, o.cdnType, JSON.stringify(o.strRange), o._receivedLength, g, s.byteLength), o.config.mdebug && console.log(r), o.config.debugger(r)), u
                        }
                        return o._pump.call(o, e)
                    }
                }).catch(function(t) {
                    if (11 === t.code && r.msedge, o.updateLoaderTime(), o._status = d.kError, "AbortError" === t.name) return o.controller = void 0, o.config.bCurSignalAbort = !0, void(!0 == o._requestAbort && (o._requestAbort = !1, o.config.mdebug && console.log("[%s][%s]fetchLoader._pump() self.fetchCreateTime[%d] fetch cancel ok Msg[%s] ", a("hh:mm:ss:S", new Date), o.config.mediaType, o.fetchCreateTime, t.message), o._onCance && o._onCance()));
                    o._requestAbort = !1;
                    var e = 0,
                        n = null;
                    (19 === t.code || "network error" === t.message) && (null === o._contentLength || 0 < o._contentLength && o._receivedLength < o._contentLength) ? (e = c.EARLY_EOF, n = {
                        code: t.code,
                        msg: "Fetch stream meet Early-EOF"
                    }) : (e = c.EXCEPTION, n = {
                        code: t.code,
                        msg: t.message
                    }), n && (0 == n.code || !t.code) && (n.code = -2), n && !n.msg && (n.msg = "fetch network error"), o._onError && !o._requestAbort ? o._onError(e, n, 23) : o.config.mdebug && console.log("[%s][%s]fetchLoader._pump() cdnType[%d] catch  erro info2[%s]", a("hh:mm:ss:S", new Date), o.config.mediaType, o.cdnType, JSON.stringify(n))
                })
            }, t.prototype.abort = function() {
                var e = this;
                if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                    var o = "[{0}][{1}]fetchLoader.abort() fetchCreateTime[{2}] cdnType[{3}] range[{4}] size[{5}] bCurSignalAbort[{6}]".format(a("hh:mm:ss:S", new Date), e.config.mediaType, e.fetchCreateTime, e.cdnType, JSON.stringify(e.strRange), e._size, e.config.bCurSignalAbort);
                    e.config.mdebug && console.log(o), e.config.debugger(o)
                }
                e.isWorking() && (e._requestAbort = !0, e.updateLoaderTime(), e.controller && e.controller.abort())
            }, t.prototype.FetchClean = function() {
                var e = this;
                if (0 < e.config.iSaveWaitLog || e.config.mdebug) {
                    var o = "[{0}][{1}]fetchLoader.FetchClean() fetchCreateTime[{2}] cdnType[{3}] range[{4}] size[{5}]".format(a("hh:mm:ss:S", new Date), e.config.mediaType, e.fetchCreateTime, e.cdnType, JSON.stringify(e.strRange), e._size);
                    e.config.mdebug && console.log(o), e.config.debugger(o)
                }
                e._requestAbort = !0, e.isWorking() && (e.updateLoaderTime(), e._requestAbort = !0), e._onContentLengthKnown = void 0, e._onDataArrival = void 0, e._onError = void 0, e._onComplete = void 0, e._onCance = void 0
            }, t.prototype.updateLoaderTime = function() {
                var e = this;
                e.endTime = new Date().getTime(), e.loader && 0 < e.loader.startTime && (e.loader.Onedowntimes = e.endTime - e.loader.startTime, e.loader.downtimes += e.loader.Onedowntimes, 0 < e._receivedLength && (e.loader.downLoadtime += e.loader.Onedowntimes, e.loader.updateSpeed()), e.loader.startTime = 0)
            }, t.prototype.destroy = function() {
                var e = this;
                e.FetchClean()
            }, t.prototype.isSupported = function() {
                try {
                    var e = r.msedge && 15048 <= r.version.minor,
                        o = !r.msedge || e;
                    return self.fetch && self.ReadableStream && o
                } catch (o) {
                    return !1
                }
            }, t.prototype.isWorking = function() {
                var e = this;
                return e._status === d.kConnecting || e._status === d.kBuffering
            }
        }, {
            "../util/browser.js": 18,
            "../util/dateFtt": 19,
            events: 3,
            inherits: 6
        }],
        13: [function(e, o) {
            o.exports = function(e, o) {
                function r() {
                    b++;
                    var o = new XMLHttpRequest;
                    o.open("GET", l, !0), o.timeout = 6e3, o.onload = function() {
                        if (200 <= this.status && 300 > this.status || 304 == this.status) {
                            c = 0;
                            var o = JSON.parse(this.response);
                            if (e.mdebug && console.log("[%s][%s]toGetNodes response[%s]", n("hh:mm:ss:S", new Date), e.mediaType, this.response), s = o.code, o.data && o.data.urls) {
                                s = 0;
                                for (var t = "", r = 0; r < o.data.urls.snodes.length; r++) t = o.data.urls.snodes[r], t && (0 < e.scdnNodeParam.length && 0 > t.indexOf(e.scdnNodeParam) && (0 < t.indexOf("?") ? t += "&" + e.scdnNodeParam : t += "?" + e.scdnNodeParam), d.push({
                                    uri: t,
                                    type: "node",
                                    nodetype: 1
                                }));
                                for (r = 0; r < o.data.urls.cnodes.length; r++) t = o.data.urls.cnodes[r], t && d.push({
                                    uri: t,
                                    type: "node",
                                    nodetype: 2
                                })
                            }
                        } else c = 1;
                        a()
                    }, o.ontimeout = function() {
                        e.mdebug && console.log("[%s][%s]toGetNodes xhr.ontimeout()", n("hh:mm:ss", new Date), e.mediaType), c = 2, a()
                    }, o.onerror = function() {
                        e.mdebug && console.log("[%s][%s]toGetNodes xhr.onerror()", n("hh:mm:ss", new Date), e.mediaType), c = 3, e.server_ts = 0, a()
                    }, e.mdebug && console.log("[%s][%s]toGetNodes send() url[%s]", n("hh:mm:ss", new Date), e.mediaType, l), o.send()
                }

                function a() {
                    0 != c && 3 > b && !e.stopLoadedFlag ? setTimeout(function() {
                        r()
                    }, 1e3 * b) : o(d, c, s)
                }
                var d = [],
                    c = 0,
                    s = -1;
                if (!e.bUseScdn) return void a();
                var g = e.GET_EDGE_NODES_ADDR,
                    u = e.videourl;
                if (0 < e.domain.indexOf(".acgvideo.com") || 0 < e.domain.indexOf(".bilivideo.com") || 0 < e.domain.indexOf(".bilivideo.cn")) u = e.videourl.replace(e.domain, e.queryNodeDomain);
                else if (e.ToReplaceDomain)
                    for (var f = 0; f < e.ToReplaceDomain.length; f++)
                        if (e.ToReplaceDomain[f] && 0 < e.domain.indexOf(e.ToReplaceDomain[f])) {
                            u = e.videourl.replace(e.domain, e.queryNodeDomain);
                            break
                        }
                var i = u,
                    p = 0;
                p = 0 < e.server_ts ? parseInt(e.server_ts / 1e3) + e.timercount + 3600 : parseInt(new Date().getTime() / 1e3) + 3600, i = encodeURIComponent(i);
                var l = g + "?url=" + i + "&upt=",
                    m = e.secretKey,
                    h = e.GET_EDGE_NODES_URI,
                    y = m + "&" + p + "&" + h;
                y = t(y), y = y.slice(12, 20) + p, l = l + y + "&ak=" + e.accessKey;
                var b = 0;
                r()
            };
            var t = e("blueimp-md5"),
                n = e("../util/dateFtt")
        }, {
            "../util/dateFtt": 19,
            "blueimp-md5": 5
        }],
        14: [function(e, o) {
            function n(e, o, t, n) {
                r.call(this), n = n || {}, this.uri = e, this.type = "server" === o ? 0 : 1, this.nodetype = t, this.downbytes = 0, this.reportdownbytes = 0, this.syncdownbytes = 0, this.downtimes = 0, this.reportdowntimes = 0, this.Onedowntimes = 0, this.usetimes = 0, this.downfails = 0, this.timeoutCnt = 0, this.timeoutDown = 0, this.code = 0, this.err_code = 0, this.lastRange = 0, this.sameRangeCount = 0, this.downloading = !1, this.bGetContentRange = !1, this.queue = [], this.startTime = 0, this.endTime = 0, this.weight = 1, this.isAsync = n.isAsync || !1, this.start = 0, this.end = 0, this.timeout = n.timeout || 1e4, this.timeoutId = 0, this.blockNum = 8, this.keepRecevieNum = 0, this.waitAbortRange = "", this.errTime = 0, this._xhr = null, this.speed = 0, this.fDownLoad = 0, this.curDownbytes = 0, this.withCredentials = !1, this.bUse = !1, this.sdkTimeout = 0, this.dataType = 1, this.errMsgArry = [], this.config = n.config, this.range = "", this.rangeSize = 0, this.iProgressArrival = 0, this.responseURL = "", this.preUseTime = 0, this.downLoadtime = 0, this.iUrlErrStatus = 0, this.connTimeOut = 1900, this.connTimeoutId = 0, this.nTimeOutCount = 0, this.nCompleteCount = 0, this.loadedLen = 0
            }
            o.exports = n;
            var i = e("buffer").Buffer,
                r = e("events").EventEmitter,
                a = e("inherits"),
                d = e("../util/dateFtt");
            a(n, r), n.prototype.open = function(e, o, t) {
                var n = this;
                if (void 0 !== e && null !== e) {
                    if (n.lastRange == e ? n.sameRangeCount++ : (n.lastRange = e, n.sameRangeCount = 0), n.startTime = new Date().getTime(), n.endTime = n.startTime, n.rangeSize = o - e, n.config.appendCount = 0, n.usetimes += 1, n.loadedLen = 0, 0 < t && (n.timeout = t), n.isAsync ? n._getChunk(e, o) : n.downloading ? n.queue.push([e, o]) : n._getChunk(e, o), 0 == n.nodetype && n.connTimeOut != n.config.fetchCdnFirstTimeOut ? n.connTimeOut = n.config.fetchCdnFirstTimeOut : 0 < n.nodetype && n.connTimeOut != n.config.fetchScdnFirstTimeOut && (n.connTimeOut = n.config.fetchScdnFirstTimeOut), 0 == n.type && n.config.bTimeOutAddTime && 0 < n.nTimeOutCount) {
                        var i = n.nTimeOutCount;
                        4 < i && (i = 4), n.connTimeOut += 1e3 * i
                    }
                    n.clearTimeOutID(), n.connTimeoutId = setTimeout(function() {
                        clearTimeout(n.connTimeoutId), n.connTimeoutId = 0, n.nTimeOutCount++, n.timeoutCnt++, n.updateLoadTime(), n.config.mdebug && console.log("[%s][%s]xhrLoader.connect Timeout() connTimeOut[%d] cdnType[%d] fDownLoad[%s] speed[%d]kb", d("hh:mm:ss:S", new Date), n.config.mediaType, n.connTimeOut, n.nodetype, n.fDownLoad, n.speed), n.weight -= 0.3, n.AddErrMsgArry({
                            err_code: 15,
                            err_msg: "xhr conn TimeOut",
                            err_pos: 9,
                            node_type: n.nodetype,
                            sCanceNum: n.config.sCanceNum,
                            bufferLen: parseInt(n.config.bufferLen),
                            pull_type: "xhr",
                            waitNum: n.config.waitNum,
                            range: n.range,
                            rangeSize: n.rangeSize,
                            timeout: n.timeout,
                            useTime: n.Onedowntimes,
                            usetimes: n.usetimes,
                            send_length: n.config.send_length,
                            url: n.uri
                        }), n.emit("timeout")
                    }, n.connTimeOut)
                }
            }, n.prototype.abort = function() {
                var e = this;
                e._xhr && (e._xhr.abort(), e._xhr.onreadystatechange = null, e._xhr.onprogress = null, e._xhr.onload = null, e._xhr.onerror = null, e._xhr.ontimeout = null), e.config.appendCount = 0, e.downloading = !1, e.clearTimeOutID(), e.bUse = !1
            }, n.prototype.clearQueue = function() {
                var e = this;
                0 < e.queue.length && (e.queue = [])
            }, n.prototype.AddErrMsgArry = function(e) {
                var o = this;
                if (o.updateErrTime(), o.config.UploadErrLog && o.errMsgArry.push(e), 0 < o.config.iSaveWaitLog || o.config.mdebug) {
                    var t = "[{0}][{1}]##xhrLoader.AddErrMsgArry() timeoutDown[{2}] timeoutCnt[{3}]  curErrJson[{4}]".format(d("hh:mm:ss:S", new Date), o.config.mediaType, o.timeoutDown, o.timeoutCnt, JSON.stringify(e));
                    o.config.mdebug && console.log(t), o.config.debugger(t)
                }
            }, n.prototype.advanceTimeOut = function() {
                var e = this;
                e.clearTimeOutID(), e.updateLoadTime(), e.weight -= 0.2, e.config.mdebug && console.log("[%s][%s]xhrLoader.advanceTimeOut() cdnType[%d] fDownLoad[%s] ", d("hh:mm:ss:S", new Date), e.config.mediaType, e.nodetype, e.fDownLoad), e.AddErrMsgArry({
                    err_code: 10,
                    err_msg: "xhr advance TimeOut",
                    err_pos: 11,
                    node_type: e.nodetype,
                    sCanceNum: e.config.sCanceNum,
                    bufferLen: parseInt(e.config.bufferLen),
                    pull_type: "xhr",
                    waitNum: e.config.waitNum,
                    range: e.range,
                    rangeSize: e.rangeSize,
                    timeout: e.timeout,
                    useTime: e.Onedowntimes,
                    usetimes: e.usetimes,
                    send_length: e.config.send_length,
                    url: e.uri
                }), e.emit("timeout")
            }, n.prototype._getChunk = function(e, o) {
                var t = this;
                t.start = e, t.end = o, t.curDownbytes = o - e, t.downloading = !0, t.fDownLoad = 0, t._xhr = null;
                var n = t.uri,
                    i = new XMLHttpRequest;
                t._xhr = i, i.open("GET", n), i.responseType = "arraybuffer", i.timeout = t.timeout, !0 == t.withCredentials && 0 == t.type && (i.withCredentials = t.withCredentials), t.range = "bytes=" + e + "-" + o, t.errTime = 0;
                if (i.setRequestHeader("Range", t.range), 3 == t.nodetype && i.setRequestHeader("X-CDN-UserAgent", "PCDN-SDK"), i.onload = function() {
                        if (200 <= i.status && 300 > i.status || 304 == i.status) try {
                            if (t.downloading = !1, t.clearTimeOutID(), t.endTime = new Date().getTime(), t.Onedowntimes = t.endTime - t.startTime, t.downtimes += t.Onedowntimes, t.downLoadtime += t.Onedowntimes, 0 == t.config.filesize && !1 == t.bGetContentRange) {
                                t.bGetContentRange = !0;
                                var n = i.getResponseHeader("Content-Range");
                                n && null != n && (t.config.filesize = +n.split(" ", 2)[1].split("/", 2)[1])
                            }
                            if (1 == t.nodetype && t.uri != i.responseURL && i.responseURL && 0 < i.responseURL.length && (t.responseURL = i.responseURL), t.err_code = 0, t._handleChunk(e + "-" + o, this.response), !t.isAsync && 0 < t.queue.length) {
                                var r = t.queue.shift();
                                t._getChunk(r[0], r[1])
                            }
                        } catch (e) {
                            t.downfails++;
                            var a = "xhr Parsing catch Error";
                            e && e.message && (a = e.message), t.config.mdebug && console.log("[%s][%s]xhrLoader.catch error err[%s]", d("hh:mm:ss:S", new Date), t.config.mediaType, a), t.AddErrMsgArry({
                                err_code: -1,
                                err_msg: a,
                                err_pos: 15,
                                node_type: t.nodetype,
                                sCanceNum: t.config.sCanceNum,
                                bufferLen: parseInt(t.config.bufferLen),
                                pull_type: "xhr",
                                waitNum: t.config.waitNum,
                                range: t.range,
                                rangeSize: t.rangeSize,
                                timeout: t.timeout,
                                useTime: t.Onedowntimes,
                                usetimes: t.usetimes,
                                send_length: t.config.send_length,
                                url: t.uri
                            }), t.downloading = !1, t.emit("error", -1, a)
                        } else t.updateLoadTime(), t.downfails++, a = i.status, i.statusText && (a = i.statusText), 403 == i.status && (a = "Forbidden"), t.AddErrMsgArry({
                            err_code: i.status,
                            err_msg: a,
                            err_pos: 12,
                            node_type: t.nodetype,
                            sCanceNum: t.config.sCanceNum,
                            bufferLen: parseInt(t.config.bufferLen),
                            pull_type: "xhr",
                            waitNum: t.config.waitNum,
                            range: t.range,
                            rangeSize: t.rangeSize,
                            timeout: t.timeout,
                            useTime: t.Onedowntimes,
                            usetimes: t.usetimes,
                            send_length: t.config.send_length,
                            url: t.uri
                        }), t.code = i.status, t.err_code = 5, t.downloading = !1, t.emit("error", i.status, i.statusText)
                    }, i.onreadystatechange = function() {
                        (2 === i.readyState || 3 === i.readyState) && t.waitAbortRange === t.range && (t.waitAbortRange = "", i.abort(), t.downloading = !1)
                    }, i.onprogress = function(e) {
                        e.loaded && e.total && 0 < e.total && (t.loadedLen = e.loaded, t.fDownLoad = (e.loaded / e.total).toFixed(2), t.config.appendCount++), 0 < t.connTimeoutId && 0 < t.fDownLoad && (t.config.mdebug && console.log("[%s][%s]xhrLoader.onprogress() clearTimeout connTimeoutId", d("hh:mm:ss:S", new Date), t.config.mediaType), clearTimeout(t.connTimeoutId), t.connTimeoutId = 0), t.emit("onprogress", t.lastRange, t.fDownLoad)
                    }, i.onerror = function(o) {
                        t.clearTimeOutID(), t.updateLoadTime(t.loadedLen), t.downfails++, t.err_code = 4, t.downloading = !1, t.weight -= 0.3;
                        var e = -2,
                            n = "xhr network error";
                        o && o.constructor && o.constructor.name && (n = o.constructor.name + " " + o.type), t.AddErrMsgArry({
                            err_code: e,
                            err_msg: n,
                            err_pos: 13,
                            node_type: t.nodetype,
                            sCanceNum: t.config.sCanceNum,
                            bufferLen: parseInt(t.config.bufferLen),
                            pull_type: "xhr",
                            waitNum: t.config.waitNum,
                            range: t.range,
                            rangeSize: t.rangeSize,
                            timeout: t.timeout,
                            useTime: t.Onedowntimes,
                            usetimes: t.usetimes,
                            send_length: t.config.send_length,
                            url: t.uri
                        }), t.emit("error", e, n)
                    }, i.ontimeout = function() {
                        t.clearTimeOutID(), t.updateLoadTime(t.loadedLen), t.downfails++, t.timeoutDown++, t.weight -= 0.3, t.nTimeOutCount++;
                        var e = 408,
                            o = "xhr requist time out";
                        i.status && 0 < i.status && i.statusText && (e = i.status, o = i.statusText), t.AddErrMsgArry({
                            err_code: e,
                            err_msg: o,
                            err_pos: 14,
                            node_type: t.nodetype,
                            sCanceNum: t.config.sCanceNum,
                            bufferLen: parseInt(t.config.bufferLen),
                            pull_type: "xhr",
                            waitNum: t.config.waitNum,
                            range: t.range,
                            rangeSize: t.rangeSize,
                            timeout: t.timeout,
                            useTime: t.Onedowntimes,
                            usetimes: t.usetimes,
                            send_length: t.config.send_length,
                            url: t.uri
                        }), t.err_code = 1, t.downloading = !1, t.emit("timeout")
                    }, t.waitAbortRange = "", t.iProgressArrival = 0, i.send(), 0 < t.config.iSaveWaitLog || t.config.mdebug) {
                    var r = 0;
                    0 < t.speed && 0 < t.rangeSize && (r = parseInt(t.rangeSize / t.speed));
                    var a = "[{0}][{1}]xhrLoader._getChunk() >>xhr.send() cdnType[{2}] range[{3}] LoadRangeSize[{4}]KB curDownbytes[{5}]KB speed[{6}]KB/s preUseTime[{7}]ms timeout[{8}]ms connTimeOut[{9}]  downbytes[{10}] downtimes[{11}] usetimes[{12}] nTimeOutCount[{13}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.nodetype, t.range, parseInt(t.config.LoadRangeSize / 1024), parseInt(t.curDownbytes / 1024), t.speed, r, t.timeout, t.connTimeOut, t.downbytes, t.downtimes, t.usetimes, t.nTimeOutCount);
                    t.config.mdebug && console.log(a), t.config.debugger(a)
                }
            }, n.prototype._handleChunk = function(e, o) {
                var t = this;
                if (o) {
                    var n = e.split("-")[0],
                        r = e.split("-")[1],
                        a = i.from(o);
                    a && 0 < a.length && a.length < 2 * t.rangeSize && (t.downbytes += a.length), t.updateSpeed(), t.bUse && a && 0 < a.length && (0 < t.nTimeOutCount && (t.nTimeOutCount = 0), t.emit("data", a, +n, +r))
                }
            }, n.prototype.updateErrTime = function() {
                var e = this;
                0 < e.type && (40 < e.config.bufferLen ? e.errTime = parseInt(new Date().getTime()) + 3e3 : 14 < e.config.bufferLen ? e.errTime = parseInt(new Date().getTime()) + 5e3 : e.errTime = parseInt(new Date().getTime()) + 1e4)
            }, n.prototype.clearTimeOutID = function() {
                var e = this;
                0 < e.timeoutId && (clearTimeout(e.timeoutId), e.timeoutId = 0), 0 < e.connTimeoutId && (clearTimeout(e.connTimeoutId), e.connTimeoutId = 0)
            }, n.prototype.updateSpeed = function() {
                var e = this;
                0 < e.downLoadtime && e.downbytes && 0 < e.downbytes && (e.speed = t(e.downbytes / e.downLoadtime))
            }, n.prototype.updatePreUseTime = function(e) {
                var o = this;
                return 0 < o.speed && e && 0 < e ? (o.preUseTime = parseInt(e / o.speed), 3e3 > o.preUseTime ? o.preUseTime = 3e3 : o.preUseTime > o.config.preMaxUseTime && (o.preUseTime = o.config.preMaxUseTime)) : o.preUseTime = 0, o.preUseTime
            }, n.prototype.updateTimeout = function(e) {
                var o = this;
                0 < e && (o.timeout = e)
            }, n.prototype.updateLoadTime = function(e) {
                var o = this;
                o.endTime = new Date().getTime(), 0 < o.startTime && (o.Onedowntimes = o.endTime - o.startTime, o.downtimes += o.Onedowntimes, e && 0 < e && (o.downLoadtime += o.Onedowntimes, o.updateSpeed()), o.startTime = 0)
            }, n.prototype.httpIdel = function() {
                var e = this;
                return !e.downloading && 0 >= e.queue.length
            }, n.prototype.close = function() {
                var e = this;
                e.abort()
            }, n.prototype.destroy = function() {
                var e = this;
                e.close()
            }
        }, {
            "../util/dateFtt": 19,
            buffer: 2,
            events: 3,
            inherits: 6
        }],
        15: [function(e, o) {
            function t(e, o) {
                var t = this;
                t.xhr = void 0, t.abortFlag = !1, t.timerId = -1, t.config = o, t.next_interval = 600, t.timeoutCnt = 0, t.timeout = e
            }
            o.exports = t;
            var n = e("../util/dateFtt"),
                i = "https://api.dns.yfcloud.com/api/refresh/task";
            t.prototype.start = function() {
                function e() {
                    var e = t.xhr = new XMLHttpRequest;
                    if (g = i, e.open("GET", g, !0), 0 < t.config.iSaveWaitLog || t.config.mdebug) {
                        var d = "[{0}][{1}]Heartbeat.start() send url[{2}] ".format(n("hh:mm:ss:S", new Date), t.config.mediaType, g);
                        t.config.mdebug && console.log(d), t.config.debugger(d)
                    }
                    e.onreadystatechange = function() {
                        if (2 === e.readyState || 3 === e.readyState) t.abortFlag && t.abort();
                        else if (4 == e.readyState && !t.abortFlag) {
                            if (r++, 200 <= e.status && 300 > e.status || 304 == e.status) try {
                                a = 0, s = e.response
                            } catch (o) {
                                a = 1
                            } else a = 404 == e.status ? 2 : 403 == e.status ? 3 : 5;
                            e.onerror = null, o()
                        }
                    }, e.ontimeout = function() {
                        r++, a = 4, o()
                    }, e.onerror = function() {
                        a = 5, r++, o()
                    }, e.send()
                }

                function o() {
                    if (!c)
                        if (clearTimeout(t.timerId), 0 != a && r < d) e();
                        else {
                            if (c = !0, s && 1 < s.length) {
                                var o = JSON.parse(s);
                                if (0 == o.errCode) {
                                    200 < parseInt(o.data.next_interval) && o.data.next_interval != t.next_interval && (t.next_interval = parseInt(o.data.next_interval));
                                    for (var n = 0; n < o.data.domains.length; n++) g = "https://" + o.data.domains[n] + ":2008", t._sendReq(g)
                                }
                            }
                            s = void 0
                        }
                }
                var t = this,
                    r = 0,
                    a = 0,
                    d = 0,
                    c = !1,
                    s = void 0,
                    g = i;
                e(), t.timerId = setTimeout(function() {
                    a = 4, o()
                }, t.timeout)
            }, t.prototype._sendReq = function(e) {
                var o = this,
                    t = [];
                t.push(["sdk_p", 3]), t.push(["sdk_v", o.config.sdkversion]), t.push(["sdk_channel", o.config.sdk_channel]), t.push(["uuid", o.config.vid]);
                var i = o.config.stat.generateJSON(t);
                (function(e, t) {
                    var i = new XMLHttpRequest;
                    i.open("POST", e), i.timeout = 2e3, i.onload = function() {}, i.onerror = function() {}, i.ontimeout = function() {}, i.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"), i.send(t), o.config.mdebug && console.log("[%s][%s]Heartbeat._sendReq reqUrl[%s] msg[%s]", n("hh:mm:ss:S", new Date), o.config.mediaType, e, t)
                })(e, i)
            }, t.prototype.abort = function() {
                var e = this;
                e.xhr && (2 == e.xhr.readyState || 3 == e.xhr.readyState) && e.xhr.abort(), clearTimeout(e.timerId), e.xhr.onreadystatechange = null, e.xhr.ontimeout = null, e.xhr.onerror = null, e.abortFlag = !0
            }
        }, {
            "../util/dateFtt": 19
        }],
        16: [function(e, o) {
            function t(e) {
                var o = this;
                o.config = e, o.log = "", o._logDic = [], o.startTime = new Date().getTime(), o.saved = !1
            }
            o.exports = t;
            var n = e("../util/dateFtt");
            t.prototype.clean = function() {
                var e = this;
                e._logDic = []
            }, t.prototype.saveLog = function() {
                var e = this;
                e.saved = !0;
                new Date;
                var o = "&key=h5_dash_" + e.config.sdkversion + "_" + n("MMddhh", new Date) + "_" + e.config.playSessid + "_" + e.config.mediaType + "_" + e.config.vid + "_" + new Date().getTime();
                o += "";
                let t = "";
                navigator && navigator.userAgent && (t += navigator.userAgent + "\n");
                for (var r = 0; r < this._logDic.length; r++) t += this._logDic[r].value + "\n";
                e.config.mdebug && console.log("[%s][%s]##LogReport.saveLog >>key[%s] _logDic.length[%d] logStr[%d]", n("hh:mm:ss:S", new Date), e.config.mediaType, o, e._logDic.length, t.length);
                var i = new XMLHttpRequest;
                i.open("POST", "https://err-log.yfp2p.net/file?token=b306712340ef1c5569afa4bbf5c164d0&hash=yunfan&user=yunfansdk" + o), i.timeout = 1e4, i.onload = function() {
                    200 <= this.status || 300 > this.status
                }, i.onerror = function() {}, i.ontimeout = function() {}, i.setRequestHeader("Content-Type", "text/plain"), i.send(t)
            }, t.prototype.write = function() {
                var e = this,
                    o = new Date().getTime(),
                    t = "";
                if (1 == arguments.length) t = arguments[0];
                else
                    for (var n = 0; n < arguments.length; n++) t += arguments[n] + ",";
                e._logDic.length > e.config.MaxWaitLogNum && e._logDic.shift(), e._logDic.push({
                    time: o,
                    value: t
                }), o - e._logDic[0].time > 600000 && e._logDic.shift()
            }, t.prototype.debugger = function() {
                var e = this,
                    o = arguments.length,
                    t = arguments[0],
                    o = t.length;
                switch (o) {
                    case 0:
                        break;
                    case 1:
                        e.write(t[0]);
                        break;
                    case 2:
                        e.write(t[0], t[1]);
                        break;
                    case 3:
                        e.write(t[0], t[1], t[2]);
                        break;
                    case 4:
                        e.write(t[0], t[1], t[2], t[3]);
                        break;
                    case 5:
                        e.write(t[0], t[1], t[2], t[3], t[4]);
                        break;
                    case 6:
                        e.write(t[0], t[1], t[2], t[3], t[4], t[5]);
                        break;
                    case 7:
                        e.write(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
                        break;
                    case 8:
                        e.write(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7]);
                        break;
                    case 9:
                        e.write(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
                        break;
                    default:
                        e.write(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9]);
                }
            }
        }, {
            "../util/dateFtt": 19
        }],
        17: [function(e, o) {
            function n() {
                var e = this;
                e.NGX_LOG_CRYPT_KEY = 1120700265, e.domain = "", e.config = null, e.vid = "", e.uid = "", e.appname = "", e.streamname = "", e.base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789*-[", e.SCDN_DASHSDK_QUALITY = "scdn_dashsdk_quality", e.SCDN_DASHSDK_NODE = "scdn_dashsdk_node", e.SCDN_DASHSDK_ERROR = "scdn_dashsdk_error", e.SCDN_DASHSDK_WAIT = "scdn_dashsdk_wait", e.sdk_p = 3, e.sdk_v = "", e.uuid = "", e.net = 0, e.url = "", e.media_time = 0, e.length = 0, e.server_ts = 0, e.open_ts = 0, e.first_cdn_byte = 0, e.first_cdn_time = 0, e.first_screen = 0, e.mincache_times = 0, e.midcache_times = 0, e.goodcache_times = 0, e.minsdkcache_times = 0, e.midsdkcache_times = 0, e.goodsdkcache_times = 0, e.upload_type = 0, e.bpos = 0, e.req_dispatch_num = 0, e.es_type = "", e.sdk_cache_time = 0, e.first_dispatch_nodes = 0, e.first_dispatch_msecs = 0, e.bSendQuality = !1, e.download_type = 1, e.timeoutCnt = 0, e.device_vid = "", e.dtype = 0, e.WaitMsgArry = []
            }
            o.exports = n;
            var i = e("buffer").Buffer,
                r = e("../util/dateFtt");
            n.prototype.init = function(e, o) {
                var t = this;
                t.domain = e, t.config = o, t.vid = t._getVID(), t.config.vid = t.vid, t.device_vid = t._getDeviceVID(), t.uid = t._getUID(), t.config.uid = t.uid, t.config.bWatch && (t.dtype = 1)
            }, n.prototype.send = function(e, o) {
                var t = this;
                if ("" != t.domain) {
                    var n = [],
                        r = 1,
                        a = [],
                        d = t.config.STAT_POST_URL + "?dm=" + t.domain + "&act=" + e;
                    switch (d = encodeURI(d), e) {
                        case t.SCDN_DASHSDK_QUALITY:
                            n.push(["sdk_p", 3]), n.push(["sdk_v", t.config.sdkversion]), n.push(["sdk_channel", t.config.sdk_channel]), n.push(["conf_v", t.config.conf_v]), n.push(["uuid", t.vid]), n.push(["net", 0]), n.push(["url", t.config.videourl]), n.push(["bitrate", t.config.bitrate]), n.push(["media_time", t.config.duration]), n.push(["length", t.config.filesize]), 0 < t.config.server_ts ? n.push(["server_ts", t.config.server_ts + 1e3 * t.config.timercount]) : n.push(["server_ts", 0]), n.push(["open_ts", t.open_ts]), n.push(["close_ts", t.config.close_ts]), n.push(["first_cdn_byte", t.first_cdn_byte]), n.push(["first_cdn_time", t.first_cdn_time]), n.push(["first_screen", t.first_screen]), n.push(["mincache_times", t.mincache_times]), n.push(["midcache_times", t.midcache_times]), n.push(["goodcache_times", t.goodcache_times]), n.push(["minsdkcache_times", 0]), n.push(["midsdkcache_times", 0]), n.push(["goodsdkcache_times", 0]), t.bSendQuality || (t.bSendQuality = !0), n.push(["upload_type", o.upload_type]), n.push(["bpos", t.bpos]), n.push(["req_dispatch_num", t.req_dispatch_num]), n.push(["es_type", "scdn_dashsdk_quality"]), n.push(["sdk_cache_size", 0]), n.push(["send_length", t.config.send_length]), n.push(["global_cache_time", t.config.global_cache_time]), n.push(["sdk_cache_time", 0]), n.push(["first_dispatch_nodes", t.first_dispatch_nodes]), n.push(["first_dispatch_msecs", t.first_dispatch_msecs]), n.push(["download_type", t.download_type]), n.push(["vid", t.device_vid]), n.push(["waitNum", t.config.waitNum]), n.push(["sCanceNum", t.config.sCanceNum]);
                            var c = t.config.playSessid + "#" + t.config.playDevId;
                            n.push(["session_devId", c]);
                            var s = t.generateJSON(n);
                            a.push(s);
                            break;
                        case t.SCDN_DASHSDK_NODE:
                            r = o.length;
                            for (var g, u = 0; u < o.length; ++u) g = o[u], n = [], n.push(["uuid", t.vid]), n.push(["url", t.config.videourl]), n.push(["nodeip", g.nodeip]), n.push(["nodeport", g.nodeport]), n.push(["nodetype", g.nodetype]), n.push(["downprotocol", 0]), n.push(["downbytes", g.downbytes]), n.push(["downtimes", g.downtimes]), n.push(["usetimes", g.usetimes]), n.push(["downfails", g.downfails]), n.push(["timeout", g.timeout]), n.push(["code", g.code]), n.push(["err_code", g.err_code]), n.push(["es_type", "scdn_dashsdk_node"]), n.push(["sdk_time_out", g.sdkTimeout]), n.push(["data_type", g.dataType]), n.push(["vid", t.device_vid]), n.push(["sdk_channel", t.config.sdk_channel]), n.push(["all_downbytes", g.all_downbytes]), c = t.config.playSessid + "#" + t.config.playDevId, n.push(["session_devId", c]), s = t.generateJSON(n), a.push(s);
                            break;
                        case t.SCDN_DASHSDK_ERROR:
                            for (r = o.length, u = 0; u < o.length; ++u) g = o[u], n = [], n.push(["sdk_p", 3]), n.push(["sdk_v", t.config.sdkversion]), n.push(["sdk_channel", t.config.sdk_channel]), n.push(["conf_v", t.config.conf_v]), n.push(["uuid", t.vid]), n.push(["url", t.config.videourl]), n.push(["req_url", g.url]), n.push(["download_type", t.download_type]), n.push(["err_code", g.err_code]), n.push(["err_msg", g.err_msg]), n.push(["node_type", g.node_type]), n.push(["vid", t.device_vid]), n.push(["bufferLen", parseInt(g.bufferLen)]), n.push(["length", t.config.filesize]), n.push(["media_time", t.config.duration]), n.push(["pull_type", g.pull_type]), n.push(["err_pos", g.err_pos]), n.push(["range", g.range]), n.push(["send_length", g.send_length]), n.push(["rangeSize", g.rangeSize]), n.push(["timeout", g.timeout]), n.push(["useTime", g.useTime]), n.push(["usetimes", g.usetimes]), n.push(["waitNum", g.waitNum]), n.push(["sCanceNum", g.sCanceNum]), c = t.config.playSessid + "#" + t.config.playDevId, n.push(["session_devId", c]), navigator && navigator.userAgent && "" == i && (i = navigator.userAgent.toLowerCase()), n.push(["ua", i]), n.push(["domain", t.config.domain]), n.push(["uri", t.config.keyurl]), s = t.generateJSON(n), a.push(s);
                            break;
                        case t.SCDN_DASHSDK_WAIT:
                            for (r = o.length, u = 0; u < o.length; ++u) {
                                g = o[u], t.config.iWaitReportCount++, n = [], n.push(["sdk_p", 3]), n.push(["sdk_v", t.config.sdkversion]), n.push(["sdk_channel", t.config.sdk_channel]), n.push(["conf_v", t.config.conf_v]), n.push(["vid", t.device_vid]), n.push(["uuid", t.vid]), n.push(["url", t.config.videourl]), n.push(["dtype", t.dtype]), n.push(["upload_type", g.upload_type]), n.push(["global_cache_time", parseInt(g.bufferLen)]), n.push(["mincache_times", g.mincache_times]), n.push(["midcache_times", g.midcache_times]), n.push(["goodcache_times", g.goodcache_times]), n.push(["waitNum", g.waitNum]), n.push(["errorNum", g.errorNum]), c = t.config.playSessid + "#" + t.config.playDevId, n.push(["session_devId", c]), n.push(["abortCount", g.abortCount]), n.push(["addWaitNum", g.addWaitNum]);
                                var i = "";
                                0 == t.dtype && navigator && navigator.userAgent && (i += navigator.userAgent.toLowerCase()), n.push(["ua", i]), n.push(["domain", t.config.domain]), n.push(["uri", t.config.keyurl]), n.push(["TimeOutNum", g.TimeOutNum]), n.push(["cntTimeOutNum", g.cntTimeOutNum]);
                                var f = "xhr";
                                t.config.bCurFetchSupported && (f = "fetch"), 0 != t.dtype && (f = "xhr"), n.push(["pull_type", f]), s = t.generateJSON(n), a.push(s)
                            }
                            break;
                        default:
                            return;
                    }
                    0 < a.length && t._sendReq(d, a, e, r)
                }
            }, n.prototype.AddWaitMsgArry = function(e) {
                var o = this;
                if (o.WaitMsgArry = [], o.WaitMsgArry.push(e), 0 < o.config.iSaveWaitLog || o.config.mdebug) {
                    var t = "[{0}][{1}]##Statx.AddWaitMsgArry() length[{2}]  curoJson[{3}]".format(r("hh:mm:ss:S", new Date), o.config.mediaType, o.WaitMsgArry.length, JSON.stringify(e));
                    o.config.mdebug && console.log(t), o.config.debugger(t)
                }
            }, n.prototype._sendReq = function(e, o, t, n) {
                function i(e, o, t) {
                    var n = new XMLHttpRequest;
                    n.open("POST", e), n.timeout = 8e3, n.onload = function() {
                        (200 <= this.status || 300 > this.status) && (a.timeoutCnt = 0)
                    }, n.onerror = function() {}, n.ontimeout = function() {
                        3 > a.timeoutCnt && a.SCDN_DASHSDK_NODE == o && (a.timeoutCnt++, a.config.mdebug && console.log("[%s][%s]Statx._sendReq ontimeout[%d] msg[%s]", r("hh:mm:ss:S", new Date), a.config.mediaType, a.timeoutCnt, c), i(e, o, t))
                    }, n.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"), n.send(t), a.config.mdebug && console.log("[%s][%s]Statx._sendReq msg[%s]", r("hh:mm:ss:S", new Date), a.config.mediaType, c)
                }
                var a = this,
                    d = a._ngxLogEnc(JSON.stringify({
                        key: "",
                        count: n,
                        dm: a.domain,
                        act: t,
                        data: o
                    }), a.NGX_LOG_CRYPT_KEY),
                    c = JSON.stringify({
                        dm: a.domain,
                        act: t,
                        count: n,
                        data: o
                    });
                i(e, t, d)
            }, n.prototype.generateJSON = function(e) {
                var o = "";
                if (1 > e.length) return o;
                for (var t, n = 0; n < e.length; n++)
                    if (t = e[n][1], t instanceof Array)
                        for (var i = 0; i < t.length; i++) o += t[i] + "|";
                    else o += "string" == typeof t || "number" == typeof t ? t + "|" : "|";
                return o.slice(0, -1)
            }, n.prototype._setUID = function() {
                var e = this.randomString(10);
                return e += new Date().getTime().toString().slice(8, 13), window.localStorage && (window.localStorage.domainUid = JSON.stringify({
                    uid: e,
                    sdk_ver: this.config.sdkversion
                })), e
            }, n.prototype._getUID = function() {
                var e, o;
                if (window.localStorage) try {
                    e = JSON.parse(window.localStorage.domainUid)
                } catch (o) {}
                return o = e && e.uid && 0 < e.uid.length ? e.sdk_ver == this.config.sdkversion ? e.uid : this._setUID() : this._setUID(), o
            }, n.prototype._getVID = function() {
                var e = this.randomString(15);
                return e += new Date().getTime().toString().slice(8, 13), e
            }, n.prototype._getDeviceVID = function() {
                var e = "";
                return window.localStorage && window.localStorage.vid && (e = window.localStorage.vid), 5 > e.length && (e = this.randomString(15), e += new Date().getTime().toString().slice(8, 13), window.localStorage && window.localStorage.setItem("vid", e)), e
            }, n.prototype.randomString = function(e) {
                e = e || 32;
                for (var o = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", n = o.length, r = "", a = 0; a < e; a++) r += o.charAt(t(Math.random() * n));
                return r
            }, n.prototype._ngxLogEnc = function(e, o) {
                var t = this;
                o = o || t.NGX_LOG_CRYPT_KEY;
                for (var n = o, i = o + 84836237, r = o + 278417278, a = o + 1995388704, d = 0, c = t.str2ary(e), s = c.length; s >= 8;) {
                    for (var g = 0, u = parseInt(t.pick(c, d)), f = parseInt(t.pick(c, d + 4)), p = 16; p--;) g += 2654435769, u += (f << 4) + n ^ f + g ^ (f >>> 5) + i, f += (u << 4) + r ^ u + g ^ (u >>> 5) + a, u = parseInt(u), f = parseInt(f);
                    t.memcpy(c, u, d), t.memcpy(c, f, d + 4), d += 8, s -= 8
                }
                for (; s;) c[d] ^= 255, ++d, --s;
                return t.ary2Base64str(c)
            }, n.prototype.ary2Base64str = function(e) {
                var o = i.from(e).toString("base64");
                return o = o.replace(/[+]/g, "*"), o = o.replace(/[\/]/g, "-"), o = o.replace(/[=]/g, "["), o
            }, n.prototype.str2ary = function(e) {
                var o = i.from(e);
                return o
            }, n.prototype.memcpy = function(e, o, t) {
                var n = new ArrayBuffer(4),
                    i = new DataView(n);
                i.setInt32(0, o, !1);
                var r = new Uint8Array(n);
                e[t + 3] = r[0], e[t + 2] = r[1], e[t + 1] = r[2], e[t] = r[3]
            }, n.prototype.pick = function(e, o) {
                var t = i.from([e[o + 3], e[o + 2], e[o + 1], e[o]]);
                return t.readUInt32BE(0)
            }
        }, {
            "../util/dateFtt": 19,
            buffer: 2
        }],
        18: [function(e, o) {
            var t = {};
            (function() {
                var e = self.navigator.userAgent.toLowerCase(),
                    o = /(edge)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(chrome)[ \/]([\w.]+)/.exec(e) || /(iemobile)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || 0 <= e.indexOf("trident") && /(rv)(?::| )([\w.]+)/.exec(e) || 0 > e.indexOf("compatible") && /(firefox)[ \/]([\w.]+)/.exec(e) || [],
                    n = /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(android)/.exec(e) || /(windows)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || [],
                    i = {
                        browser: o[5] || o[3] || o[1] || "",
                        version: o[2] || o[4] || "0",
                        majorVersion: o[4] || o[2] || "0",
                        platform: n[0] || ""
                    },
                    r = {};
                if (i.browser) {
                    r[i.browser] = !0;
                    var a = i.majorVersion.split(".");
                    r.version = {
                        major: parseInt(i.majorVersion, 10),
                        string: i.version
                    }, 1 < a.length && (r.version.minor = parseInt(a[1], 10)), 2 < a.length && (r.version.build = parseInt(a[2], 10))
                }
                if (i.platform && (r[i.platform] = !0), (r.chrome || r.opr || r.safari) && (r.webkit = !0), r.rv || r.iemobile) {
                    r.rv && delete r.rv;
                    var d = "msie";
                    i.browser = d, r[d] = !0
                }
                if (r.edge) {
                    delete r.edge;
                    var c = "msedge";
                    i.browser = c, r[c] = !0
                }
                if (r.opr) {
                    var s = "opera";
                    i.browser = s, r[s] = !0
                }
                if (r.safari && r.android) {
                    var g = "android";
                    i.browser = g, r[g] = !0
                }
                for (var u in r.name = i.browser, r.platform = i.platform, t) t.hasOwnProperty(u) && delete t[u];
                for (var u in r) t[u] = r[u]
            })(), o.exports = t
        }, {}],
        19: [function(e, o) {
            o.exports = function(e, n) {
                var i = {
                    "M+": n.getMonth() + 1,
                    "d+": n.getDate(),
                    "h+": n.getHours(),
                    "m+": n.getMinutes(),
                    "s+": n.getSeconds(),
                    "q+": t((n.getMonth() + 3) / 3),
                    S: n.getMilliseconds()
                };
                for (var o in /(y+)/.test(e) && (e = e.replace(RegExp.$1, (n.getFullYear() + "").substr(4 - RegExp.$1.length))), i) new RegExp("(" + o + ")").test(e) && (e = e.replace(RegExp.$1, 1 == RegExp.$1.length ? i[o] : ("00" + i[o]).substr(("" + i[o]).length)));
                return e
            }
        }, {}],
        20: [function(e, t) {
            function n(e, o, t) {
                var n = this;
                n.version = r;
                var i = this.observer = new a;
                i.trigger = function(e, o) {
                    i.emit(e, e, o)
                }, i.off = function(e, o) {
                    i.removeListener(e, o)
                }, this.on = i.on.bind(i), this.off = i.off.bind(i), this.trigger = i.trigger.bind(i), this.emit = i.emit.bind(i), this.removeAllListeners = i.removeAllListeners.bind(i), this.iocontroller = void 0, this.mediaType = t, this.PlayEventTimeOutId = 0, this.InitIO(o, e)
            }
            t.exports = n;
            var i = e("./src/controller/IOcontroller.js"),
                r = e("./package.json").version,
                a = e("events"),
                d = e("./src/util/dateFtt");
            n.prototype.InitIO = function(e, o) {
                var t = this;
                if (void 0 != t.iocontroller) return void(t.iocontroller.config.mdebug && console.log("[%s]YFDashIO.InitIO() can not repeat Init", d("hh:mm:ss:S", new Date)));
                if (!e || "VIDEO" !== e.tagName && "AUDIO" !== e.tagName && "BWP-VIDEO" !== e.tagName) throw new Error("must be video or audio!");
                t.video = e, t.h5vars = {
                    mdebug: !1
                }, t.h5vars.src = o, t.h5vars.version = t.version, t.h5vars.autoplay = e.autoplay, t.h5vars.autoload = e.autoplay, t.h5vars.mdebug = window && window.localStorage && window.localStorage.mdebug && "true" === window.localStorage.mdebug, t.iocontroller = new i(t.h5vars.src, t.h5vars, this), t.setupListeners(), t.firstScreenTime = 0;
                var n = t.iocontroller;
                if (0 < n.config.iSaveWaitLog || n.config.mdebug) {
                    var r = "[{0}][{1}]#YFDashIO.InitIO() setupTime[{2}}] fileName[{3}]".format(d("hh:mm:ss:S", new Date), n.config.mediaType, n.config.setupTime, n.stat.streamname);
                    n.config.mdebug && console.log(r), n.config.debugger(r)
                }
            }, n.prototype.load = function(e, o) {
                var t = this,
                    n = this.iocontroller;
                if (n) {
                    if (n.destroyed || !e || n.config.bWatch || !t.onDataArrival || !t.onComplete) {
                        if (0 < n.config.iSaveWaitLog || n.config.mdebug) {
                            var i = "[{0}][{1}]#YFDashIO.load() range[{2}}] sdk is destroyed or range error or sdk type is watch  or onDataArrival is null".format(d("hh:mm:ss:S", new Date), n.config.mediaType, JSON.stringify(e));
                            n.config.mdebug && console.log(i), n.config.debugger(i)
                        }
                        return
                    }
                    n.config.LoadRangeSize = 0;
                    var r = {
                        from: 0,
                        to: -1
                    };
                    if (e && (0 < e.from && (r.from = e.from), 0 < e.to && (r.to = e.to, n.config.LoadRangeSize = e.to - r.from + 1)), o != n.withCredentials && (n.withCredentials = o), 0 < n.config.iSaveWaitLog || n.config.mdebug) {
                        var a = 0;
                        n.dispatcher && n.dispatcher.loadInfo && (a = n.dispatcher.loadInfo.cdnLoaded + n.dispatcher.loadInfo.scdnLoaded), i = "[{0}][{1}]#player.load bufferlen[{2}] start[{3}] end[{4}] size[{5}] appendToPlayerPos[{6}] CacheBufSize[{7}] bytesAvailable[{8}] curCacheStart[{9}] appendCacheEnd[{10}] curCacheEnd[{11}] waitNum[{12}] abortCount[{13}] iSeekNum[{14}] uuid[{15}] cacheCleanCount[{16}] wasteDataLen[{17}] currentTime[{18}] downbytes[{19}]".format(d("hh:mm:ss:S", new Date), n.config.mediaType, n.config.bufferLen.toFixed(2), r.from, r.to, n.config.LoadRangeSize, n.appendToPlayerPos, n.CacheBufSize, n.bytesAvailable, n.curCacheStart, n.appendCacheEnd, n.curCacheEnd, n.config.waitNum, n.config.abortCount, n.iSeekNum, n.config.stat.vid, n.cacheCleanCount, n.wasteDataLen, n.config.currentTime.toFixed(2), a), n.config.mdebug && console.log(i), n.config.debugger(i)
                    }
                    n.config.hasSteupded ? t.seek(r) : n._start(r, o), t.firstScreenTime = new Date().getTime()
                }
            }, n.prototype.pause = function() {
                var e = this.iocontroller;
                !e || e.config.bWatch || (e.config.stopLoadedFlag = !0, e.abort(), e.config.mdebug && console.log("[%s][%s]YFDashIO.pause()", d("hh:mm:ss:S", new Date), e.config.mediaType))
            }, n.prototype.resume = function() {
                var e = this.iocontroller;
                !e || e.config.bWatch || (e.config.stopLoadedFlag = !1)
            }, n.prototype.seek = function(e) {
                var o = this,
                    t = o.iocontroller;
                return t ? t.config.bWatch ? void 0 : t.destroyed || !e ? void(t.config.mdebug && console.log("[%s][%s]YFDashIO.load() range[%s] sdk is destroyed or range error", d("hh:mm:ss:S", new Date), t.config.mediaType, JSON.stringify(e))) : void(t.bPlayEnd = !1, o.resume(), t.load(e)) : void 0
            }, n.prototype.abort = function() {
                var e = this,
                    o = e.iocontroller;
                !o || o.config.bWatch || (o.config.stopLoadedFlag = !0, o.abort())
            }, n.prototype.onDataArrival = null, n.prototype.DataArrival = function(e, o, t) {
                var n = this,
                    i = n.iocontroller;
                if (i) {
                    if (o && 102400 < o.length && (0 < i.config.iSaveWaitLog || i.config.mdebug)) {
                        var r = "[{0}][{1}]#player.DataArrival {2} bufferlen[{3}] start[{4}] end[{5}] size[{6}] appendToPlayerPos[{7}] chunk.length[{8}]".format(d("hh:mm:ss:S", new Date), i.config.mediaType, e, i.config.bufferLen.toFixed(2), i.range_start, i.range_end, i.config.LoadRangeSize, i.appendToPlayerPos, o.length);
                        i.config.mdebug && console.log(r), i.config.debugger(r)
                    }
                    n.onDataArrival && (o && 0 < o.length && (i.appendToPlayerPos = t + o.length), n.onDataArrival(o, t)), (o && 102400 < o.length || 0 == i.config.appendCount % 3) && n.updateBufferLen(!0)
                }
            }, n.prototype.onError = null, n.prototype.Error = function(e, o, t) {
                var n = this,
                    i = n.iocontroller;
                if (i) {
                    if (0 < i.config.iSaveWaitLog || i.config.mdebug) {
                        var r = "[{0}][{1}]#player.onError {2} bufferlen[{3}] start[{4}] end[{5}] size[{6}] appendToPlayerPos[{7}] code[{8}] errMsg[{9}]".format(d("hh:mm:ss:S", new Date), i.config.mediaType, e, i.config.bufferLen.toFixed(2), i.range_start, i.range_end, i.config.LoadRangeSize, i.appendToPlayerPos, o, t);
                        i.config.mdebug && console.log(r), i.config.debugger(r)
                    }
                    n.onError && n.onError(o, t)
                }
            }, n.prototype.onComplete = null, n.prototype.Complete = function(e) {
                var o = this,
                    t = o.iocontroller;
                if (t) {
                    if (0 < t.config.iSaveWaitLog || t.config.mdebug) {
                        var n = 0;
                        t.dispatcher && t.dispatcher.loadInfo && (n = t.dispatcher.loadInfo.cdnLoaded + t.dispatcher.loadInfo.scdnLoaded);
                        var i = "[{0}][{1}]#player.onComplete {2} bufferlen[{3}] start[{4}] end[{5}] size[{6}] appendToPlayerPos[{7}] CacheBufSize[{8}] bytesAvailable[{9}] curCacheStart[{10}] appendCacheEnd[{11}] curCacheEnd[{12}] waitNum[{13}] abortCount[{14}] iSeekNum[{15}] uuid[{16}] cacheCleanCount[{17}] wasteDataLen[{18}] currentTime[{19}] downbytes[{20}] nodeCount[{21}] fShare[{22}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, e, t.config.bufferLen.toFixed(2), t.range_start, t.range_end, t.config.LoadRangeSize, t.appendToPlayerPos, t.CacheBufSize, t.bytesAvailable, t.curCacheStart, t.appendCacheEnd, t.curCacheEnd, t.config.waitNum, t.config.abortCount, t.iSeekNum, t.config.stat.vid, t.cacheCleanCount, t.wasteDataLen, t.config.currentTime.toFixed(2), n, t.nodeCount, t.config.fShare);
                        t.config.mdebug && console.log(i), t.config.debugger(i)
                    }
                    o.onComplete && null != o.onComplete && (t.CompleteCount++, o.onComplete())
                }
            }, n.prototype.setupListeners = function() {
                var e = this,
                    t = e.iocontroller;
                t && (e.onloadedmetadata = function() {
                    !t || t.config.bWatch || t.destroyed || t.config.stopLoadedFlag || (window.player && window.player.getDuration && (t.config.duration = window.player.getDuration()), e.video && 0 < e.video.duration && 0 == t.config.duration && (t.config.duration = e.video.duration), 0 < t.config.filesize && 20 < t.config.duration && (t.config.bitrate = 8 * o(t.config.filesize / t.config.duration / 1024), t.config.bitrateLimit(), t.config.mdebug && console.log("[%s][%s]onloadedmetadata() filesize[%d] bitrate[%d]KB", d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.filesize, t.config.bitrate / 8)), t.config.hasLoadedMetadata = !0, t.startTimer(), e.buffering())
                }, e.video.addEventListener("loadedmetadata", e.onloadedmetadata, !0), e.onloadeddata = function() {
                    if (t && !t.destroyed) {
                        t.config.hasLoadeddata = !0;
                        var o = new Date().getTime();
                        t.config.stat.first_screen = o - e.firstScreenTime, t.config.mdebug && console.log("[%s][%s]onloadeddata() fs[%f]\u79D2 setupTime[%s] count[%d]", d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.stat.first_screen / 1e3, t.config.setupTime, t.count), t.config.bWatch || (e.PlayEventTimeOutId = setTimeout(function() {
                            clearTimeout(e.PlayEventTimeOutId), e.PlayEventTimeOutId = 0, t._initsingal()
                        }, 1500))
                    }
                }, e.video.addEventListener("loadeddata", e.onloadeddata, !0), e.onplay = function() {
                    t && (t.config.autoload = !0)
                }, e.video.addEventListener("play", e.onplay, !0), e.onwaiting = function() {
                    if (t) {
                        e.updateBufferLen(!0);
                        var o = new Date().getTime(),
                            n = o - t.config.SdkFristTime,
                            i = o - t.config.iLastLoadTime;
                        if (0 < t.config.iSaveWaitLog || t.config.mdebug) {
                            var r = "[{0}][{1}]##YFDashIO.onwaiting() >> bufferLen[{2}]   seekTime[{3}] activeTime[{4}] bPlayEnd[{5}] setupTime[{6}]  playDevId[{7}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), n, i, t.bPlayEnd, t.config.setupTime, t.config.playDevId);
                            t.config.mdebug && console.log(r), t.config.debugger(r)
                        }
                        if (!(1e3 > n || 0 < t.config.bufferLen || t.bPlayEnd || 6e4 < i || !t.config.bWatch && !e.onDataArrival || t.config.LastWaitVideoTime == e.video.currentTime || t.appendToPlayerPos >= t.config.filesize && 0 < t.config.filesize) && (t.config.waitNum++, e.video && e.video.currentTime && (t.config.addWaitNum++, t.config.LastWaitVideoTime = e.video.currentTime, t.config.iSaveLogCount = 0), t.config.waitNum > t.config.allowMaxWaitNum && "video" == t.config.mediaType && t.ErrorQuitActively("onwaiting()", "sdk too many waiting"), (0 < t.config.iSaveWaitLog || t.config.mdebug) && (r = "[{0}][{1}]##YFDashIO.onwaiting() >> bufferLen[{2}] waitNum[{3}]  addWaitNum[{4}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), t.config.waitNum, t.config.addWaitNum), t.config.mdebug && console.log(r), t.config.debugger(r)), t.config.UploadWaitLog)) {
                            var a = 0,
                                c = 0;
                            t.hdCdn && (a = t.hdCdn.timeoutCnt, c = t.hdCdn.timeoutDown), t.config.stat.AddWaitMsgArry({
                                upload_type: 1,
                                mincache_times: t.stat.mincache_times,
                                midcache_times: t.stat.midcache_times,
                                goodcache_times: t.stat.goodcache_times,
                                bufferLen: t.config.bufferLen.toFixed(2),
                                waitNum: t.config.waitNum,
                                errorNum: t.config.AllErrCount,
                                abortCount: t.config.abortCount,
                                addWaitNum: t.config.addWaitNum,
                                TimeOutNum: c,
                                cntTimeOutNum: a
                            })
                        }
                    }
                }, e.video.addEventListener("waiting", e.onwaiting, !0), e.onplaying = function() {
                    t && e.updateBufferLen(!0)
                }, e.video.addEventListener("playing", e.onplaying, !0), e.onseeking = function() {
                    if (t && (t.iSeekNum++, t.config.SdkFristTime = new Date().getTime(), e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = 0;
                        e.video && e.video.currentTime && (o = parseInt(e.video.currentTime));
                        var n = "[{0}][{1}]##YFDashIO.setupListeners()>>onseeking() bufferLen[{2}] currentTime[{3}] iSeekNum[{4}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2), o, t.iSeekNum);
                        t.config.mdebug && console.log(n), t.config.debugger(n)
                    }
                }, e.video.addEventListener("seeking", e.onseeking, !0), e.onSeeked = function() {
                    if (t && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]##YFDashIO.setupListeners()>>onSeeked() bufferLen[{2}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2));
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("seeked", e.onSeeked, !0), e.oncanplay = function() {
                    if (t && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]##YFDashIO.setupListeners()>>oncanplay() bufferLen[{2}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.bufferLen.toFixed(2));
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("canplay", e.oncanplay, !0), e.onpause = function() {
                    if (t && !t.config.bWatch && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]#YFDashIO.setupListeners>>onpause() playSessid[{2}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.playSessid);
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("pause", e.onpause, !0), e.onended = function() {
                    if (t && !(t.destroyed || t.config.stopLoadedFlag)) {
                        if (t.config.UploadWaitData(), 0 == t.config.close_ts) {
                            if (t.config.close_ts = new Date().getTime(), t.config.bWatch) return;
                            t.config.UploadLog && t.config.stat.send(t.config.stat.SCDN_DASHSDK_QUALITY, {
                                upload_type: 100
                            })
                        }
                        t.config.bWatch || t.dispatcher.FlowReport(0)
                    }
                }, e.video.addEventListener("ended", e.onended, !0), e.onabort = function() {
                    if (t && !t.config.bWatch && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]#YFDashIO.setupListeners>>onabort() playSessid[{2}]".format(d("hh:mm:ss:S", new Date), t.config.mediaType, t.config.playSessid);
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("abort", e.onabort, !0), e.onerror = function() {
                    if (t && !t.config.bWatch && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]#YFDashIO.setupListeners>>onerror()".format(d("hh:mm:ss:S", new Date), t.config.mediaType);
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("error", e.onerror, !0), e.onloadstart = function() {
                    if (t && !t.config.bWatch && (e.updateBufferLen(!0), 0 < t.config.iSaveWaitLog || t.config.mdebug)) {
                        var o = "[{0}][{1}]#YFDashIO.setupListeners>>onloadstart()".format(d("hh:mm:ss:S", new Date), t.config.mediaType);
                        t.config.mdebug && console.log(o), t.config.debugger(o)
                    }
                }, e.video.addEventListener("loadstart", e.onloadstart, !0))
            }, n.prototype.onplayEvent = function() {
                var e = this,
                    t = e.iocontroller;
                if (t && !t.config.bWatch) {
                    window && window.player && window.player.getDuration && (t.config.duration = window.player.getDuration()), e.video && 0 < e.video.duration && 0 == t.config.duration && (t.config.duration = e.video.duration), 0 < t.config.filesize && 20 < t.config.duration && (t.config.bitrate = 8 * o(t.config.filesize / t.config.duration / 1024)), t.config.hasLoadeddata = !0;
                    var n = 1500;
                    "video" == t.config.mediaType && (n = 2500), e.PlayEventTimeOutId = setTimeout(function() {
                        clearTimeout(e.PlayEventTimeOutId), e.PlayEventTimeOutId = 0, e.updateBufferLen(!0), t.startTimer(), e.buffering(), t._initsingal(), t.config.autoload = !0
                    }, n), e.updateBufferLen(!0)
                }
            }, n.prototype.buffering = function() {
                var e = this;
                e.updateBufferLen(!0)
            }, n.prototype.updateBufferLen = function(e) {
                var o = this,
                    t = o.iocontroller;
                !t || o.video && (o.video.paused || e) && (0 == t.config.duration && 0 < o.video.duration && (t.config.duration = o.video.duration), t.config.bufferLen = o._bufferLen(), t.config.global_cache_time = t.config.bufferLen, o.video.currentTime && (t.config.currentTime = o.video.currentTime))
            }, n.prototype._bufferLen = function() {
                var e = this;
                if (!(e.video && e.video.buffered && e.video.buffered.length)) return 0;
                for (var o = e.video.buffered.length, t = 0, n = 0; n < o; n++)
                    if (e.video.currentTime >= e.video.buffered.start(n) && e.video.currentTime < e.video.buffered.end(n)) {
                        t = e.video.buffered.end(n) - e.video.currentTime;
                        break
                    }
                return t
            }, n.prototype.loadInfo = function() {
                var e = this,
                    o = e.iocontroller;
                if (o && o.dispatcher) {
                    var t = {
                        cdn: o.dispatcher.loadInfo.cdnLoaded,
                        p2p: o.dispatcher.loadInfo.scdnLoaded,
                        url: o.dispatcher.loadInfo.curUrl
                    };
                    return t
                }
                return {
                    cdn: 0,
                    p2p: 0,
                    url: ""
                }
            }, n.prototype.destroy = function() {
                var e = this;
                e.iocontroller && (e.iocontroller.config.stopLoadedFlag = !0), 0 < e.PlayEventTimeOutId && (clearTimeout(e.PlayEventTimeOutId), e.PlayEventTimeOutId = 0), e.onDataArrival = null, e.onLoadError = null, e.onComplete = null, e.loadInfo = null, e.video && (e.video.removeEventListener("loadedmetadata", e.onloadedmetadata, !0), e.video.removeEventListener("loadeddata", e.onloadeddata, !0), e.video.removeEventListener("play", e.onplay, !0), e.video.removeEventListener("waiting", e.onwaiting, !0), e.video.removeEventListener("playing", e.onplaying, !0), e.video.removeEventListener("ended", e.onended, !0), e.video.removeEventListener("seeking", e.onseeking, !0), e.video.removeEventListener("seeked", e.onSeeked, !0), e.video.removeEventListener("canplay", e.oncanplay, !0), e.video.removeEventListener("pause", e.onpause, !0), e.video.removeEventListener("abort", e.onabort, !0), e.video.removeEventListener("error", e.onerror, !0), e.video.removeEventListener("loadstart", e.onloadstart, !0), e.video = null), e.iocontroller && e.iocontroller.destroy()
            }
        }, {
            "./package.json": 7,
            "./src/controller/IOcontroller.js": 8,
            "./src/util/dateFtt": 19,
            events: 3
        }]
    }, {}, [20])(20)
});