/*! #metadata# bp-nc-sdk: 0.10.2-1626ac3f (2021-06-28T09:02:40.612Z) */
var e, t;
e = window, t = function() {
    return function(e) {
        var t = {};

        function r(n) {
            if (t[n]) return t[n].exports;
            var s = t[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(s.exports, s, s.exports, r), s.l = !0, s.exports
        }
        return r.m = e, r.c = t, r.d = function(e, t, n) {
            r.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: n
            })
        }, r.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, r.t = function(e, t) {
            if (1 & t && (e = r(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var n = Object.create(null);
            if (r.r(n), Object.defineProperty(n, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var s in e) r.d(n, s, function(t) {
                    return e[t]
                }.bind(null, s));
            return n
        }, r.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default
            } : function() {
                return e
            };
            return r.d(t, "a", t), t
        }, r.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, r.p = "", r(r.s = 32)
    }([function(e, t, r) {
        "use strict";
        r.r(t), r.d(t, "__extends", (function() {
            return s
        })), r.d(t, "__assign", (function() {
            return i
        })), r.d(t, "__rest", (function() {
            return o
        })), r.d(t, "__decorate", (function() {
            return a
        })), r.d(t, "__param", (function() {
            return c
        })), r.d(t, "__metadata", (function() {
            return d
        })), r.d(t, "__awaiter", (function() {
            return l
        })), r.d(t, "__generator", (function() {
            return u
        })), r.d(t, "__createBinding", (function() {
            return h
        })), r.d(t, "__exportStar", (function() {
            return p
        })), r.d(t, "__values", (function() {
            return f
        })), r.d(t, "__read", (function() {
            return m
        })), r.d(t, "__spread", (function() {
            return g
        })), r.d(t, "__spreadArrays", (function() {
            return v
        })), r.d(t, "__spreadArray", (function() {
            return y
        })), r.d(t, "__await", (function() {
            return C
        })), r.d(t, "__asyncGenerator", (function() {
            return b
        })), r.d(t, "__asyncDelegator", (function() {
            return S
        })), r.d(t, "__asyncValues", (function() {
            return P
        })), r.d(t, "__makeTemplateObject", (function() {
            return T
        })), r.d(t, "__importStar", (function() {
            return R
        })), r.d(t, "__importDefault", (function() {
            return D
        })), r.d(t, "__classPrivateFieldGet", (function() {
            return k
        })), r.d(t, "__classPrivateFieldSet", (function() {
            return E
        }));
        var n = function(e, t) {
            return (n = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(e, t) {
                    e.__proto__ = t
                } || function(e, t) {
                    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                })(e, t)
        };

        function s(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

            function r() {
                this.constructor = e
            }
            n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
        }
        var i = function() {
            return (i = Object.assign || function(e) {
                for (var t, r = 1, n = arguments.length; r < n; r++)
                    for (var s in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
                return e
            }).apply(this, arguments)
        };

        function o(e, t) {
            var r = {};
            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var s = 0;
                for (n = Object.getOwnPropertySymbols(e); s < n.length; s++) t.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[s]) && (r[n[s]] = e[n[s]])
            }
            return r
        }

        function a(e, t, r, n) {
            var s, i = arguments.length,
                o = i < 3 ? t : null === n ? n = Object.getOwnPropertyDescriptor(t, r) : n;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, n);
            else
                for (var a = e.length - 1; a >= 0; a--)(s = e[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o);
            return i > 3 && o && Object.defineProperty(t, r, o), o
        }

        function c(e, t) {
            return function(r, n) {
                t(r, n, e)
            }
        }

        function d(e, t) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
        }

        function l(e, t, r, n) {
            return new(r || (r = Promise))((function(s, i) {
                function o(e) {
                    try {
                        c(n.next(e))
                    } catch (e) {
                        i(e)
                    }
                }

                function a(e) {
                    try {
                        c(n.throw(e))
                    } catch (e) {
                        i(e)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? s(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
                        e(t)
                    }))).then(o, a)
                }
                c((n = n.apply(e, t || [])).next())
            }))
        }

        function u(e, t) {
            var r, n, s, i, o = {
                label: 0,
                sent: function() {
                    if (1 & s[0]) throw s[1];
                    return s[1]
                },
                trys: [],
                ops: []
            };
            return i = {
                next: a(0),
                throw: a(1),
                return: a(2)
            }, "function" == typeof Symbol && (i[Symbol.iterator] = function() {
                return this
            }), i;

            function a(i) {
                return function(a) {
                    return function(i) {
                        if (r) throw new TypeError("Generator is already executing.");
                        for (; o;) try {
                            if (r = 1, n && (s = 2 & i[0] ? n.return : i[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, i[1])).done) return s;
                            switch (n = 0, s && (i = [2 & i[0], s.value]), i[0]) {
                                case 0:
                                case 1:
                                    s = i;
                                    break;
                                case 4:
                                    return o.label++, {
                                        value: i[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++, n = i[1], i = [0];
                                    continue;
                                case 7:
                                    i = o.ops.pop(), o.trys.pop();
                                    continue;
                                default:
                                    if (!((s = (s = o.trys).length > 0 && s[s.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === i[0] && (!s || i[1] > s[0] && i[1] < s[3])) {
                                        o.label = i[1];
                                        break
                                    }
                                    if (6 === i[0] && o.label < s[1]) {
                                        o.label = s[1], s = i;
                                        break
                                    }
                                    if (s && o.label < s[2]) {
                                        o.label = s[2], o.ops.push(i);
                                        break
                                    }
                                    s[2] && o.ops.pop(), o.trys.pop();
                                    continue
                            }
                            i = t.call(e, o)
                        } catch (e) {
                            i = [6, e], n = 0
                        } finally {
                            r = s = 0
                        }
                        if (5 & i[0]) throw i[1];
                        return {
                            value: i[0] ? i[1] : void 0,
                            done: !0
                        }
                    }([i, a])
                }
            }
        }
        var h = Object.create ? function(e, t, r, n) {
            void 0 === n && (n = r), Object.defineProperty(e, n, {
                enumerable: !0,
                get: function() {
                    return t[r]
                }
            })
        } : function(e, t, r, n) {
            void 0 === n && (n = r), e[n] = t[r]
        };

        function p(e, t) {
            for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || h(t, e, r)
        }

        function f(e) {
            var t = "function" == typeof Symbol && Symbol.iterator,
                r = t && e[t],
                n = 0;
            if (r) return r.call(e);
            if (e && "number" == typeof e.length) return {
                next: function() {
                    return e && n >= e.length && (e = void 0), {
                        value: e && e[n++],
                        done: !e
                    }
                }
            };
            throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }

        function m(e, t) {
            var r = "function" == typeof Symbol && e[Symbol.iterator];
            if (!r) return e;
            var n, s, i = r.call(e),
                o = [];
            try {
                for (;
                    (void 0 === t || t-- > 0) && !(n = i.next()).done;) o.push(n.value)
            } catch (e) {
                s = {
                    error: e
                }
            } finally {
                try {
                    n && !n.done && (r = i.return) && r.call(i)
                } finally {
                    if (s) throw s.error
                }
            }
            return o
        }

        function g() {
            for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(m(arguments[t]));
            return e
        }

        function v() {
            for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
            var n = Array(e),
                s = 0;
            for (t = 0; t < r; t++)
                for (var i = arguments[t], o = 0, a = i.length; o < a; o++, s++) n[s] = i[o];
            return n
        }

        function y(e, t) {
            for (var r = 0, n = t.length, s = e.length; r < n; r++, s++) e[s] = t[r];
            return e
        }

        function C(e) {
            return this instanceof C ? (this.v = e, this) : new C(e)
        }

        function b(e, t, r) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var n, s = r.apply(e, t || []),
                i = [];
            return n = {}, o("next"), o("throw"), o("return"), n[Symbol.asyncIterator] = function() {
                return this
            }, n;

            function o(e) {
                s[e] && (n[e] = function(t) {
                    return new Promise((function(r, n) {
                        i.push([e, t, r, n]) > 1 || a(e, t)
                    }))
                })
            }

            function a(e, t) {
                try {
                    (r = s[e](t)).value instanceof C ? Promise.resolve(r.value.v).then(c, d) : l(i[0][2], r)
                } catch (e) {
                    l(i[0][3], e)
                }
                var r
            }

            function c(e) {
                a("next", e)
            }

            function d(e) {
                a("throw", e)
            }

            function l(e, t) {
                e(t), i.shift(), i.length && a(i[0][0], i[0][1])
            }
        }

        function S(e) {
            var t, r;
            return t = {}, n("next"), n("throw", (function(e) {
                throw e
            })), n("return"), t[Symbol.iterator] = function() {
                return this
            }, t;

            function n(n, s) {
                t[n] = e[n] ? function(t) {
                    return (r = !r) ? {
                        value: C(e[n](t)),
                        done: "return" === n
                    } : s ? s(t) : t
                } : s
            }
        }

        function P(e) {
            if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
            var t, r = e[Symbol.asyncIterator];
            return r ? r.call(e) : (e = f(e), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
                return this
            }, t);

            function n(r) {
                t[r] = e[r] && function(t) {
                    return new Promise((function(n, s) {
                        ! function(e, t, r, n) {
                            Promise.resolve(n).then((function(t) {
                                e({
                                    value: t,
                                    done: r
                                })
                            }), t)
                        }(n, s, (t = e[r](t)).done, t.value)
                    }))
                }
            }
        }

        function T(e, t) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", {
                value: t
            }) : e.raw = t, e
        }
        var _ = Object.create ? function(e, t) {
            Object.defineProperty(e, "default", {
                enumerable: !0,
                value: t
            })
        } : function(e, t) {
            e.default = t
        };

        function R(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
                for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && h(t, e, r);
            return _(t, e), t
        }

        function D(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }

        function k(e, t) {
            if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance");
            return t.get(e)
        }

        function E(e, t, r) {
            if (!t.has(e)) throw new TypeError("attempted to set private field on non-instance");
            return t.set(e, r), r
        }
    }, function(e, t, r) {
        "use strict";
        var n = {
            generateIdentifier: function() {
                return Math.random().toString(36).substr(2, 10)
            }
        };
        n.localCName = n.generateIdentifier(), n.splitLines = function(e) {
            return e.trim().split("\n").map((function(e) {
                return e.trim()
            }))
        }, n.splitSections = function(e) {
            return e.split("\nm=").map((function(e, t) {
                return (t > 0 ? "m=" + e : e).trim() + "\r\n"
            }))
        }, n.getDescription = function(e) {
            var t = n.splitSections(e);
            return t && t[0]
        }, n.getMediaSections = function(e) {
            var t = n.splitSections(e);
            return t.shift(), t
        }, n.matchPrefix = function(e, t) {
            return n.splitLines(e).filter((function(e) {
                return 0 === e.indexOf(t)
            }))
        }, n.parseCandidate = function(e) {
            for (var t, r = {
                    foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0],
                    component: parseInt(t[1], 10),
                    protocol: t[2].toLowerCase(),
                    priority: parseInt(t[3], 10),
                    ip: t[4],
                    address: t[4],
                    port: parseInt(t[5], 10),
                    type: t[7]
                }, n = 8; n < t.length; n += 2) switch (t[n]) {
                case "raddr":
                    r.relatedAddress = t[n + 1];
                    break;
                case "rport":
                    r.relatedPort = parseInt(t[n + 1], 10);
                    break;
                case "tcptype":
                    r.tcpType = t[n + 1];
                    break;
                case "ufrag":
                    r.ufrag = t[n + 1], r.usernameFragment = t[n + 1];
                    break;
                default:
                    r[t[n]] = t[n + 1]
            }
            return r
        }, n.writeCandidate = function(e) {
            var t = [];
            t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
            var r = e.type;
            return t.push("typ"), t.push(r), "host" !== r && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
        }, n.parseIceOptions = function(e) {
            return e.substr(14).split(" ")
        }, n.parseRtpMap = function(e) {
            var t = e.substr(9).split(" "),
                r = {
                    payloadType: parseInt(t.shift(), 10)
                };
            return t = t[0].split("/"), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = 3 === t.length ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r
        }, n.writeRtpMap = function(e) {
            var t = e.payloadType;
            void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
            var r = e.channels || e.numChannels || 1;
            return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== r ? "/" + r : "") + "\r\n"
        }, n.parseExtmap = function(e) {
            var t = e.substr(9).split(" ");
            return {
                id: parseInt(t[0], 10),
                direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                uri: t[1]
            }
        }, n.writeExtmap = function(e) {
            return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
        }, n.parseFmtp = function(e) {
            for (var t, r = {}, n = e.substr(e.indexOf(" ") + 1).split(";"), s = 0; s < n.length; s++) r[(t = n[s].trim().split("="))[0].trim()] = t[1];
            return r
        }, n.writeFmtp = function(e) {
            var t = "",
                r = e.payloadType;
            if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                var n = [];
                Object.keys(e.parameters).forEach((function(t) {
                    e.parameters[t] ? n.push(t + "=" + e.parameters[t]) : n.push(t)
                })), t += "a=fmtp:" + r + " " + n.join(";") + "\r\n"
            }
            return t
        }, n.parseRtcpFb = function(e) {
            var t = e.substr(e.indexOf(" ") + 1).split(" ");
            return {
                type: t.shift(),
                parameter: t.join(" ")
            }
        }, n.writeRtcpFb = function(e) {
            var t = "",
                r = e.payloadType;
            return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((function(e) {
                t += "a=rtcp-fb:" + r + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
            })), t
        }, n.parseSsrcMedia = function(e) {
            var t = e.indexOf(" "),
                r = {
                    ssrc: parseInt(e.substr(7, t - 7), 10)
                },
                n = e.indexOf(":", t);
            return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r
        }, n.parseSsrcGroup = function(e) {
            var t = e.substr(13).split(" ");
            return {
                semantics: t.shift(),
                ssrcs: t.map((function(e) {
                    return parseInt(e, 10)
                }))
            }
        }, n.getMid = function(e) {
            var t = n.matchPrefix(e, "a=mid:")[0];
            if (t) return t.substr(6)
        }, n.parseFingerprint = function(e) {
            var t = e.substr(14).split(" ");
            return {
                algorithm: t[0].toLowerCase(),
                value: t[1]
            }
        }, n.getDtlsParameters = function(e, t) {
            return {
                role: "auto",
                fingerprints: n.matchPrefix(e + t, "a=fingerprint:").map(n.parseFingerprint)
            }
        }, n.writeDtlsParameters = function(e, t) {
            var r = "a=setup:" + t + "\r\n";
            return e.fingerprints.forEach((function(e) {
                r += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
            })), r
        }, n.parseCryptoLine = function(e) {
            var t = e.substr(9).split(" ");
            return {
                tag: parseInt(t[0], 10),
                cryptoSuite: t[1],
                keyParams: t[2],
                sessionParams: t.slice(3)
            }
        }, n.writeCryptoLine = function(e) {
            return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? n.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
        }, n.parseCryptoKeyParams = function(e) {
            if (0 !== e.indexOf("inline:")) return null;
            var t = e.substr(7).split("|");
            return {
                keyMethod: "inline",
                keySalt: t[0],
                lifeTime: t[1],
                mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                mkiLength: t[2] ? t[2].split(":")[1] : void 0
            }
        }, n.writeCryptoKeyParams = function(e) {
            return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
        }, n.getCryptoParameters = function(e, t) {
            return n.matchPrefix(e + t, "a=crypto:").map(n.parseCryptoLine)
        }, n.getIceParameters = function(e, t) {
            var r = n.matchPrefix(e + t, "a=ice-ufrag:")[0],
                s = n.matchPrefix(e + t, "a=ice-pwd:")[0];
            return r && s ? {
                usernameFragment: r.substr(12),
                password: s.substr(10)
            } : null
        }, n.writeIceParameters = function(e) {
            return "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"
        }, n.parseRtpParameters = function(e) {
            for (var t = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                }, r = n.splitLines(e)[0].split(" "), s = 3; s < r.length; s++) {
                var i = r[s],
                    o = n.matchPrefix(e, "a=rtpmap:" + i + " ")[0];
                if (o) {
                    var a = n.parseRtpMap(o),
                        c = n.matchPrefix(e, "a=fmtp:" + i + " ");
                    switch (a.parameters = c.length ? n.parseFmtp(c[0]) : {}, a.rtcpFeedback = n.matchPrefix(e, "a=rtcp-fb:" + i + " ").map(n.parseRtcpFb), t.codecs.push(a), a.name.toUpperCase()) {
                        case "RED":
                        case "ULPFEC":
                            t.fecMechanisms.push(a.name.toUpperCase())
                    }
                }
            }
            return n.matchPrefix(e, "a=extmap:").forEach((function(e) {
                t.headerExtensions.push(n.parseExtmap(e))
            })), t
        }, n.writeRtpDescription = function(e, t) {
            var r = "";
            r += "m=" + e + " ", r += t.codecs.length > 0 ? "9" : "0", r += " UDP/TLS/RTP/SAVPF ", r += t.codecs.map((function(e) {
                return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType
            })).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((function(e) {
                r += n.writeRtpMap(e), r += n.writeFmtp(e), r += n.writeRtcpFb(e)
            }));
            var s = 0;
            return t.codecs.forEach((function(e) {
                e.maxptime > s && (s = e.maxptime)
            })), s > 0 && (r += "a=maxptime:" + s + "\r\n"), r += "a=rtcp-mux\r\n", t.headerExtensions && t.headerExtensions.forEach((function(e) {
                r += n.writeExtmap(e)
            })), r
        }, n.parseRtpEncodingParameters = function(e) {
            var t, r = [],
                s = n.parseRtpParameters(e),
                i = -1 !== s.fecMechanisms.indexOf("RED"),
                o = -1 !== s.fecMechanisms.indexOf("ULPFEC"),
                a = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                    return n.parseSsrcMedia(e)
                })).filter((function(e) {
                    return "cname" === e.attribute
                })),
                c = a.length > 0 && a[0].ssrc,
                d = n.matchPrefix(e, "a=ssrc-group:FID").map((function(e) {
                    return e.substr(17).split(" ").map((function(e) {
                        return parseInt(e, 10)
                    }))
                }));
            d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), s.codecs.forEach((function(e) {
                if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                    var n = {
                        ssrc: c,
                        codecPayloadType: parseInt(e.parameters.apt, 10)
                    };
                    c && t && (n.rtx = {
                        ssrc: t
                    }), r.push(n), i && ((n = JSON.parse(JSON.stringify(n))).fec = {
                        ssrc: c,
                        mechanism: o ? "red+ulpfec" : "red"
                    }, r.push(n))
                }
            })), 0 === r.length && c && r.push({
                ssrc: c
            });
            var l = n.matchPrefix(e, "b=");
            return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, r.forEach((function(e) {
                e.maxBitrate = l
            }))), r
        }, n.parseRtcpParameters = function(e) {
            var t = {},
                r = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                    return n.parseSsrcMedia(e)
                })).filter((function(e) {
                    return "cname" === e.attribute
                }))[0];
            r && (t.cname = r.value, t.ssrc = r.ssrc);
            var s = n.matchPrefix(e, "a=rtcp-rsize");
            t.reducedSize = s.length > 0, t.compound = 0 === s.length;
            var i = n.matchPrefix(e, "a=rtcp-mux");
            return t.mux = i.length > 0, t
        }, n.parseMsid = function(e) {
            var t, r = n.matchPrefix(e, "a=msid:");
            if (1 === r.length) return {
                stream: (t = r[0].substr(7).split(" "))[0],
                track: t[1]
            };
            var s = n.matchPrefix(e, "a=ssrc:").map((function(e) {
                return n.parseSsrcMedia(e)
            })).filter((function(e) {
                return "msid" === e.attribute
            }));
            return s.length > 0 ? {
                stream: (t = s[0].value.split(" "))[0],
                track: t[1]
            } : void 0
        }, n.parseSctpDescription = function(e) {
            var t, r = n.parseMLine(e),
                s = n.matchPrefix(e, "a=max-message-size:");
            s.length > 0 && (t = parseInt(s[0].substr(19), 10)), isNaN(t) && (t = 65536);
            var i = n.matchPrefix(e, "a=sctp-port:");
            if (i.length > 0) return {
                port: parseInt(i[0].substr(12), 10),
                protocol: r.fmt,
                maxMessageSize: t
            };
            if (n.matchPrefix(e, "a=sctpmap:").length > 0) {
                var o = n.matchPrefix(e, "a=sctpmap:")[0].substr(10).split(" ");
                return {
                    port: parseInt(o[0], 10),
                    protocol: o[1],
                    maxMessageSize: t
                }
            }
        }, n.writeSctpDescription = function(e, t) {
            var r = [];
            return r = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && r.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), r.join("")
        }, n.generateSessionId = function() {
            return Math.random().toString().substr(2, 21)
        }, n.writeSessionBoilerplate = function(e, t, r) {
            var s = void 0 !== t ? t : 2;
            return "v=0\r\no=" + (r || "thisisadapterortc") + " " + (e || n.generateSessionId()) + " " + s + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        }, n.writeMediaSection = function(e, t, r, s) {
            var i = n.writeRtpDescription(e.kind, t);
            if (i += n.writeIceParameters(e.iceGatherer.getLocalParameters()), i += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === r ? "actpass" : "active"), i += "a=mid:" + e.mid + "\r\n", e.direction ? i += "a=" + e.direction + "\r\n" : e.rtpSender && e.rtpReceiver ? i += "a=sendrecv\r\n" : e.rtpSender ? i += "a=sendonly\r\n" : e.rtpReceiver ? i += "a=recvonly\r\n" : i += "a=inactive\r\n", e.rtpSender) {
                var o = "msid:" + s.id + " " + e.rtpSender.track.id + "\r\n";
                i += "a=" + o, i += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + o, e.sendEncodingParameters[0].rtx && (i += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + o, i += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return i += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (i += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + "\r\n"), i
        }, n.getDirection = function(e, t) {
            for (var r = n.splitLines(e), s = 0; s < r.length; s++) switch (r[s]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                    return r[s].substr(2)
            }
            return t ? n.getDirection(t) : "sendrecv"
        }, n.getKind = function(e) {
            return n.splitLines(e)[0].split(" ")[0].substr(2)
        }, n.isRejected = function(e) {
            return "0" === e.split(" ", 2)[1]
        }, n.parseMLine = function(e) {
            var t = n.splitLines(e)[0].substr(2).split(" ");
            return {
                kind: t[0],
                port: parseInt(t[1], 10),
                protocol: t[2],
                fmt: t.slice(3).join(" ")
            }
        }, n.parseOLine = function(e) {
            var t = n.matchPrefix(e, "o=")[0].substr(2).split(" ");
            return {
                username: t[0],
                sessionId: t[1],
                sessionVersion: parseInt(t[2], 10),
                netType: t[3],
                addressType: t[4],
                address: t[5]
            }
        }, n.isValidSDP = function(e) {
            if ("string" != typeof e || 0 === e.length) return !1;
            for (var t = n.splitLines(e), r = 0; r < t.length; r++)
                if (t[r].length < 2 || "=" !== t[r].charAt(1)) return !1;
            return !0
        }, e.exports = n
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        class n {}
        n.TRACK = "track", n.SOCKET_CONNECT = "socket_connect", n.SOCKET_MESSAGE = "socket_message", n.WEBRTC_ANSWER_TIMEOUT = "webrtc_answer_timeout", n.WEBRTC_CHANNEL_CLOSE = "webrtc_channel_close", t.default = n
    }, function(e, t, r) {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", {
                value: !0
            }), t.LOG_LEVEL = void 0,
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARNING = 3] = "WARNING", e[e.ERROR = 4] = "ERROR"
            }(n = t.LOG_LEVEL || (t.LOG_LEVEL = {}));
        class s {
            constructor(e = "") {
                this.namespace = e, this.state = {
                    level: n.INFO,
                    historyList: []
                }
            }
            static getInstance() {
                return s.instance || (s.instance = new s), s.instance
            }
            setLevel(e) {
                this.state.level = e
            }
            debug(e) {
                this.baseLog(e, n.VERBOSE)
            }
            log(e) {
                this.baseLog(e, n.INFO)
            }
            warn(e) {
                this.baseLog(e, n.WARNING)
            }
            error(e) {
                this.baseLog(e, n.ERROR)
            }
            baseLog(e, t = n.INFO) {
                let r = "";
                const i = {
                    level: t,
                    time: Date.now(),
                    msg: e
                };
                if (this.state.historyList.push(i), this.state.historyList.length >= s.MAX_LOG_LENGTH && this.state.historyList.shift(), i.level >= this.state.level && (r = `[${i.time}] ${i.msg}`), r) switch (i.level) {
                    case n.WARNING:
                    case n.ERROR:
                    case n.VERBOSE:
                }
            }
            getHistory(e = n.INFO) {
                let t = "";
                return this.state.historyList.forEach(r => {
                    r.level >= e && (t += `\n[BPNC ${this.namespace} ${r.time}] ${r.msg}`)
                }), t
            }
            reset() {
                this.state = {
                    level: n.INFO,
                    historyList: []
                }
            }
        }
        s.MAX_LOG_LENGTH = 2e4, t.default = s
    }, function(e, t, r) {
        const n = r(44),
            s = r(45),
            i = String.fromCharCode(30);
        e.exports = {
            protocol: 4,
            encodePacket: n,
            encodePayload: (e, t) => {
                const r = e.length,
                    s = new Array(r);
                let o = 0;
                e.forEach((e, a) => {
                    n(e, !1, e => {
                        s[a] = e, ++o === r && t(s.join(i))
                    })
                })
            },
            decodePacket: s,
            decodePayload: (e, t) => {
                const r = e.split(i),
                    n = [];
                for (let e = 0; e < r.length; e++) {
                    const i = s(r[e], t);
                    if (n.push(i), "error" === i.type) break
                }
                return n
            }
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(18);
        class s {
            constructor() {
                this.version = n.metadata.version + "-" + n.metadata.hash.substr(0, 8)
            }
            static getInstance() {
                return s.instance || (s.instance = new s), s.instance
            }
            reset() {}
        }
        s.BLOCK_SIZE = 1048576, t.default = s
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        class n {}
        n.TRACK_TYPE = {
            TEST: 1e3,
            ENTER: 1001,
            QUIT: 1002,
            SAVE_DATA: 2001,
            GET_DATA: 2002,
            OPEN_DB: 2003,
            DB_UPGRADE: 2004,
            OPEN_DB_ERROR: 2005,
            OPEN_DB_SUCCESS: 2006,
            DB_CLOSE: 2007,
            PUT_DB: 2008,
            PUT_DB_SUCCESS: 2009,
            PUT_DB_ERROR: 2010,
            DB_RESOURCE: 2011,
            DEL_DB_ERROR: 2012
        }, n.RESOURCE_OPTION = {
            UPDATE: 1,
            ADD: 2,
            DEL: 3
        }, n.RESPONSE_CODE = {
            SUCCESS: 1,
            ERROR: -1,
            FILE_READER_ERROR: -2,
            WEBRTC_OPEN_TIMEOUT: -300,
            WEBRTC_OPEN_TIMEOUT_BY_NO_LDP: -301,
            WEBRTC_OPEN_TIMEOUT_BY_NO_RDP: -302,
            WEBRTC_OPEN_TIMEOUT_BY_NO_RC: -303,
            WEBRTC_OPEN_TIMEOUT_BY_NO_ACS: -304
        }, n.RTC_STATE_CODE = {
            INIT: 1,
            DATA_CHANNEL_OPEN_SUCCESS: 2,
            DATA_CHANNEL_OPEN_ERROR: 3,
            SEND_DATA_SUCCESS: 4,
            GET_DATA_SUCCESS: 5
        }, t.default = n
    }, function(e, t, r) {
        t.formatArgs = function(t) {
            if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
            const r = "color: " + this.color;
            t.splice(1, 0, r, "color: inherit");
            let n = 0,
                s = 0;
            t[0].replace(/%[a-zA-Z%]/g, e => {
                "%%" !== e && (n++, "%c" === e && (s = n))
            }), t.splice(s, 0, r)
        }, t.save = function(e) {
            try {
                e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug")
            } catch (e) {}
        }, t.load = function() {
            let e;
            try {
                e = t.storage.getItem("debug")
            } catch (e) {}
            return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e
        }, t.useColors = function() {
            return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        }, t.storage = function() {
            try {
                return localStorage
            } catch (e) {}
        }(), t.destroy = (() => {
            let e = !1;
            return () => {
                e || (e = !0)
            }
        })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {}), e.exports = r(38)(t);
        const {
            formatters: n
        } = e.exports;
        n.j = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[UnexpectedJSONParseError]: " + e.message
            }
        }
    }, function(e, t) {
        e.exports = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")()
    }, function(e, t, r) {
        t.formatArgs = function(t) {
            if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
            const r = "color: " + this.color;
            t.splice(1, 0, r, "color: inherit");
            let n = 0,
                s = 0;
            t[0].replace(/%[a-zA-Z%]/g, e => {
                "%%" !== e && (n++, "%c" === e && (s = n))
            }), t.splice(s, 0, r)
        }, t.save = function(e) {
            try {
                e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug")
            } catch (e) {}
        }, t.load = function() {
            let e;
            try {
                e = t.storage.getItem("debug")
            } catch (e) {}
            return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e
        }, t.useColors = function() {
            return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        }, t.storage = function() {
            try {
                return localStorage
            } catch (e) {}
        }(), t.destroy = (() => {
            let e = !1;
            return () => {
                e || (e = !0)
            }
        })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {}), e.exports = r(47)(t);
        const {
            formatters: n
        } = e.exports;
        n.j = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[UnexpectedJSONParseError]: " + e.message
            }
        }
    }, function(e, t, r) {
        "use strict";
        var n;

        function s(e, t, r) {
            if (!r || typeof r.value !== n.typeOfFunction) throw new TypeError("Only methods can be decorated with @bind. <" + t + "> is not a method!");
            return {
                configurable: n.boolTrue,
                get: function() {
                    var e = r.value.bind(this);
                    return Object.defineProperty(this, t, {
                        value: e,
                        configurable: n.boolTrue,
                        writable: n.boolTrue
                    }), e
                }
            }
        }
        Object.defineProperty(t, "__esModule", {
                value: !0
            }),
            function(e) {
                e.typeOfFunction = "function", e.boolTrue = !0
            }(n || (n = {})), t.bind = s, t.default = s
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(18);
        class s {
            static cloneDeep(e, t) {
                if (null === e || "object" != typeof e) return e;
                let r;
                if (s.isTypedArray(e) && "function" == typeof e.slice) return r = e.slice(), r;
                r = Array.isArray(e) ? [] : {};
                for (const n in e)
                    if (Object.prototype.hasOwnProperty.call(e, n)) {
                        const i = e[n];
                        r[n] = t && "object" == typeof i ? s.cloneDeep(i, t) : i
                    }
                return r
            }
            static isTypedArray(e) {
                return !!(e && e.buffer instanceof ArrayBuffer && e.BYTES_PER_ELEMENT)
            }
            static downloadFile(e, t) {
                let r = document.createElement("a"),
                    n = t.slice && "data:" === t.slice(0, 5),
                    s = t.lastIndexOf && t.lastIndexOf(".") > -1;
                r.download = e, r.style.display = "none", r.href = s || n ? t : URL.createObjectURL(new Blob([t])), document.body.appendChild(r), r.click(), document.body.removeChild(r)
            }
            static concatArrayBuffer(e, t) {
                if (!e) return t;
                if (!t) return e;
                let r = new Uint8Array(e.byteLength + t.byteLength);
                return r.set(new Uint8Array(e), 0), r.set(new Uint8Array(t), e.byteLength), r.buffer
            }
            static concatUint8Array(e, t) {
                if (!e) return t;
                if (!t) return e;
                let r = new Uint8Array(e.byteLength + t.byteLength);
                return r.set(e, 0), r.set(t, e.byteLength), r
            }
            static encodeUTF8(e) {
                const t = encodeURIComponent(e),
                    r = [];
                for (let e = 0; e < t.length; e++) {
                    const n = t.charAt(e);
                    if ("%" === n) {
                        const n = t.charAt(e + 1) + t.charAt(e + 2),
                            s = parseInt(n, 16);
                        r.push(s), e += 2
                    } else r.push(n.charCodeAt(0))
                }
                return new Uint8Array(r)
            }
            static decodeUTF8(e) {
                let t = "";
                for (let r = 0; r < e.byteLength; r++) t += "%" + e[r].toString(16);
                return decodeURIComponent(t)
            }
            static isChrome() {
                const e = navigator.userAgent;
                return -1 === e.indexOf("Edge") && e.indexOf("Chrome") > -1 && e.indexOf("Safari") > -1
            }
            static isSupportP2P() {
                const e = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                return !!(s.isChrome() && window.indexedDB && (null == e ? void 0 : e.prototype.createDataChannel))
            }
            static getCookie(e) {
                if (null == e) return "";
                const t = document.cookie.split(";"),
                    r = decodeURIComponent(e);
                for (let e = 0; e < t.length; e++) {
                    const [n, s] = t[e].trim().split("=");
                    if (decodeURIComponent(n) === r) return decodeURIComponent(s)
                }
                return ""
            }
            static getLocalSettings(e) {
                return window.localStorage && localStorage.getItem ? localStorage.getItem(e) : s.getCookie(e)
            }
            static randomString(e) {
                const t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    r = t.length,
                    n = [];
                for (let s = 0; s < e; s++) {
                    const e = Math.floor(Math.random() * r);
                    n.push(t[e])
                }
                return n.join("")
            }
            static get RUNTIME_MODE() {
                let e = "production";
                return "development" === n.metadata.mode && (e = "development"), e
            }
        }
        t.default = s
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0).__importDefault(r(13));
        class s {
            constructor() {
                this.events = new n.default
            }
            static getInstance() {
                return s.instance || (s.instance = new s), s.instance
            }
            one(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.one(e, t)
            }
            on(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.on(e, t)
            }
            off(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.off(e, t)
            }
            trigger(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.trigger(e, t)
            }
            destroy() {
                this.events && (this.events.destroy(), this.events = new n.default)
            }
        }
        t.default = s
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.default = class {
            constructor() {
                this.events = {}
            }
            on(e, t) {
                "function" == typeof t && (this.events[e] || (this.events[e] = []), this.events[e].push(t))
            }
            off(e, t) {
                if ("function" == typeof t && this.events[e])
                    if (t) {
                        const r = this.events[e].indexOf(t);
                        r > -1 && this.events[e].splice(r, 1)
                    } else this.events[e] = []
            }
            one(e, t) {
                if ("function" == typeof t) {
                    this.events[e] || (this.events[e] = []);
                    const r = n => {
                        t(n), this.off(e, r)
                    };
                    this.on(e, r)
                }
            }
            trigger(e, t) {
                this.events[e] && this.events[e].length && [...this.events[e]].forEach(e => {
                    try {
                        e(t)
                    } catch (e) {}
                })
            }
            destroy() {
                this.events = {}
            }
        }
    }, function(e, t, r) {
        const n = r(4),
            s = r(15);
        e.exports = class extends s {
            constructor(e) {
                super(), this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket
            }
            onError(e, t) {
                const r = new Error(e);
                return r.type = "TransportError", r.description = t, this.emit("error", r), this
            }
            open() {
                return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this
            }
            close() {
                return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
            }
            send(e) {
                if ("open" !== this.readyState) throw new Error("Transport not open");
                this.write(e)
            }
            onOpen() {
                this.readyState = "open", this.writable = !0, this.emit("open")
            }
            onData(e) {
                const t = n.decodePacket(e, this.socket.binaryType);
                this.onPacket(t)
            }
            onPacket(e) {
                this.emit("packet", e)
            }
            onClose() {
                this.readyState = "closed", this.emit("close")
            }
        }
    }, function(e, t, r) {
        function n(e) {
            if (e) return function(e) {
                for (var t in n.prototype) e[t] = n.prototype[t];
                return e
            }(e)
        }
        e.exports = n, n.prototype.on = n.prototype.addEventListener = function(e, t) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
        }, n.prototype.once = function(e, t) {
            function r() {
                this.off(e, r), t.apply(this, arguments)
            }
            return r.fn = t, this.on(e, r), this
        }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function(e, t) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var r, n = this._callbacks["$" + e];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + e], this;
            for (var s = 0; s < n.length; s++)
                if ((r = n[s]) === t || r.fn === t) {
                    n.splice(s, 1);
                    break
                }
            return 0 === n.length && delete this._callbacks["$" + e], this
        }, n.prototype.emit = function(e) {
            this._callbacks = this._callbacks || {};
            for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            if (r) {
                n = 0;
                for (var s = (r = r.slice(0)).length; n < s; ++n) r[n].apply(this, t)
            }
            return this
        }, n.prototype.listeners = function(e) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
        }, n.prototype.hasListeners = function(e) {
            return !!this.listeners(e).length
        }
    }, function(e, t) {
        t.encode = function(e) {
            var t = "";
            for (var r in e) e.hasOwnProperty(r) && (t.length && (t += "&"), t += encodeURIComponent(r) + "=" + encodeURIComponent(e[r]));
            return t
        }, t.decode = function(e) {
            for (var t = {}, r = e.split("&"), n = 0, s = r.length; n < s; n++) {
                var i = r[n].split("=");
                t[decodeURIComponent(i[0])] = decodeURIComponent(i[1])
            }
            return t
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Decoder = t.Encoder = t.PacketType = t.protocol = void 0;
        const n = r(52),
            s = r(53),
            i = r(28),
            o = r(54)("socket.io-parser");
        var a;
        t.protocol = 5,
            function(e) {
                e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK"
            }(a = t.PacketType || (t.PacketType = {})), t.Encoder = class {
                encode(e) {
                    return o("encoding packet %j", e), e.type !== a.EVENT && e.type !== a.ACK || !i.hasBinary(e) ? [this.encodeAsString(e)] : (e.type = e.type === a.EVENT ? a.BINARY_EVENT : a.BINARY_ACK, this.encodeAsBinary(e))
                }
                encodeAsString(e) {
                    let t = "" + e.type;
                    return e.type !== a.BINARY_EVENT && e.type !== a.BINARY_ACK || (t += e.attachments + "-"), e.nsp && "/" !== e.nsp && (t += e.nsp + ","), null != e.id && (t += e.id), null != e.data && (t += JSON.stringify(e.data)), o("encoded %j as %s", e, t), t
                }
                encodeAsBinary(e) {
                    const t = s.deconstructPacket(e),
                        r = this.encodeAsString(t.packet),
                        n = t.buffers;
                    return n.unshift(r), n
                }
            };
        class c extends n {
            constructor() {
                super()
            }
            add(e) {
                let t;
                if ("string" == typeof e) t = this.decodeString(e), t.type === a.BINARY_EVENT || t.type === a.BINARY_ACK ? (this.reconstructor = new d(t), 0 === t.attachments && super.emit("decoded", t)) : super.emit("decoded", t);
                else {
                    if (!i.isBinary(e) && !e.base64) throw new Error("Unknown type: " + e);
                    if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                    t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emit("decoded", t))
                }
            }
            decodeString(e) {
                let t = 0;
                const r = {
                    type: Number(e.charAt(0))
                };
                if (void 0 === a[r.type]) throw new Error("unknown packet type " + r.type);
                if (r.type === a.BINARY_EVENT || r.type === a.BINARY_ACK) {
                    const n = t + 1;
                    for (;
                        "-" !== e.charAt(++t) && t != e.length;);
                    const s = e.substring(n, t);
                    if (s != Number(s) || "-" !== e.charAt(t)) throw new Error("Illegal attachments");
                    r.attachments = Number(s)
                }
                if ("/" === e.charAt(t + 1)) {
                    const n = t + 1;
                    for (; ++t && "," !== e.charAt(t) && t !== e.length;);
                    r.nsp = e.substring(n, t)
                } else r.nsp = "/";
                const n = e.charAt(t + 1);
                if ("" !== n && Number(n) == n) {
                    const n = t + 1;
                    for (; ++t;) {
                        const r = e.charAt(t);
                        if (null == r || Number(r) != r) {
                            --t;
                            break
                        }
                        if (t === e.length) break
                    }
                    r.id = Number(e.substring(n, t + 1))
                }
                if (e.charAt(++t)) {
                    const n = function(e) {
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            return !1
                        }
                    }(e.substr(t));
                    if (!c.isPayloadValid(r.type, n)) throw new Error("invalid payload");
                    r.data = n
                }
                return o("decoded %s as %j", e, r), r
            }
            static isPayloadValid(e, t) {
                switch (e) {
                    case a.CONNECT:
                        return "object" == typeof t;
                    case a.DISCONNECT:
                        return void 0 === t;
                    case a.CONNECT_ERROR:
                        return "string" == typeof t || "object" == typeof t;
                    case a.EVENT:
                    case a.BINARY_EVENT:
                        return Array.isArray(t) && t.length > 0;
                    case a.ACK:
                    case a.BINARY_ACK:
                        return Array.isArray(t)
                }
            }
            destroy() {
                this.reconstructor && this.reconstructor.finishedReconstruction()
            }
        }
        t.Decoder = c;
        class d {
            constructor(e) {
                this.packet = e, this.buffers = [], this.reconPack = e
            }
            takeBinaryData(e) {
                if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
                    const e = s.reconstructPacket(this.reconPack, this.buffers);
                    return this.finishedReconstruction(), e
                }
                return null
            }
            finishedReconstruction() {
                this.reconPack = null, this.buffers = []
            }
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.metadata = void 0, t.metadata = {
            name: "@bilibili-player/component.bp-p2p-sdk",
            version: "0.10.2",
            hash: "1626ac3",
            branch: "master",
            lastModefied: "2021-06-28T09:02:40.615Z",
            mode: "production"
        }
    }, function(e, t) {
        var r = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
            n = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
        e.exports = function(e) {
            var t, s, i = e,
                o = e.indexOf("["),
                a = e.indexOf("]"); - 1 != o && -1 != a && (e = e.substring(0, o) + e.substring(o, a).replace(/:/g, ";") + e.substring(a, e.length));
            for (var c, d, l = r.exec(e || ""), u = {}, h = 14; h--;) u[n[h]] = l[h] || "";
            return -1 != o && -1 != a && (u.source = i, u.host = u.host.substring(1, u.host.length - 1).replace(/;/g, ":"), u.authority = u.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), u.ipv6uri = !0), u.pathNames = (t = u.path, s = t.replace(/\/{2,9}/g, "/").split("/"), "/" != t.substr(0, 1) && 0 !== t.length || s.splice(0, 1), "/" == t.substr(t.length - 1, 1) && s.splice(s.length - 1, 1), s), u.queryKey = (c = u.query, d = {}, c.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, (function(e, t, r) {
                t && (d[t] = r)
            })), d), u
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Manager = void 0;
        const n = r(40),
            s = r(27),
            i = r(29),
            o = r(17),
            a = r(30),
            c = r(57),
            d = r(7)("socket.io-client:manager");
        t.Manager = class extends i {
            constructor(e, t) {
                super(), this.nsps = {}, this.subs = [], e && "object" == typeof e && (t = e, e = void 0), (t = t || {}).path = t.path || "/socket.io", this.opts = t, this.reconnection(!1 !== t.reconnection), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor(t.randomizationFactor || .5), this.backoff = new c({
                    min: this.reconnectionDelay(),
                    max: this.reconnectionDelayMax(),
                    jitter: this.randomizationFactor()
                }), this.timeout(null == t.timeout ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
                const r = t.parser || o;
                this.encoder = new r.Encoder, this.decoder = new r.Decoder, this._autoConnect = !1 !== t.autoConnect, this._autoConnect && this.open()
            }
            reconnection(e) {
                return arguments.length ? (this._reconnection = !!e, this) : this._reconnection
            }
            reconnectionAttempts(e) {
                return void 0 === e ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this)
            }
            reconnectionDelay(e) {
                var t;
                return void 0 === e ? this._reconnectionDelay : (this._reconnectionDelay = e, null === (t = this.backoff) || void 0 === t || t.setMin(e), this)
            }
            randomizationFactor(e) {
                var t;
                return void 0 === e ? this._randomizationFactor : (this._randomizationFactor = e, null === (t = this.backoff) || void 0 === t || t.setJitter(e), this)
            }
            reconnectionDelayMax(e) {
                var t;
                return void 0 === e ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, null === (t = this.backoff) || void 0 === t || t.setMax(e), this)
            }
            timeout(e) {
                return arguments.length ? (this._timeout = e, this) : this._timeout
            }
            maybeReconnectOnOpen() {
                !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
            }
            open(e) {
                if (d("readyState %s", this._readyState), ~this._readyState.indexOf("open")) return this;
                d("opening %s", this.uri), this.engine = n(this.uri, this.opts);
                const t = this.engine,
                    r = this;
                this._readyState = "opening", this.skipReconnect = !1;
                const s = a.on(t, "open", (function() {
                        r.onopen(), e && e()
                    })),
                    i = a.on(t, "error", t => {
                        d("error"), r.cleanup(), r._readyState = "closed", super.emit("error", t), e ? e(t) : r.maybeReconnectOnOpen()
                    });
                if (!1 !== this._timeout) {
                    const e = this._timeout;
                    d("connect attempt will timeout after %d", e), 0 === e && s();
                    const r = setTimeout(() => {
                        d("connect attempt timed out after %d", e), s(), t.close(), t.emit("error", new Error("timeout"))
                    }, e);
                    this.subs.push((function() {
                        clearTimeout(r)
                    }))
                }
                return this.subs.push(s), this.subs.push(i), this
            }
            connect(e) {
                return this.open(e)
            }
            onopen() {
                d("open"), this.cleanup(), this._readyState = "open", super.emit("open");
                const e = this.engine;
                this.subs.push(a.on(e, "ping", this.onping.bind(this)), a.on(e, "data", this.ondata.bind(this)), a.on(e, "error", this.onerror.bind(this)), a.on(e, "close", this.onclose.bind(this)), a.on(this.decoder, "decoded", this.ondecoded.bind(this)))
            }
            onping() {
                super.emit("ping")
            }
            ondata(e) {
                this.decoder.add(e)
            }
            ondecoded(e) {
                super.emit("packet", e)
            }
            onerror(e) {
                d("error", e), super.emit("error", e)
            }
            socket(e, t) {
                let r = this.nsps[e];
                return r || (r = new s.Socket(this, e, t), this.nsps[e] = r), r
            }
            _destroy(e) {
                const t = Object.keys(this.nsps);
                for (const e of t)
                    if (this.nsps[e].active) return void d("socket %s is still active, skipping close", e);
                this._close()
            }
            _packet(e) {
                d("writing packet %j", e), e.query && 0 === e.type && (e.nsp += "?" + e.query);
                const t = this.encoder.encode(e);
                for (let r = 0; r < t.length; r++) this.engine.write(t[r], e.options)
            }
            cleanup() {
                d("cleanup"), this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy()
            }
            _close() {
                d("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, "opening" === this._readyState && this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.engine && this.engine.close()
            }
            disconnect() {
                return this._close()
            }
            onclose(e) {
                d("onclose"), this.cleanup(), this.backoff.reset(), this._readyState = "closed", super.emit("close", e), this._reconnection && !this.skipReconnect && this.reconnect()
            }
            reconnect() {
                if (this._reconnecting || this.skipReconnect) return this;
                const e = this;
                if (this.backoff.attempts >= this._reconnectionAttempts) d("reconnect failed"), this.backoff.reset(), super.emit("reconnect_failed"), this._reconnecting = !1;
                else {
                    const t = this.backoff.duration();
                    d("will wait %dms before reconnect attempt", t), this._reconnecting = !0;
                    const r = setTimeout(() => {
                        e.skipReconnect || (d("attempting reconnect"), super.emit("reconnect_attempt", e.backoff.attempts), e.skipReconnect || e.open(t => {
                            t ? (d("reconnect attempt error"), e._reconnecting = !1, e.reconnect(), super.emit("reconnect_error", t)) : (d("reconnect success"), e.onreconnect())
                        }))
                    }, t);
                    this.subs.push((function() {
                        clearTimeout(r)
                    }))
                }
            }
            onreconnect() {
                const e = this.backoff.attempts;
                this._reconnecting = !1, this.backoff.reset(), super.emit("reconnect", e)
            }
        }
    }, function(e, t, r) {
        const n = r(22),
            s = r(43),
            i = r(49),
            o = r(50);
        t.polling = function(e) {
            let t, r = !1,
                o = !1;
            const a = !1 !== e.jsonp;
            if ("undefined" != typeof location) {
                const t = "https:" === location.protocol;
                let n = location.port;
                n || (n = t ? 443 : 80), r = e.hostname !== location.hostname || n !== e.port, o = e.secure !== t
            }
            if (e.xdomain = r, e.xscheme = o, t = new n(e), "open" in t && !e.forceJSONP) return new s(e);
            if (!a) throw new Error("JSONP disabled");
            return new i(e)
        }, t.websocket = o
    }, function(e, t, r) {
        const n = r(42),
            s = r(8);
        e.exports = function(e) {
            const t = e.xdomain,
                r = e.xscheme,
                i = e.enablesXDR;
            try {
                if ("undefined" != typeof XMLHttpRequest && (!t || n)) return new XMLHttpRequest
            } catch (e) {}
            try {
                if ("undefined" != typeof XDomainRequest && !r && i) return new XDomainRequest
            } catch (e) {}
            if (!t) try {
                return new(s[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
            } catch (e) {}
        }
    }, function(e, t, r) {
        const n = r(14),
            s = r(16),
            i = r(4),
            o = r(25),
            a = r(9)("engine.io-client:polling");
        e.exports = class extends n {
            get name() {
                return "polling"
            }
            doOpen() {
                this.poll()
            }
            pause(e) {
                const t = this;

                function r() {
                    a("paused"), t.readyState = "paused", e()
                }
                if (this.readyState = "pausing", this.polling || !this.writable) {
                    let e = 0;
                    this.polling && (a("we are currently polling - waiting to pause"), e++, this.once("pollComplete", (function() {
                        a("pre-pause polling complete"), --e || r()
                    }))), this.writable || (a("we are currently writing - waiting to pause"), e++, this.once("drain", (function() {
                        a("pre-pause writing complete"), --e || r()
                    })))
                } else r()
            }
            poll() {
                a("polling"), this.polling = !0, this.doPoll(), this.emit("poll")
            }
            onData(e) {
                const t = this;
                a("polling got data %s", e), i.decodePayload(e, this.socket.binaryType).forEach((function(e, r, n) {
                    if ("opening" === t.readyState && "open" === e.type && t.onOpen(), "close" === e.type) return t.onClose(), !1;
                    t.onPacket(e)
                })), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : a('ignoring poll - transport state "%s"', this.readyState))
            }
            doClose() {
                const e = this;

                function t() {
                    a("writing close packet"), e.write([{
                        type: "close"
                    }])
                }
                "open" === this.readyState ? (a("transport open - closing"), t()) : (a("transport not open - deferring close"), this.once("open", t))
            }
            write(e) {
                this.writable = !1, i.encodePayload(e, e => {
                    this.doWrite(e, () => {
                        this.writable = !0, this.emit("drain")
                    })
                })
            }
            uri() {
                let e = this.query || {};
                const t = this.opts.secure ? "https" : "http";
                let r = "";
                return !1 !== this.opts.timestampRequests && (e[this.opts.timestampParam] = o()), this.supportsBinary || e.sid || (e.b64 = 1), e = s.encode(e), this.opts.port && ("https" === t && 443 !== Number(this.opts.port) || "http" === t && 80 !== Number(this.opts.port)) && (r = ":" + this.opts.port), e.length && (e = "?" + e), t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + e
            }
        }
    }, function(e, t) {
        const r = Object.create(null);
        r.open = "0", r.close = "1", r.ping = "2", r.pong = "3", r.message = "4", r.upgrade = "5", r.noop = "6";
        const n = Object.create(null);
        Object.keys(r).forEach(e => {
            n[r[e]] = e
        }), e.exports = {
            PACKET_TYPES: r,
            PACKET_TYPES_REVERSE: n,
            ERROR_PACKET: {
                type: "error",
                data: "parser error"
            }
        }
    }, function(e, t, r) {
        "use strict";
        var n, s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
            i = {},
            o = 0,
            a = 0;

        function c(e) {
            var t = "";
            do {
                t = s[e % 64] + t, e = Math.floor(e / 64)
            } while (e > 0);
            return t
        }

        function d() {
            var e = c(+new Date);
            return e !== n ? (o = 0, n = e) : e + "." + c(o++)
        }
        for (; a < 64; a++) i[s[a]] = a;
        d.encode = c, d.decode = function(e) {
            var t = 0;
            for (a = 0; a < e.length; a++) t = 64 * t + i[e.charAt(a)];
            return t
        }, e.exports = d
    }, function(e, t) {
        e.exports.pick = (e, ...t) => t.reduce((t, r) => (e.hasOwnProperty(r) && (t[r] = e[r]), t), {})
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Socket = void 0;
        const n = r(17),
            s = r(29),
            i = r(30),
            o = r(7)("socket.io-client:socket"),
            a = Object.freeze({
                connect: 1,
                connect_error: 1,
                disconnect: 1,
                disconnecting: 1,
                newListener: 1,
                removeListener: 1
            });
        t.Socket = class extends s {
            constructor(e, t, r) {
                super(), this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open()
            }
            subEvents() {
                if (this.subs) return;
                const e = this.io;
                this.subs = [i.on(e, "open", this.onopen.bind(this)), i.on(e, "packet", this.onpacket.bind(this)), i.on(e, "error", this.onerror.bind(this)), i.on(e, "close", this.onclose.bind(this))]
            }
            get active() {
                return !!this.subs
            }
            connect() {
                return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this
            }
            open() {
                return this.connect()
            }
            send(...e) {
                return e.unshift("message"), this.emit.apply(this, e), this
            }
            emit(e, ...t) {
                if (a.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name');
                t.unshift(e);
                const r = {
                    type: n.PacketType.EVENT,
                    data: t,
                    options: {}
                };
                r.options.compress = !1 !== this.flags.compress, "function" == typeof t[t.length - 1] && (o("emitting packet with ack id %d", this.ids), this.acks[this.ids] = t.pop(), r.id = this.ids++);
                const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
                return !this.flags.volatile || s && this.connected ? this.connected ? this.packet(r) : this.sendBuffer.push(r) : o("discard packet as the transport is not currently writable"), this.flags = {}, this
            }
            packet(e) {
                e.nsp = this.nsp, this.io._packet(e)
            }
            onopen() {
                o("transport is open - connecting"), "function" == typeof this.auth ? this.auth(e => {
                    this.packet({
                        type: n.PacketType.CONNECT,
                        data: e
                    })
                }) : this.packet({
                    type: n.PacketType.CONNECT,
                    data: this.auth
                })
            }
            onerror(e) {
                this.connected || super.emit("connect_error", e)
            }
            onclose(e) {
                o("close (%s)", e), this.connected = !1, this.disconnected = !0, delete this.id, super.emit("disconnect", e)
            }
            onpacket(e) {
                if (e.nsp === this.nsp) switch (e.type) {
                    case n.PacketType.CONNECT:
                        if (e.data && e.data.sid) {
                            const t = e.data.sid;
                            this.onconnect(t)
                        } else super.emit("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                        break;
                    case n.PacketType.EVENT:
                    case n.PacketType.BINARY_EVENT:
                        this.onevent(e);
                        break;
                    case n.PacketType.ACK:
                    case n.PacketType.BINARY_ACK:
                        this.onack(e);
                        break;
                    case n.PacketType.DISCONNECT:
                        this.ondisconnect();
                        break;
                    case n.PacketType.CONNECT_ERROR:
                        const t = new Error(e.data.message);
                        t.data = e.data.data, super.emit("connect_error", t)
                }
            }
            onevent(e) {
                const t = e.data || [];
                o("emitting event %j", t), null != e.id && (o("attaching ack callback to event"), t.push(this.ack(e.id))), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t))
            }
            emitEvent(e) {
                if (this._anyListeners && this._anyListeners.length) {
                    const t = this._anyListeners.slice();
                    for (const r of t) r.apply(this, e)
                }
                super.emit.apply(this, e)
            }
            ack(e) {
                const t = this;
                let r = !1;
                return function(...s) {
                    r || (r = !0, o("sending ack %j", s), t.packet({
                        type: n.PacketType.ACK,
                        id: e,
                        data: s
                    }))
                }
            }
            onack(e) {
                const t = this.acks[e.id];
                "function" == typeof t ? (o("calling ack %s with %j", e.id, e.data), t.apply(this, e.data), delete this.acks[e.id]) : o("bad ack %s", e.id)
            }
            onconnect(e) {
                o("socket connected with id %s", e), this.id = e, this.connected = !0, this.disconnected = !1, super.emit("connect"), this.emitBuffered()
            }
            emitBuffered() {
                this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => this.packet(e)), this.sendBuffer = []
            }
            ondisconnect() {
                o("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect")
            }
            destroy() {
                this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this)
            }
            disconnect() {
                return this.connected && (o("performing disconnect (%s)", this.nsp), this.packet({
                    type: n.PacketType.DISCONNECT
                })), this.destroy(), this.connected && this.onclose("io client disconnect"), this
            }
            close() {
                return this.disconnect()
            }
            compress(e) {
                return this.flags.compress = e, this
            }
            get volatile() {
                return this.flags.volatile = !0, this
            }
            onAny(e) {
                return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this
            }
            prependAny(e) {
                return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this
            }
            offAny(e) {
                if (!this._anyListeners) return this;
                if (e) {
                    const t = this._anyListeners;
                    for (let r = 0; r < t.length; r++)
                        if (e === t[r]) return t.splice(r, 1), this
                } else this._anyListeners = [];
                return this
            }
            listenersAny() {
                return this._anyListeners || []
            }
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.hasBinary = t.isBinary = void 0;
        const n = "function" == typeof ArrayBuffer,
            s = Object.prototype.toString,
            i = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === s.call(Blob),
            o = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === s.call(File);

        function a(e) {
            return n && (e instanceof ArrayBuffer || (e => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer)(e)) || i && e instanceof Blob || o && e instanceof File
        }
        t.isBinary = a, t.hasBinary = function e(t, r) {
            if (!t || "object" != typeof t) return !1;
            if (Array.isArray(t)) {
                for (let r = 0, n = t.length; r < n; r++)
                    if (e(t[r])) return !0;
                return !1
            }
            if (a(t)) return !0;
            if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return e(t.toJSON(), !0);
            for (const r in t)
                if (Object.prototype.hasOwnProperty.call(t, r) && e(t[r])) return !0;
            return !1
        }
    }, function(e, t, r) {
        function n(e) {
            if (e) return function(e) {
                for (var t in n.prototype) e[t] = n.prototype[t];
                return e
            }(e)
        }
        e.exports = n, n.prototype.on = n.prototype.addEventListener = function(e, t) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
        }, n.prototype.once = function(e, t) {
            function r() {
                this.off(e, r), t.apply(this, arguments)
            }
            return r.fn = t, this.on(e, r), this
        }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function(e, t) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var r, n = this._callbacks["$" + e];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + e], this;
            for (var s = 0; s < n.length; s++)
                if ((r = n[s]) === t || r.fn === t) {
                    n.splice(s, 1);
                    break
                }
            return 0 === n.length && delete this._callbacks["$" + e], this
        }, n.prototype.emit = function(e) {
            this._callbacks = this._callbacks || {};
            for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            if (r) {
                n = 0;
                for (var s = (r = r.slice(0)).length; n < s; ++n) r[n].apply(this, t)
            }
            return this
        }, n.prototype.listeners = function(e) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
        }, n.prototype.hasListeners = function(e) {
            return !!this.listeners(e).length
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.on = void 0, t.on = function(e, t, r) {
            return e.on(t, r),
                function() {
                    e.off(t, r)
                }
        }
    }, function(e, t, r) {
        "use strict";
        var n = r(1);

        function s(e, t, r, s, i) {
            var o = n.writeRtpDescription(e.kind, t);
            if (o += n.writeIceParameters(e.iceGatherer.getLocalParameters()), o += n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === r ? "actpass" : i || "active"), o += "a=mid:" + e.mid + "\r\n", e.rtpSender && e.rtpReceiver ? o += "a=sendrecv\r\n" : e.rtpSender ? o += "a=sendonly\r\n" : e.rtpReceiver ? o += "a=recvonly\r\n" : o += "a=inactive\r\n", e.rtpSender) {
                var a = e.rtpSender._initialTrackId || e.rtpSender.track.id;
                e.rtpSender._initialTrackId = a;
                var c = "msid:" + (s ? s.id : "-") + " " + a + "\r\n";
                o += "a=" + c, o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + c, e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + c, o += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + n.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + n.localCName + "\r\n"), o
        }

        function i(e, t) {
            var r = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: []
                },
                n = function(e, t) {
                    e = parseInt(e, 10);
                    for (var r = 0; r < t.length; r++)
                        if (t[r].payloadType === e || t[r].preferredPayloadType === e) return t[r]
                },
                s = function(e, t, r, s) {
                    var i = n(e.parameters.apt, r),
                        o = n(t.parameters.apt, s);
                    return i && o && i.name.toLowerCase() === o.name.toLowerCase()
                };
            return e.codecs.forEach((function(n) {
                for (var i = 0; i < t.codecs.length; i++) {
                    var o = t.codecs[i];
                    if (n.name.toLowerCase() === o.name.toLowerCase() && n.clockRate === o.clockRate) {
                        if ("rtx" === n.name.toLowerCase() && n.parameters && o.parameters.apt && !s(n, o, e.codecs, t.codecs)) continue;
                        (o = JSON.parse(JSON.stringify(o))).numChannels = Math.min(n.numChannels, o.numChannels), r.codecs.push(o), o.rtcpFeedback = o.rtcpFeedback.filter((function(e) {
                            for (var t = 0; t < n.rtcpFeedback.length; t++)
                                if (n.rtcpFeedback[t].type === e.type && n.rtcpFeedback[t].parameter === e.parameter) return !0;
                            return !1
                        }));
                        break
                    }
                }
            })), e.headerExtensions.forEach((function(e) {
                for (var n = 0; n < t.headerExtensions.length; n++) {
                    var s = t.headerExtensions[n];
                    if (e.uri === s.uri) {
                        r.headerExtensions.push(s);
                        break
                    }
                }
            })), r
        }

        function o(e, t, r) {
            return -1 !== {
                offer: {
                    setLocalDescription: ["stable", "have-local-offer"],
                    setRemoteDescription: ["stable", "have-remote-offer"]
                },
                answer: {
                    setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
                    setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
                }
            }[t][e].indexOf(r)
        }

        function a(e, t) {
            var r = e.getRemoteCandidates().find((function(e) {
                return t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type
            }));
            return r || e.addRemoteCandidate(t), !r
        }

        function c(e, t) {
            var r = new Error(t);
            return r.name = e, r.code = {
                NotSupportedError: 9,
                InvalidStateError: 11,
                InvalidAccessError: 15,
                TypeError: void 0,
                OperationError: void 0
            }[e], r
        }
        e.exports = function(e, t) {
            function r(t, r) {
                r.addTrack(t), r.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", {
                    track: t
                }))
            }

            function d(t, r, n, s) {
                var i = new Event("track");
                i.track = r, i.receiver = n, i.transceiver = {
                    receiver: n
                }, i.streams = s, e.setTimeout((function() {
                    t._dispatchEvent("track", i)
                }))
            }
            var l = function(r) {
                var s = this,
                    i = document.createDocumentFragment();
                if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach((function(e) {
                        s[e] = i[e].bind(i)
                    })), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", r = JSON.parse(JSON.stringify(r || {})), this.usingBundle = "max-bundle" === r.bundlePolicy, "negotiate" === r.rtcpMuxPolicy) throw c("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
                switch (r.rtcpMuxPolicy || (r.rtcpMuxPolicy = "require"), r.iceTransportPolicy) {
                    case "all":
                    case "relay":
                        break;
                    default:
                        r.iceTransportPolicy = "all"
                }
                switch (r.bundlePolicy) {
                    case "balanced":
                    case "max-compat":
                    case "max-bundle":
                        break;
                    default:
                        r.bundlePolicy = "balanced"
                }
                if (r.iceServers = function(e, t) {
                        var r = !1;
                        return (e = JSON.parse(JSON.stringify(e))).filter((function(e) {
                            if (e && (e.urls || e.url)) {
                                var n = e.urls || e.url;
                                e.url && e.urls;
                                var s = "string" == typeof n;
                                return s && (n = [n]), n = n.filter((function(e) {
                                    return 0 !== e.indexOf("turn:") || -1 === e.indexOf("transport=udp") || -1 !== e.indexOf("turn:[") || r ? 0 === e.indexOf("stun:") && t >= 14393 && -1 === e.indexOf("?transport=udp") : (r = !0, !0)
                                })), delete e.url, e.urls = s ? n[0] : n, !!n.length
                            }
                        }))
                    }(r.iceServers || [], t), this._iceGatherers = [], r.iceCandidatePoolSize)
                    for (var o = r.iceCandidatePoolSize; o > 0; o--) this._iceGatherers.push(new e.RTCIceGatherer({
                        iceServers: r.iceServers,
                        gatherPolicy: r.iceTransportPolicy
                    }));
                else r.iceCandidatePoolSize = 0;
                this._config = r, this.transceivers = [], this._sdpSessionId = n.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1
            };
            Object.defineProperty(l.prototype, "localDescription", {
                configurable: !0,
                get: function() {
                    return this._localDescription
                }
            }), Object.defineProperty(l.prototype, "remoteDescription", {
                configurable: !0,
                get: function() {
                    return this._remoteDescription
                }
            }), l.prototype.onicecandidate = null, l.prototype.onaddstream = null, l.prototype.ontrack = null, l.prototype.onremovestream = null, l.prototype.onsignalingstatechange = null, l.prototype.oniceconnectionstatechange = null, l.prototype.onconnectionstatechange = null, l.prototype.onicegatheringstatechange = null, l.prototype.onnegotiationneeded = null, l.prototype.ondatachannel = null, l.prototype._dispatchEvent = function(e, t) {
                this._isClosed || (this.dispatchEvent(t), "function" == typeof this["on" + e] && this["on" + e](t))
            }, l.prototype._emitGatheringStateChange = function() {
                var e = new Event("icegatheringstatechange");
                this._dispatchEvent("icegatheringstatechange", e)
            }, l.prototype.getConfiguration = function() {
                return this._config
            }, l.prototype.getLocalStreams = function() {
                return this.localStreams
            }, l.prototype.getRemoteStreams = function() {
                return this.remoteStreams
            }, l.prototype._createTransceiver = function(e, t) {
                var r = this.transceivers.length > 0,
                    n = {
                        track: null,
                        iceGatherer: null,
                        iceTransport: null,
                        dtlsTransport: null,
                        localCapabilities: null,
                        remoteCapabilities: null,
                        rtpSender: null,
                        rtpReceiver: null,
                        kind: e,
                        mid: null,
                        sendEncodingParameters: null,
                        recvEncodingParameters: null,
                        stream: null,
                        associatedRemoteMediaStreams: [],
                        wantReceive: !0
                    };
                if (this.usingBundle && r) n.iceTransport = this.transceivers[0].iceTransport, n.dtlsTransport = this.transceivers[0].dtlsTransport;
                else {
                    var s = this._createIceAndDtlsTransports();
                    n.iceTransport = s.iceTransport, n.dtlsTransport = s.dtlsTransport
                }
                return t || this.transceivers.push(n), n
            }, l.prototype.addTrack = function(t, r) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
                var n;
                if (this.transceivers.find((function(e) {
                        return e.track === t
                    }))) throw c("InvalidAccessError", "Track already exists.");
                for (var s = 0; s < this.transceivers.length; s++) this.transceivers[s].track || this.transceivers[s].kind !== t.kind || (n = this.transceivers[s]);
                return n || (n = this._createTransceiver(t.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(r) && this.localStreams.push(r), n.track = t, n.stream = r, n.rtpSender = new e.RTCRtpSender(t, n.dtlsTransport), n.rtpSender
            }, l.prototype.addStream = function(e) {
                var r = this;
                if (t >= 15025) e.getTracks().forEach((function(t) {
                    r.addTrack(t, e)
                }));
                else {
                    var n = e.clone();
                    e.getTracks().forEach((function(e, t) {
                        var r = n.getTracks()[t];
                        e.addEventListener("enabled", (function(e) {
                            r.enabled = e.enabled
                        }))
                    })), n.getTracks().forEach((function(e) {
                        r.addTrack(e, n)
                    }))
                }
            }, l.prototype.removeTrack = function(t) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
                if (!(t instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
                var r = this.transceivers.find((function(e) {
                    return e.rtpSender === t
                }));
                if (!r) throw c("InvalidAccessError", "Sender was not created by this connection.");
                var n = r.stream;
                r.rtpSender.stop(), r.rtpSender = null, r.track = null, r.stream = null, -1 === this.transceivers.map((function(e) {
                    return e.stream
                })).indexOf(n) && this.localStreams.indexOf(n) > -1 && this.localStreams.splice(this.localStreams.indexOf(n), 1), this._maybeFireNegotiationNeeded()
            }, l.prototype.removeStream = function(e) {
                var t = this;
                e.getTracks().forEach((function(e) {
                    var r = t.getSenders().find((function(t) {
                        return t.track === e
                    }));
                    r && t.removeTrack(r)
                }))
            }, l.prototype.getSenders = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpSender
                })).map((function(e) {
                    return e.rtpSender
                }))
            }, l.prototype.getReceivers = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpReceiver
                })).map((function(e) {
                    return e.rtpReceiver
                }))
            }, l.prototype._createIceGatherer = function(t, r) {
                var n = this;
                if (r && t > 0) return this.transceivers[0].iceGatherer;
                if (this._iceGatherers.length) return this._iceGatherers.shift();
                var s = new e.RTCIceGatherer({
                    iceServers: this._config.iceServers,
                    gatherPolicy: this._config.iceTransportPolicy
                });
                return Object.defineProperty(s, "state", {
                    value: "new",
                    writable: !0
                }), this.transceivers[t].bufferedCandidateEvents = [], this.transceivers[t].bufferCandidates = function(e) {
                    var r = !e.candidate || 0 === Object.keys(e.candidate).length;
                    s.state = r ? "completed" : "gathering", null !== n.transceivers[t].bufferedCandidateEvents && n.transceivers[t].bufferedCandidateEvents.push(e)
                }, s.addEventListener("localcandidate", this.transceivers[t].bufferCandidates), s
            }, l.prototype._gather = function(t, r) {
                var s = this,
                    i = this.transceivers[r].iceGatherer;
                if (!i.onlocalcandidate) {
                    var o = this.transceivers[r].bufferedCandidateEvents;
                    this.transceivers[r].bufferedCandidateEvents = null, i.removeEventListener("localcandidate", this.transceivers[r].bufferCandidates), i.onlocalcandidate = function(e) {
                        if (!(s.usingBundle && r > 0)) {
                            var o = new Event("icecandidate");
                            o.candidate = {
                                sdpMid: t,
                                sdpMLineIndex: r
                            };
                            var a = e.candidate,
                                c = !a || 0 === Object.keys(a).length;
                            if (c) "new" !== i.state && "gathering" !== i.state || (i.state = "completed");
                            else {
                                "new" === i.state && (i.state = "gathering"), a.component = 1, a.ufrag = i.getLocalParameters().usernameFragment;
                                var d = n.writeCandidate(a);
                                o.candidate = Object.assign(o.candidate, n.parseCandidate(d)), o.candidate.candidate = d, o.candidate.toJSON = function() {
                                    return {
                                        candidate: o.candidate.candidate,
                                        sdpMid: o.candidate.sdpMid,
                                        sdpMLineIndex: o.candidate.sdpMLineIndex,
                                        usernameFragment: o.candidate.usernameFragment
                                    }
                                }
                            }
                            var l = n.getMediaSections(s._localDescription.sdp);
                            l[o.candidate.sdpMLineIndex] += c ? "a=end-of-candidates\r\n" : "a=" + o.candidate.candidate + "\r\n", s._localDescription.sdp = n.getDescription(s._localDescription.sdp) + l.join("");
                            var u = s.transceivers.every((function(e) {
                                return e.iceGatherer && "completed" === e.iceGatherer.state
                            }));
                            "gathering" !== s.iceGatheringState && (s.iceGatheringState = "gathering", s._emitGatheringStateChange()), c || s._dispatchEvent("icecandidate", o), u && (s._dispatchEvent("icecandidate", new Event("icecandidate")), s.iceGatheringState = "complete", s._emitGatheringStateChange())
                        }
                    }, e.setTimeout((function() {
                        o.forEach((function(e) {
                            i.onlocalcandidate(e)
                        }))
                    }), 0)
                }
            }, l.prototype._createIceAndDtlsTransports = function() {
                var t = this,
                    r = new e.RTCIceTransport(null);
                r.onicestatechange = function() {
                    t._updateIceConnectionState(), t._updateConnectionState()
                };
                var n = new e.RTCDtlsTransport(r);
                return n.ondtlsstatechange = function() {
                    t._updateConnectionState()
                }, n.onerror = function() {
                    Object.defineProperty(n, "state", {
                        value: "failed",
                        writable: !0
                    }), t._updateConnectionState()
                }, {
                    iceTransport: r,
                    dtlsTransport: n
                }
            }, l.prototype._disposeIceAndDtlsTransports = function(e) {
                var t = this.transceivers[e].iceGatherer;
                t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer);
                var r = this.transceivers[e].iceTransport;
                r && (delete r.onicestatechange, delete this.transceivers[e].iceTransport);
                var n = this.transceivers[e].dtlsTransport;
                n && (delete n.ondtlsstatechange, delete n.onerror, delete this.transceivers[e].dtlsTransport)
            }, l.prototype._transceive = function(e, r, s) {
                var o = i(e.localCapabilities, e.remoteCapabilities);
                r && e.rtpSender && (o.encodings = e.sendEncodingParameters, o.rtcp = {
                    cname: n.localCName,
                    compound: e.rtcpParameters.compound
                }, e.recvEncodingParameters.length && (o.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(o)), s && e.rtpReceiver && o.codecs.length > 0 && ("video" === e.kind && e.recvEncodingParameters && t < 15019 && e.recvEncodingParameters.forEach((function(e) {
                    delete e.rtx
                })), e.recvEncodingParameters.length ? o.encodings = e.recvEncodingParameters : o.encodings = [{}], o.rtcp = {
                    compound: e.rtcpParameters.compound
                }, e.rtcpParameters.cname && (o.rtcp.cname = e.rtcpParameters.cname), e.sendEncodingParameters.length && (o.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(o))
            }, l.prototype.setLocalDescription = function(e) {
                var t, r, s = this;
                if (-1 === ["offer", "answer"].indexOf(e.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + e.type + '"'));
                if (!o("setLocalDescription", e.type, s.signalingState) || s._isClosed) return Promise.reject(c("InvalidStateError", "Can not set local " + e.type + " in state " + s.signalingState));
                if ("offer" === e.type) t = n.splitSections(e.sdp), r = t.shift(), t.forEach((function(e, t) {
                    var r = n.parseRtpParameters(e);
                    s.transceivers[t].localCapabilities = r
                })), s.transceivers.forEach((function(e, t) {
                    s._gather(e.mid, t)
                }));
                else if ("answer" === e.type) {
                    t = n.splitSections(s._remoteDescription.sdp), r = t.shift();
                    var a = n.matchPrefix(r, "a=ice-lite").length > 0;
                    t.forEach((function(e, t) {
                        var o = s.transceivers[t],
                            c = o.iceGatherer,
                            d = o.iceTransport,
                            l = o.dtlsTransport,
                            u = o.localCapabilities,
                            h = o.remoteCapabilities;
                        if (!(n.isRejected(e) && 0 === n.matchPrefix(e, "a=bundle-only").length || o.rejected)) {
                            var p = n.getIceParameters(e, r),
                                f = n.getDtlsParameters(e, r);
                            a && (f.role = "server"), s.usingBundle && 0 !== t || (s._gather(o.mid, t), "new" === d.state && d.start(c, p, a ? "controlling" : "controlled"), "new" === l.state && l.start(f));
                            var m = i(u, h);
                            s._transceive(o, m.codecs.length > 0, !1)
                        }
                    }))
                }
                return s._localDescription = {
                    type: e.type,
                    sdp: e.sdp
                }, "offer" === e.type ? s._updateSignalingState("have-local-offer") : s._updateSignalingState("stable"), Promise.resolve()
            }, l.prototype.setRemoteDescription = function(s) {
                var l = this;
                if (-1 === ["offer", "answer"].indexOf(s.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + s.type + '"'));
                if (!o("setRemoteDescription", s.type, l.signalingState) || l._isClosed) return Promise.reject(c("InvalidStateError", "Can not set remote " + s.type + " in state " + l.signalingState));
                var u = {};
                l.remoteStreams.forEach((function(e) {
                    u[e.id] = e
                }));
                var h = [],
                    p = n.splitSections(s.sdp),
                    f = p.shift(),
                    m = n.matchPrefix(f, "a=ice-lite").length > 0,
                    g = n.matchPrefix(f, "a=group:BUNDLE ").length > 0;
                l.usingBundle = g;
                var v = n.matchPrefix(f, "a=ice-options:")[0];
                return l.canTrickleIceCandidates = !!v && v.substr(14).split(" ").indexOf("trickle") >= 0, p.forEach((function(o, c) {
                    var d = n.splitLines(o),
                        p = n.getKind(o),
                        v = n.isRejected(o) && 0 === n.matchPrefix(o, "a=bundle-only").length,
                        y = d[0].substr(2).split(" ")[2],
                        C = n.getDirection(o, f),
                        b = n.parseMsid(o),
                        S = n.getMid(o) || n.generateIdentifier();
                    if (v || "application" === p && ("DTLS/SCTP" === y || "UDP/DTLS/SCTP" === y)) l.transceivers[c] = {
                        mid: S,
                        kind: p,
                        protocol: y,
                        rejected: !0
                    };
                    else {
                        var P, T, _, R, D, k, E, w, O;
                        !v && l.transceivers[c] && l.transceivers[c].rejected && (l.transceivers[c] = l._createTransceiver(p, !0));
                        var I, N, x = n.parseRtpParameters(o);
                        v || (I = n.getIceParameters(o, f), (N = n.getDtlsParameters(o, f)).role = "client"), E = n.parseRtpEncodingParameters(o);
                        var A = n.parseRtcpParameters(o),
                            B = n.matchPrefix(o, "a=end-of-candidates", f).length > 0,
                            M = n.matchPrefix(o, "a=candidate:").map((function(e) {
                                return n.parseCandidate(e)
                            })).filter((function(e) {
                                return 1 === e.component
                            }));
                        if (("offer" === s.type || "answer" === s.type) && !v && g && c > 0 && l.transceivers[c] && (l._disposeIceAndDtlsTransports(c), l.transceivers[c].iceGatherer = l.transceivers[0].iceGatherer, l.transceivers[c].iceTransport = l.transceivers[0].iceTransport, l.transceivers[c].dtlsTransport = l.transceivers[0].dtlsTransport, l.transceivers[c].rtpSender && l.transceivers[c].rtpSender.setTransport(l.transceivers[0].dtlsTransport), l.transceivers[c].rtpReceiver && l.transceivers[c].rtpReceiver.setTransport(l.transceivers[0].dtlsTransport)), "offer" !== s.type || v) "answer" !== s.type || v || (T = (P = l.transceivers[c]).iceGatherer, _ = P.iceTransport, R = P.dtlsTransport, D = P.rtpReceiver, k = P.sendEncodingParameters, w = P.localCapabilities, l.transceivers[c].recvEncodingParameters = E, l.transceivers[c].remoteCapabilities = x, l.transceivers[c].rtcpParameters = A, M.length && "new" === _.state && (!m && !B || g && 0 !== c ? M.forEach((function(e) {
                            a(P.iceTransport, e)
                        })) : _.setRemoteCandidates(M)), g && 0 !== c || ("new" === _.state && _.start(T, I, "controlling"), "new" === R.state && R.start(N)), !i(P.localCapabilities, P.remoteCapabilities).codecs.filter((function(e) {
                            return "rtx" === e.name.toLowerCase()
                        })).length && P.sendEncodingParameters[0].rtx && delete P.sendEncodingParameters[0].rtx, l._transceive(P, "sendrecv" === C || "recvonly" === C, "sendrecv" === C || "sendonly" === C), !D || "sendrecv" !== C && "sendonly" !== C ? delete P.rtpReceiver : (O = D.track, b ? (u[b.stream] || (u[b.stream] = new e.MediaStream), r(O, u[b.stream]), h.push([O, D, u[b.stream]])) : (u.default || (u.default = new e.MediaStream), r(O, u.default), h.push([O, D, u.default]))));
                        else {
                            (P = l.transceivers[c] || l._createTransceiver(p)).mid = S, P.iceGatherer || (P.iceGatherer = l._createIceGatherer(c, g)), M.length && "new" === P.iceTransport.state && (!B || g && 0 !== c ? M.forEach((function(e) {
                                a(P.iceTransport, e)
                            })) : P.iceTransport.setRemoteCandidates(M)), w = e.RTCRtpReceiver.getCapabilities(p), t < 15019 && (w.codecs = w.codecs.filter((function(e) {
                                return "rtx" !== e.name
                            }))), k = P.sendEncodingParameters || [{
                                ssrc: 1001 * (2 * c + 2)
                            }];
                            var j, L = !1;
                            "sendrecv" === C || "sendonly" === C ? (L = !P.rtpReceiver, D = P.rtpReceiver || new e.RTCRtpReceiver(P.dtlsTransport, p), L && (O = D.track, b && "-" === b.stream || (b ? (u[b.stream] || (u[b.stream] = new e.MediaStream, Object.defineProperty(u[b.stream], "id", {
                                get: function() {
                                    return b.stream
                                }
                            })), Object.defineProperty(O, "id", {
                                get: function() {
                                    return b.track
                                }
                            }), j = u[b.stream]) : (u.default || (u.default = new e.MediaStream), j = u.default)), j && (r(O, j), P.associatedRemoteMediaStreams.push(j)), h.push([O, D, j]))) : P.rtpReceiver && P.rtpReceiver.track && (P.associatedRemoteMediaStreams.forEach((function(t) {
                                var r = t.getTracks().find((function(e) {
                                    return e.id === P.rtpReceiver.track.id
                                }));
                                r && function(t, r) {
                                    r.removeTrack(t), r.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", {
                                        track: t
                                    }))
                                }(r, t)
                            })), P.associatedRemoteMediaStreams = []), P.localCapabilities = w, P.remoteCapabilities = x, P.rtpReceiver = D, P.rtcpParameters = A, P.sendEncodingParameters = k, P.recvEncodingParameters = E, l._transceive(l.transceivers[c], !1, L)
                        }
                    }
                })), void 0 === l._dtlsRole && (l._dtlsRole = "offer" === s.type ? "active" : "passive"), l._remoteDescription = {
                    type: s.type,
                    sdp: s.sdp
                }, "offer" === s.type ? l._updateSignalingState("have-remote-offer") : l._updateSignalingState("stable"), Object.keys(u).forEach((function(t) {
                    var r = u[t];
                    if (r.getTracks().length) {
                        if (-1 === l.remoteStreams.indexOf(r)) {
                            l.remoteStreams.push(r);
                            var n = new Event("addstream");
                            n.stream = r, e.setTimeout((function() {
                                l._dispatchEvent("addstream", n)
                            }))
                        }
                        h.forEach((function(e) {
                            var t = e[0],
                                n = e[1];
                            r.id === e[2].id && d(l, t, n, [r])
                        }))
                    }
                })), h.forEach((function(e) {
                    e[2] || d(l, e[0], e[1], [])
                })), e.setTimeout((function() {
                    l && l.transceivers && l.transceivers.forEach((function(e) {
                        e.iceTransport && "new" === e.iceTransport.state && e.iceTransport.getRemoteCandidates().length > 0 && e.iceTransport.addRemoteCandidate({})
                    }))
                }), 4e3), Promise.resolve()
            }, l.prototype.close = function() {
                this.transceivers.forEach((function(e) {
                    e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop()
                })), this._isClosed = !0, this._updateSignalingState("closed")
            }, l.prototype._updateSignalingState = function(e) {
                this.signalingState = e;
                var t = new Event("signalingstatechange");
                this._dispatchEvent("signalingstatechange", t)
            }, l.prototype._maybeFireNegotiationNeeded = function() {
                var t = this;
                "stable" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, e.setTimeout((function() {
                    if (t.needNegotiation) {
                        t.needNegotiation = !1;
                        var e = new Event("negotiationneeded");
                        t._dispatchEvent("negotiationneeded", e)
                    }
                }), 0))
            }, l.prototype._updateIceConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    checking: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && !e.rejected && t[e.iceTransport.state]++
                    })), e = "new", t.failed > 0 ? e = "failed" : t.checking > 0 ? e = "checking" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 ? e = "connected" : t.completed > 0 && (e = "completed"), e !== this.iceConnectionState) {
                    this.iceConnectionState = e;
                    var r = new Event("iceconnectionstatechange");
                    this._dispatchEvent("iceconnectionstatechange", r)
                }
            }, l.prototype._updateConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    connecting: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && e.dtlsTransport && !e.rejected && (t[e.iceTransport.state]++, t[e.dtlsTransport.state]++)
                    })), t.connected += t.completed, e = "new", t.failed > 0 ? e = "failed" : t.connecting > 0 ? e = "connecting" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 && (e = "connected"), e !== this.connectionState) {
                    this.connectionState = e;
                    var r = new Event("connectionstatechange");
                    this._dispatchEvent("connectionstatechange", r)
                }
            }, l.prototype.createOffer = function() {
                var r = this;
                if (r._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createOffer after close"));
                var i = r.transceivers.filter((function(e) {
                        return "audio" === e.kind
                    })).length,
                    o = r.transceivers.filter((function(e) {
                        return "video" === e.kind
                    })).length,
                    a = arguments[0];
                if (a) {
                    if (a.mandatory || a.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                    void 0 !== a.offerToReceiveAudio && (i = !0 === a.offerToReceiveAudio ? 1 : !1 === a.offerToReceiveAudio ? 0 : a.offerToReceiveAudio), void 0 !== a.offerToReceiveVideo && (o = !0 === a.offerToReceiveVideo ? 1 : !1 === a.offerToReceiveVideo ? 0 : a.offerToReceiveVideo)
                }
                for (r.transceivers.forEach((function(e) {
                        "audio" === e.kind ? --i < 0 && (e.wantReceive = !1) : "video" === e.kind && --o < 0 && (e.wantReceive = !1)
                    })); i > 0 || o > 0;) i > 0 && (r._createTransceiver("audio"), i--), o > 0 && (r._createTransceiver("video"), o--);
                var d = n.writeSessionBoilerplate(r._sdpSessionId, r._sdpSessionVersion++);
                r.transceivers.forEach((function(s, i) {
                    var o = s.track,
                        a = s.kind,
                        c = s.mid || n.generateIdentifier();
                    s.mid = c, s.iceGatherer || (s.iceGatherer = r._createIceGatherer(i, r.usingBundle));
                    var d = e.RTCRtpSender.getCapabilities(a);
                    t < 15019 && (d.codecs = d.codecs.filter((function(e) {
                        return "rtx" !== e.name
                    }))), d.codecs.forEach((function(e) {
                        "H264" === e.name && void 0 === e.parameters["level-asymmetry-allowed"] && (e.parameters["level-asymmetry-allowed"] = "1"), s.remoteCapabilities && s.remoteCapabilities.codecs && s.remoteCapabilities.codecs.forEach((function(t) {
                            e.name.toLowerCase() === t.name.toLowerCase() && e.clockRate === t.clockRate && (e.preferredPayloadType = t.payloadType)
                        }))
                    })), d.headerExtensions.forEach((function(e) {
                        (s.remoteCapabilities && s.remoteCapabilities.headerExtensions || []).forEach((function(t) {
                            e.uri === t.uri && (e.id = t.id)
                        }))
                    }));
                    var l = s.sendEncodingParameters || [{
                        ssrc: 1001 * (2 * i + 1)
                    }];
                    o && t >= 15019 && "video" === a && !l[0].rtx && (l[0].rtx = {
                        ssrc: l[0].ssrc + 1
                    }), s.wantReceive && (s.rtpReceiver = new e.RTCRtpReceiver(s.dtlsTransport, a)), s.localCapabilities = d, s.sendEncodingParameters = l
                })), "max-compat" !== r._config.bundlePolicy && (d += "a=group:BUNDLE " + r.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), d += "a=ice-options:trickle\r\n", r.transceivers.forEach((function(e, t) {
                    d += s(e, e.localCapabilities, "offer", e.stream, r._dtlsRole), d += "a=rtcp-rsize\r\n", !e.iceGatherer || "new" === r.iceGatheringState || 0 !== t && r.usingBundle || (e.iceGatherer.getLocalCandidates().forEach((function(e) {
                        e.component = 1, d += "a=" + n.writeCandidate(e) + "\r\n"
                    })), "completed" === e.iceGatherer.state && (d += "a=end-of-candidates\r\n"))
                }));
                var l = new e.RTCSessionDescription({
                    type: "offer",
                    sdp: d
                });
                return Promise.resolve(l)
            }, l.prototype.createAnswer = function() {
                var r = this;
                if (r._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createAnswer after close"));
                if ("have-remote-offer" !== r.signalingState && "have-local-pranswer" !== r.signalingState) return Promise.reject(c("InvalidStateError", "Can not call createAnswer in signalingState " + r.signalingState));
                var o = n.writeSessionBoilerplate(r._sdpSessionId, r._sdpSessionVersion++);
                r.usingBundle && (o += "a=group:BUNDLE " + r.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), o += "a=ice-options:trickle\r\n";
                var a = n.getMediaSections(r._remoteDescription.sdp).length;
                r.transceivers.forEach((function(e, n) {
                    if (!(n + 1 > a)) {
                        if (e.rejected) return "application" === e.kind ? "DTLS/SCTP" === e.protocol ? o += "m=application 0 DTLS/SCTP 5000\r\n" : o += "m=application 0 " + e.protocol + " webrtc-datachannel\r\n" : "audio" === e.kind ? o += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : "video" === e.kind && (o += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void(o += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e.mid + "\r\n");
                        var c;
                        e.stream && ("audio" === e.kind ? c = e.stream.getAudioTracks()[0] : "video" === e.kind && (c = e.stream.getVideoTracks()[0]), c && t >= 15019 && "video" === e.kind && !e.sendEncodingParameters[0].rtx && (e.sendEncodingParameters[0].rtx = {
                            ssrc: e.sendEncodingParameters[0].ssrc + 1
                        }));
                        var d = i(e.localCapabilities, e.remoteCapabilities);
                        !d.codecs.filter((function(e) {
                            return "rtx" === e.name.toLowerCase()
                        })).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, o += s(e, d, "answer", e.stream, r._dtlsRole), e.rtcpParameters && e.rtcpParameters.reducedSize && (o += "a=rtcp-rsize\r\n")
                    }
                }));
                var d = new e.RTCSessionDescription({
                    type: "answer",
                    sdp: o
                });
                return Promise.resolve(d)
            }, l.prototype.addIceCandidate = function(e) {
                var t, r = this;
                return e && void 0 === e.sdpMLineIndex && !e.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise((function(s, i) {
                    if (!r._remoteDescription) return i(c("InvalidStateError", "Can not add ICE candidate without a remote description"));
                    if (e && "" !== e.candidate) {
                        var o = e.sdpMLineIndex;
                        if (e.sdpMid)
                            for (var d = 0; d < r.transceivers.length; d++)
                                if (r.transceivers[d].mid === e.sdpMid) {
                                    o = d;
                                    break
                                }
                        var l = r.transceivers[o];
                        if (!l) return i(c("OperationError", "Can not add ICE candidate"));
                        if (l.rejected) return s();
                        var u = Object.keys(e.candidate).length > 0 ? n.parseCandidate(e.candidate) : {};
                        if ("tcp" === u.protocol && (0 === u.port || 9 === u.port)) return s();
                        if (u.component && 1 !== u.component) return s();
                        if ((0 === o || o > 0 && l.iceTransport !== r.transceivers[0].iceTransport) && !a(l.iceTransport, u)) return i(c("OperationError", "Can not add ICE candidate"));
                        var h = e.candidate.trim();
                        0 === h.indexOf("a=") && (h = h.substr(2)), (t = n.getMediaSections(r._remoteDescription.sdp))[o] += "a=" + (u.type ? h : "end-of-candidates") + "\r\n", r._remoteDescription.sdp = n.getDescription(r._remoteDescription.sdp) + t.join("")
                    } else
                        for (var p = 0; p < r.transceivers.length && (r.transceivers[p].rejected || (r.transceivers[p].iceTransport.addRemoteCandidate({}), (t = n.getMediaSections(r._remoteDescription.sdp))[p] += "a=end-of-candidates\r\n", r._remoteDescription.sdp = n.getDescription(r._remoteDescription.sdp) + t.join(""), !r.usingBundle)); p++);
                    s()
                }))
            }, l.prototype.getStats = function(t) {
                if (t && t instanceof e.MediaStreamTrack) {
                    var r = null;
                    if (this.transceivers.forEach((function(e) {
                            e.rtpSender && e.rtpSender.track === t ? r = e.rtpSender : e.rtpReceiver && e.rtpReceiver.track === t && (r = e.rtpReceiver)
                        })), !r) throw c("InvalidAccessError", "Invalid selector.");
                    return r.getStats()
                }
                var n = [];
                return this.transceivers.forEach((function(e) {
                    ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach((function(t) {
                        e[t] && n.push(e[t].getStats())
                    }))
                })), Promise.all(n).then((function(e) {
                    var t = new Map;
                    return e.forEach((function(e) {
                        e.forEach((function(e) {
                            t.set(e.id, e)
                        }))
                    })), t
                }))
            }, ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach((function(t) {
                var r = e[t];
                if (r && r.prototype && r.prototype.getStats) {
                    var n = r.prototype.getStats;
                    r.prototype.getStats = function() {
                        return n.apply(this).then((function(e) {
                            var t = new Map;
                            return Object.keys(e).forEach((function(r) {
                                var n;
                                e[r].type = {
                                    inboundrtp: "inbound-rtp",
                                    outboundrtp: "outbound-rtp",
                                    candidatepair: "candidate-pair",
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                }[(n = e[r]).type] || n.type, t.set(r, e[r])
                            })), t
                        }))
                    }
                }
            }));
            var u = ["createOffer", "createAnswer"];
            return u.forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[0] || "function" == typeof e[1] ? t.apply(this, [arguments[2]]).then((function(t) {
                        "function" == typeof e[0] && e[0].apply(null, [t])
                    }), (function(t) {
                        "function" == typeof e[1] && e[1].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), (u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] || "function" == typeof e[2] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    }), (function(t) {
                        "function" == typeof e[2] && e[2].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), ["getStats"].forEach((function(e) {
                var t = l.prototype[e];
                l.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    })) : t.apply(this, arguments)
                }
            })), l
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0);
        r(66), r(65);
        const s = n.__importDefault(r(33)),
            i = n.__importDefault(r(11)),
            o = n.__importDefault(r(5)),
            a = n.__importDefault(r(12)),
            c = n.__importDefault(r(2)),
            d = n.__importDefault(r(6)),
            l = n.__importStar(r(3));
        class u {
            constructor(e) {
                this.enterReportTimer = 0, this.saveDataBuvidSwitch = !1, this.disableSaveDataByDB = !1, this.disableGetData = !1, this.saveAndGetDataSwitch = !1, this.trackerVersion = "", this.init(e)
            }
            get version() {
                return "bp-nc-sdk " + o.default.getInstance().version
            }
            get saveDataEnabled() {
                return this.saveAndGetDataSwitch && this.saveDataBuvidSwitch && !this.disableSaveDataByDB
            }
            get getDataEnabled() {
                return this.saveAndGetDataSwitch && !this.disableGetData
            }
            init(e) {
                this.config = {
                    aid: 0,
                    cid: 0,
                    bvid: ""
                }, e && (this.config.aid = Math.floor(e.aid), this.config.cid = Math.floor(e.cid), this.config.bvid = e.bvid ? "" + e.bvid : "", e.buvid ? this.config.buvid = "" + e.buvid : this.config.buvid = i.default.getCookie("buvid3"), !0 === e.isAdmin && (this.config.isAdmin = !0), e.debugKey && (this.config.debugKey = "" + e.debugKey)), this.state = {}, l.default.getInstance().log(`init -- version: ${o.default.getInstance().version}, isSupportNC: ${i.default.isSupportP2P()}`), this.eventBus = a.default.getInstance(), i.default.isSupportP2P() && (this.main = new s.default(this)), this.enterReportTimer = window.setTimeout(() => {
                    let e = {
                        type: d.default.TRACK_TYPE.ENTER,
                        version: o.default.getInstance().version,
                        isSupportP2P: i.default.isSupportP2P()
                    };
                    this.trigger(c.default.TRACK, e)
                })
            }
            updateConfig(e) {
                e && (this.config = {
                    aid: 0,
                    cid: 0,
                    bvid: ""
                }, this.config.aid = Math.floor(e.aid), this.config.cid = Math.floor(e.cid), this.config.bvid = e.bvid ? "" + e.bvid : "", e.buvid && (this.config.buvid = "" + e.buvid), !0 === e.isAdmin && (this.config.isAdmin = !0), e.debugKey && (this.config.debugKey = "" + e.debugKey))
            }
            quit() {
                let e = {
                    type: d.default.TRACK_TYPE.QUIT,
                    version: o.default.getInstance().version
                };
                this.state.getData && (e.getData = this.state.getData), this.state.rtcStatistic && (e.rtcStatistic = this.state.rtcStatistic), this.state.dbStatistic && (e.dbStatistic = this.state.dbStatistic), this.trigger(c.default.TRACK, e)
            }
            destroy() {
                l.default.getInstance().log("destroy"), window.clearTimeout(this.enterReportTimer), this.main && (this.main.destroy(), this.main = null), this.eventBus && (this.eventBus.destroy(), this.eventBus = null), this.saveAndGetDataSwitch = !1, this.saveDataBuvidSwitch = !1, this.disableSaveDataByDB = !1, l.default.getInstance().reset(), this.state = {}
            }
            getData(e) {
                if (i.default.isSupportP2P() && this.main && e && this.getDataEnabled) {
                    let t = `\n            ----\n            getData -- url: ${e.url}, range: ${e.range}`;
                    return l.default.getInstance().log(t), e.startTime = Date.now(), this.main.getData(e, !0)
                }
                return Promise.reject({
                    code: -1,
                    msg: "basic error"
                })
            }
            getDBAllResource() {
                return this.main ? this.main.getDBAllResource() : Promise.reject({
                    code: -1,
                    msg: "no main class"
                })
            }
            saveData(e) {
                var t;
                if (i.default.isSupportP2P() && this.main && e && this.saveDataEnabled) {
                    let r = `saveData -- url: ${e.url}, range: ${e.range}, totalSize: ${e.totalSize}, `;
                    r += "dataSize: " + (null === (t = e.data) || void 0 === t ? void 0 : t.byteLength), l.default.getInstance().log(r), this.main.saveData(e)
                }
            }
            abortGetData(e) {
                i.default.isSupportP2P() && this.main && e && "string" == typeof e && this.main.abortGetData(e)
            }
            getToken() {
                return i.default.randomString(16)
            }
            allowDPGetDataByNC(e) {
                if (!this.getDataEnabled) return !1;
                if (!e) return !1;
                const t = +e.rangeStart,
                    r = Math.floor(e.qn),
                    n = +e.bufferRemaining;
                return !(isNaN(t) || t < 100 || isNaN(r) || r <= 0 || !(r > 3e4 && r <= 30080 || r > 30200 && r <= 30280) || isNaN(n) || n < 12)
            }
            getLogHistory(e = l.LOG_LEVEL.INFO) {
                return l.default.getInstance().getHistory(e)
            }
            one(e, t) {
                var r;
                null === (r = this.eventBus) || void 0 === r || r.one(e, t)
            }
            on(e, t) {
                var r;
                null === (r = this.eventBus) || void 0 === r || r.on(e, t)
            }
            off(e, t) {
                var r;
                null === (r = this.eventBus) || void 0 === r || r.off(e, t)
            }
            trigger(e, t) {
                var r;
                null === (r = this.eventBus) || void 0 === r || r.trigger(e, t)
            }
        }
        u.LOG_LEVEL = l.LOG_LEVEL, u.BPP2PEvent = c.default, u.isSupport = i.default.isSupportP2P, t.default = u
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0),
            s = n.__importDefault(r(10)),
            i = n.__importDefault(r(11)),
            o = n.__importDefault(r(34)),
            a = n.__importDefault(r(5)),
            c = n.__importDefault(r(12)),
            d = n.__importDefault(r(2)),
            l = n.__importDefault(r(6)),
            u = n.__importDefault(r(3)),
            h = n.__importDefault(r(35)),
            p = n.__importDefault(r(64));
        class f {
            constructor(e) {
                this.onceSaveDataSizeMax = 52428800, this.needSaveDataSizeMax = 157286400, this.needSaveDataNumMax = 4, this.isReportedSaveData = !1, this.refreshTimeout = 5e4, this.getDataFromP2PTimeout = 5e3, this.getDataFromDBTimeout = 1e3, this.stateGetData = {}, this.changePeerTypesCount = {}, this.changePeerContinuous = 3, this.changePeerTotalCountLimit = 6, this.sdk = e, this.peers = {}, this.peerRTCControllers = {}, this.needSaveResources = {}, this.webRTCControllers = [], this.useP2PGetDataObj = {}, this.useDBGetDataObjArr = [], this.sdk.state.getData || (this.sdk.state.getData = {}), this.stateGetData = this.sdk.state.getData, this.socketController = new h.default(this.sdk), this.socketController.on(d.default.SOCKET_MESSAGE, this.onSocketMessage), this.dbController = new o.default(this.sdk, this.socketController)
            }
            onSocketMessage(e) {
                if (e && e.fromSocketID)
                    if ("offer" === e.type) {
                        if (!e.data) return;
                        const t = new p.default(this.sdk, this.socketController, e.fromSocketID, !1, Boolean(e.isSameIP));
                        t.on(d.default.WEBRTC_ANSWER_TIMEOUT, this.onWebRTCAnswerTimeout), t.createAnswer(e.data), this.webRTCControllers.push(t), this.webRTCControllers.length > 1 && u.default.getInstance().warn(`answer webRTCControllers more than 1 -- length: ${this.webRTCControllers.length}, fromSocketID: ${e.fromSocketID}`)
                    } else "released" === e.type && this.releasedBySocket(e.fromSocketID)
            }
            onWebRTCAnswerTimeout(e) {
                this.releasedBySocket(e)
            }
            onWebRTCChannelClose(e) {
                this.releaseCurrentPeer(e)
            }
            getDBAllResource() {
                return this.dbController ? this.dbController.getDBAllResource() : Promise.reject({
                    code: -1,
                    msg: "no dbController"
                })
            }
            destroy() {
                this.isReportedSaveData = !1, this.needSaveResources = {}, this.stateGetData = {}, this.dbController && (this.dbController.destroy(), this.dbController = null), this.socketController && (this.socketController.off(d.default.SOCKET_MESSAGE), this.socketController.destroy(), this.socketController = null), this.refreshTimer && (clearTimeout(this.refreshTimer), this.refreshTimer = null);
                for (let e = 0; e < this.webRTCControllers.length; e++) {
                    let t = this.webRTCControllers[e];
                    t && t.destroy()
                }
                this.webRTCControllers = [];
                for (const e in this.useP2PGetDataObj)
                    for (let t = 0; t < this.useP2PGetDataObj[e].length; t++) this.clearGetDataObj(this.useP2PGetDataObj[e][t], !1, !0);
                this.useP2PGetDataObj = {};
                for (let e = 0; e < this.useDBGetDataObjArr.length; e++) this.clearGetDataObj(this.useDBGetDataObjArr[e], !1, !0);
                this.useDBGetDataObjArr = []
            }
            saveData(e) {
                var t;
                if (!this.isReportedSaveData) {
                    this.isReportedSaveData = !0;
                    let t = {
                        type: l.default.TRACK_TYPE.SAVE_DATA,
                        version: a.default.getInstance().version,
                        url: e.url,
                        range: e.range,
                        resourceTotalSize: e.totalSize
                    };
                    c.default.getInstance().trigger(d.default.TRACK, t)
                }
                let r = this.handleDataParam("save", e);
                if (!r) return;
                if (r.data.byteLength > this.onceSaveDataSizeMax) return void u.default.getInstance().warn("more than onceSaveDataSizeMax -- dataSize: " + r.data.byteLength);
                let n = 0;
                for (let e in this.needSaveResources) this.needSaveResources[e] && this.needSaveResources[e].blockNum && (n += this.needSaveResources[e].blockNum);
                if (1024 * n * 1024 > this.needSaveDataSizeMax) return void u.default.getInstance().warn("more than needSaveDataSizeMax -- needSaveBlockNum: " + n);
                this.blockData(r), this.needSaveResources[r.path].updateTime = (new Date).getTime();
                let s = 0,
                    i = "";
                for (let e in this.needSaveResources) this.needSaveResources[e] ? (s++, i ? this.needSaveResources[e].updateTime < this.needSaveResources[i].updateTime && (i = e) : i = e) : delete this.needSaveResources[e];
                i && s > this.needSaveDataNumMax && (this.needSaveResources[i] = null, delete this.needSaveResources[i]);
                let o = !1;
                for (let e in this.needSaveResources)
                    if (this.needSaveResources[e] && this.needSaveResources[e].blockNum) {
                        o = !0;
                        break
                    }
                o && (null === (t = this.dbController) || void 0 === t || t.saveResource(this.needSaveResources))
            }
            abortGetData(e) {
                for (const t in this.useP2PGetDataObj)
                    for (let r = 0; r < this.useP2PGetDataObj[t].length; r++) {
                        const n = this.useP2PGetDataObj[t][r];
                        if (n && n.token && n.token === e) {
                            let e = !1;
                            0 === r && (e = !0), this.removeGetDataObj(n, e);
                            break
                        }
                    }
            }
            getData(e, t = !1) {
                let r = this.handleDataParam("get", e);
                if (!r) return Promise.reject({
                    code: -1,
                    msg: "data param invalid"
                });
                let n = {
                        useP2P: t,
                        token: e.token,
                        dataParam: e,
                        internalParam: r
                    },
                    s = this.getDataFromDBTimeout;
                n.useP2P && (this.stateGetData.useP2P = this.stateGetData.useP2P ? this.stateGetData.useP2P + 1 : 1, s = this.getDataFromP2PTimeout);
                const {
                    path: i
                } = r;
                let o;
                return n.timer = window.setTimeout(() => {
                    var e, t, r, s, o, a, c;
                    if (n.timer) {
                        let d;
                        window.clearTimeout(n.timer), n.timer = 0;
                        let l, u = 0,
                            h = "";
                        (null === (e = this.peerRTCControllers[i]) || void 0 === e ? void 0 : e.getReceivedU8Buffer()) && (d = this.peerRTCControllers[i].getReceivedU8Buffer().buffer, u = this.peerRTCControllers[i].getReceivedDataByte()), (null === (t = this.peerRTCControllers[i]) || void 0 === t ? void 0 : t.dataChannelState) && (l = this.peerRTCControllers[i].dataChannelState), (null === (r = this.peerRTCControllers[i]) || void 0 === r ? void 0 : r.cPeerSocketID) && (h = this.peerRTCControllers[i].cPeerSocketID);
                        const p = {
                            range: (null === (s = n.internalParam) || void 0 === s ? void 0 : s.rangeStart) + "-" + (null === (o = n.internalParam) || void 0 === o ? void 0 : o.rangeEnd),
                            from: 0,
                            path: null === (a = n.internalParam) || void 0 === a ? void 0 : a.path,
                            getDataTime: Date.now() - (null === (c = n.internalParam) || void 0 === c ? void 0 : c.startTime),
                            data: d,
                            gotDataByte: u,
                            rtcDataChannelState: l,
                            cPeerSID: h
                        };
                        n.useP2P && ("open" === p.rtcDataChannelState ? p.gotDataByte ? this.stateGetData.useP2PTimeoutFailBySpeed = ++this.stateGetData.useP2PTimeoutFailBySpeed || 1 : this.stateGetData.useP2PTimeoutFailByBlobLock = ++this.stateGetData.useP2PTimeoutFailByBlobLock || 1 : this.stateGetData.useP2PTimeoutFail = ++this.stateGetData.useP2PTimeoutFail || 1), n.onReject && n.onReject({
                            code: -1,
                            msg: "getData timeout",
                            responseData: p
                        }), this.removeGetDataObj(n, !0)
                    }
                }, s), n.promise = new Promise((e, t) => {
                    n.onResolve = e, n.onReject = t
                }), o = n.useP2P ? this.useP2PGetDataObj[i] || [] : this.useDBGetDataObjArr, o.push(n), this.useP2PGetDataObj[i] = o, o.length > 1 || this.internalGetData(o[0]), n.promise
            }
            internalGetData(e) {
                var t, r, s, i, o, c, u, h, f;
                return n.__awaiter(this, void 0, void 0, (function*() {
                    if (e.useP2P) {
                        const n = {
                                start: Math.floor(e.internalParam.rangeStart / a.default.BLOCK_SIZE),
                                end: Math.floor(e.internalParam.rangeEnd / a.default.BLOCK_SIZE)
                            },
                            {
                                path: f,
                                url: m
                            } = e.internalParam;
                        let g;
                        if (!this.peers[f]) try {
                            g = yield this.socketController.getPeerInfo(f, n, m), this.peers[f] = g.peers[0]
                        } catch (n) {
                            if (!e.timer) return;
                            const o = {
                                range: (null === (t = e.internalParam) || void 0 === t ? void 0 : t.rangeStart) + "-" + (null === (r = e.internalParam) || void 0 === r ? void 0 : r.rangeEnd),
                                from: 0,
                                path: null === (s = e.internalParam) || void 0 === s ? void 0 : s.path,
                                getDataTime: Date.now() - (null === (i = e.internalParam) || void 0 === i ? void 0 : i.startTime),
                                data: void 0,
                                gotDataByte: 0,
                                cPeerSID: ""
                            };
                            let a = `no valid peer, get ${f} peerInfo error`;
                            (null == n ? void 0 : n.msg) && (a = "" + n.msg), e.onReject && e.onReject({
                                code: -1,
                                msg: a,
                                responseData: o
                            }), this.removeGetDataObj(e, !0), this.stateGetData.useP2PNoPeerFailByError = this.stateGetData.useP2PNoPeerFailByError ? this.stateGetData.useP2PNoPeerFailByError + 1 : 1
                        }
                        if (!e.timer) return void(this.peers[f] && this.releaseCurrentPeer(f));
                        if (clearTimeout(this.refreshTimer), this.refreshTimer = setTimeout(() => {
                                e.onReject && e.onReject({
                                    code: -1,
                                    msg: `current ${f} peer lose`
                                }), this.removeGetDataObj(e, !1)
                            }, this.refreshTimeout), this.socketController)
                            if (this.peers[f]) try {
                                this.peerRTCControllers[f] || (this.peerRTCControllers[f] = new p.default(this.sdk, this.socketController, this.peers[f].id, !0, Boolean(this.peers[f].isSameIP), f), this.peerRTCControllers[f].createOffer(), this.peerRTCControllers[f].on(d.default.WEBRTC_CHANNEL_CLOSE, this.onWebRTCChannelClose));
                                const t = yield this.peerRTCControllers[f].getData(e.dataParam);
                                if (!e.timer) return;
                                e.onResolve && e.onResolve(t), this.removeGetDataObj(e, !0, !1), this.stateGetData.useP2PSuccess = this.stateGetData.useP2PSuccess ? this.stateGetData.useP2PSuccess + 1 : 1
                            } catch (t) {
                                if (!e.timer) return;
                                e.onReject && e.onReject(t), this.removeGetDataObj(e, !0);
                                const r = null == t ? void 0 : t.code;
                                r === l.default.RESPONSE_CODE.FILE_READER_ERROR ? this.stateGetData.useP2PFileReaderError = ++this.stateGetData.useP2PFileReaderError || 1 : r === l.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT ? this.stateGetData.useP2PWebRTCOpenTimeout = ++this.stateGetData.useP2PWebRTCOpenTimeout || 1 : r === l.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_LDP ? this.stateGetData.useP2PWebRTCOpenTimeoutByNoLDP = ++this.stateGetData.useP2PWebRTCOpenTimeoutByNoLDP || 1 : r === l.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_RDP ? this.stateGetData.useP2PWebRTCOpenTimeoutByNoRDP = ++this.stateGetData.useP2PWebRTCOpenTimeoutByNoRDP || 1 : r === l.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_RC ? this.stateGetData.useP2PWebRTCOpenTimeoutByNoRC = ++this.stateGetData.useP2PWebRTCOpenTimeoutByNoRC || 1 : r === l.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_ACS ? this.stateGetData.useP2PWebRTCOpenTimeoutByNoACS = ++this.stateGetData.useP2PWebRTCOpenTimeoutByNoACS || 1 : this.stateGetData.useP2PWebRTCFail = ++this.stateGetData.useP2PWebRTCFail || 1
                            } else {
                                const t = {
                                    range: (null === (o = e.internalParam) || void 0 === o ? void 0 : o.rangeStart) + "-" + (null === (c = e.internalParam) || void 0 === c ? void 0 : c.rangeEnd),
                                    from: 0,
                                    path: null === (u = e.internalParam) || void 0 === u ? void 0 : u.path,
                                    getDataTime: Date.now() - (null === (h = e.internalParam) || void 0 === h ? void 0 : h.startTime),
                                    data: void 0,
                                    gotDataByte: 0,
                                    cPeerSID: ""
                                };
                                let r = `no valid peer, get ${f} peerInfo error`;
                                (null == g ? void 0 : g.msg) && (r = "" + g.msg), e.onReject && e.onReject({
                                    code: -1,
                                    msg: r,
                                    responseData: t
                                }), this.removeGetDataObj(e, !0), -2001 === (null == g ? void 0 : g.code) ? this.stateGetData.useP2PNoPeerFailByLR = this.stateGetData.useP2PNoPeerFailByLR ? this.stateGetData.useP2PNoPeerFailByLR + 1 : 1 : -2002 === (null == g ? void 0 : g.code) ? this.stateGetData.useP2PNoPeerFailByL = this.stateGetData.useP2PNoPeerFailByL ? this.stateGetData.useP2PNoPeerFailByL + 1 : 1 : this.stateGetData.useP2PNoPeerFail = this.stateGetData.useP2PNoPeerFail ? this.stateGetData.useP2PNoPeerFail + 1 : 1
                            } else e.onReject && e.onReject({
                                code: -1,
                                msg: "no socketController"
                            }), this.removeGetDataObj(e, !0), this.stateGetData.useP2PNoSCFail = this.stateGetData.useP2PNoSCFail ? this.stateGetData.useP2PNoSCFail + 1 : 1
                    } else null === (f = this.dbController) || void 0 === f || f.getResource(e.internalParam).then(t => {
                        e.timer && (e.onResolve && e.onResolve(t), this.removeGetDataObj(e, !0))
                    }, t => {
                        e.timer && (e.onReject && e.onReject(t), this.removeGetDataObj(e, !0))
                    })
                }))
            }
            clearGetDataObj(e, t = !0, r = !1) {
                var n;
                if (!e) return;
                e.timer && (window.clearTimeout(e.timer), e.timer = 0), e.onResolve = null, e.onReject = null, e.promise = null;
                const {
                    path: s
                } = e.internalParam;
                this.changePeerTypesCount[s] || (this.changePeerTypesCount[s] = {}), t ? (this.changePeerTypesCount[s].continuous = ++this.changePeerTypesCount[s].continuous || 1, this.changePeerTypesCount[s].total = ++this.changePeerTypesCount[s].total || 1) : this.changePeerTypesCount[s].continuous = 0, ("open" !== (null === (n = this.peerRTCControllers[s]) || void 0 === n ? void 0 : n.dataChannelState) || this.changePeerTypesCount[s].continuous > this.changePeerContinuous || this.changePeerTypesCount[s].total > this.changePeerTotalCountLimit || r) && this.releaseCurrentPeer(s)
            }
            releaseCurrentPeer(e) {
                var t, r, n, s;
                null === (t = this.peerRTCControllers[e]) || void 0 === t || t.off(d.default.WEBRTC_CHANNEL_CLOSE), null === (r = this.peerRTCControllers[e]) || void 0 === r || r.destroy(), (null === (n = this.peers[e]) || void 0 === n ? void 0 : n.id) && (null === (s = this.socketController) || void 0 === s || s.releasePeerInfo(this.peers[e].id)), delete this.peers[e], delete this.peerRTCControllers[e], delete this.changePeerTypesCount[e]
            }
            removeGetDataObj(e, t = !1, r = !0, n = !1) {
                if (!e) return;
                let s;
                this.clearGetDataObj(e, r, n), s = e.useP2P ? this.useP2PGetDataObj[e.internalParam.path] || [] : this.useDBGetDataObjArr;
                let i = -1;
                for (let t = 0; t < s.length; t++)
                    if (s[t] === e) {
                        s.splice(t, 1), i = t;
                        break
                    }
                0 !== i && t && u.default.getInstance().warn("removeGetDataObj is not first and need getNextData -- removeI: ' + " + i), 0 === i && t && s.length && this.internalGetData(s[0])
            }
            releasedBySocket(e) {
                var t;
                if (e)
                    for (let r = 0; r < this.webRTCControllers.length; r++) {
                        let n = this.webRTCControllers[r];
                        if (n && n.cPeerSocketID === e) {
                            if (null === (t = n.getGetDataParam()) || void 0 === t ? void 0 : t.token)
                                for (let e = 0; e < this.useDBGetDataObjArr.length; e++)
                                    if (this.useDBGetDataObjArr[e].token === n.getGetDataParam().token) {
                                        let t = !1;
                                        0 === e && (t = !0), this.removeGetDataObj(this.useDBGetDataObjArr[e], t);
                                        break
                                    }
                            n.off(d.default.WEBRTC_ANSWER_TIMEOUT), n.destroy(), this.webRTCControllers.splice(r, 1);
                            break
                        }
                    }
            }
            handleDataParam(e, t) {
                if (!t || !t.url) return null;
                let r = "" + t.url,
                    n = r.split("?")[0].split("/"),
                    s = n[n.length - 1];
                if (!s) return null;
                let i = ("" + t.range).split("-");
                if (i.length < 2) return null;
                let o = parseInt(i[0], 10),
                    a = parseInt(i[1], 10);
                if (isNaN(o) || isNaN(a) || o < 0 || a < o) return null;
                if (!t.token || "string" != typeof t.token) return null;
                if (t.totalSize && a >= t.totalSize) return null;
                let c = t.data;
                return "save" !== e || c && c.byteLength && c.byteLength === a - o + 1 ? {
                    type: e,
                    url: r,
                    path: s,
                    rangeStart: o,
                    rangeEnd: a,
                    token: t.token,
                    startTime: t.startTime,
                    data: c,
                    totalSize: t.totalSize
                } : null
            }
            blockData(e) {
                let t = e.path,
                    r = e.rangeStart,
                    n = e.rangeEnd,
                    s = e.data;
                this.needSaveResources[t] || (this.needSaveResources[t] = {
                    id: t,
                    blocks: [],
                    blockNum: 0,
                    priority: -1,
                    updateTime: 0
                });
                let o = this.needSaveResources[t],
                    c = o.waitConcatData;
                c && c.rangeEnd === r - 1 && (r = c.rangeStart, s = i.default.concatArrayBuffer(c.data, s), o.waitConcatData = c = null), e.totalSize && !o.totalSize && (o.totalSize = e.totalSize), o.blocks || (o.blocks = []);
                const d = Math.ceil(r / a.default.BLOCK_SIZE),
                    l = Math.floor(n / a.default.BLOCK_SIZE);
                u.default.getInstance().log(`blockData -- startIndex: ${d}, endIndex: ${l}`);
                for (let e = d; e < l; e++) o.blocks[e] || (o.blocks[e] = {
                    id: e,
                    data: new Blob([s.slice(e * a.default.BLOCK_SIZE - r, (e + 1) * a.default.BLOCK_SIZE - r)], {
                        type: "multipart/byteranges"
                    }),
                    priority: -1,
                    isLast: !1
                }, o.blockNum++);
                if (n >= l * a.default.BLOCK_SIZE && !o.blocks[l]) {
                    let i = r > l * a.default.BLOCK_SIZE ? r : l * a.default.BLOCK_SIZE;
                    e.totalSize && n === e.totalSize - 1 && i === l * a.default.BLOCK_SIZE || n === (l + 1) * a.default.BLOCK_SIZE - 1 && i === l * a.default.BLOCK_SIZE ? (o.blocks[l] = {
                        id: l,
                        data: new Blob([s.slice(i - r, n + 1 - r)], {
                            type: "multipart/byteranges"
                        }),
                        priority: -1,
                        isLast: !1
                    }, e.totalSize && n === e.totalSize - 1 && (o.blocks[l].isLast = !0), o.blockNum++) : (o.waitConcatData = {
                        type: e.type,
                        url: e.url,
                        path: t,
                        rangeStart: i,
                        rangeEnd: n,
                        token: e.token,
                        data: s.slice(i - r, n + 1 - r)
                    }, e.totalSize && (o.waitConcatData.totalSize = e.totalSize))
                }
            }
            getNodeVar(e, t) {
                this.socketController && this.socketController.getNodeVar(e, t)
            }
            hotPushToTracker(e, t) {
                var r;
                e && t ? null === (r = this.socketController) || void 0 === r || r.hotPushToTracker(e, t) : u.default.getInstance().log("hotPushToTracker -- param invalid")
            }
        }
        n.__decorate([s.default], f.prototype, "onSocketMessage", null), n.__decorate([s.default], f.prototype, "onWebRTCAnswerTimeout", null), n.__decorate([s.default], f.prototype, "onWebRTCChannelClose", null), t.default = f
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0),
            s = n.__importDefault(r(10)),
            i = n.__importDefault(r(5)),
            o = n.__importDefault(r(12)),
            a = n.__importDefault(r(2)),
            c = n.__importDefault(r(6)),
            d = n.__importDefault(r(3));
        class l {
            constructor(e, t) {
                this.dbName = "bilibiliPlayerCacheData", this.dbVersion = 1, this.isOpeningDB = !1, this.isSavingResource = !1, this.objectStoreName = "resource", this.resourceMaxNum = 20, this.resourceMaxSize = 524288e3, this.resourceUpdateInterval = 864e5, this.isReportedPutDB = !1, this.isReportedDelDBErr = !1, this.openDBErrNum = 0, this.openDBErrMaxNum = 10, this.stateDBStatistic = {}, this.needSaveResources = {}, this.sdk = e, this.socketController = t, this.sdk.state.dbStatistic || (this.sdk.state.dbStatistic = {}), this.stateDBStatistic = this.sdk.state.dbStatistic
            }
            destroy() {
                this.socketController && (this.socketController.off(a.default.SOCKET_CONNECT, this.onSocketConnect), this.socketController = null), this.isReportedPutDB = !1, this.needSaveResources = {}, this.stateDBStatistic = {}, this.dbClose(), this.isOpeningDB = !1, this.isSavingResource = !1, this.openDBErrNum = 0, this.isReportedDelDBErr = !1
            }
            onSocketConnect() {
                this.getDBAllResource().then(e => {
                    var t, r, n, s;
                    let i = [];
                    if (null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.length)
                        for (let t = 0; t < e.data.length; t++)
                            if (null === (n = null === (r = e.data[t]) || void 0 === r ? void 0 : r.blocks) || void 0 === n ? void 0 : n.length) {
                                const r = e.data[t];
                                let n = {
                                    id: r.id,
                                    blockIDs: []
                                };
                                for (let e = 0; e < r.blocks.length; e++) r.blocks[e] && n.blockIDs.push(e);
                                n.id && n.blockIDs.length && i.push(n)
                            }
                    i.length && (null === (s = this.socketController) || void 0 === s || s.report(c.default.RESOURCE_OPTION.UPDATE, i))
                }, e => {})
            }
            saveResource(e) {
                if (e && !this.isSavingResource)
                    if (this.isSavingResource = !0, this.needSaveResources = e, this.db) this.checkAndWriteDBData().then(() => {
                        this.delayOpenSaveResource()
                    }, () => {
                        this.delayOpenSaveResource()
                    });
                    else {
                        if (this.isOpeningDB) return d.default.getInstance().log("saveResource isOpeningDB"), void(this.isSavingResource = !1);
                        this.openDB().then(() => {
                            this.checkAndWriteDBData().then(() => {
                                this.delayOpenSaveResource()
                            }, () => {
                                this.delayOpenSaveResource()
                            })
                        }, () => {
                            this.delayOpenSaveResource()
                        })
                    }
            }
            delayOpenSaveResource() {
                window.setTimeout(() => {
                    this.isSavingResource = !1
                }, 200)
            }
            checkAndWriteDBData() {
                let e, t;
                const r = new Promise((r, n) => {
                    e = r, t = n
                });
                return this.db.objectStoreNames.contains(this.objectStoreName) ? this.writeDBData() : (this.dbClose(), this.openDB(this.dbVersion + 1).then(() => {
                    this.writeDBData().then(() => {
                        e({
                            code: 1,
                            msg: "save data success"
                        })
                    }, () => {
                        t({
                            code: -1,
                            msg: "save data fail"
                        })
                    })
                }, () => {
                    t({
                        code: -1,
                        msg: "save data fail"
                    })
                }), r)
            }
            getResource(e) {
                let t, r;
                const n = new Promise((e, n) => {
                    t = e, r = n
                });
                return this.db ? this.readDBData(e) : this.isOpeningDB ? (d.default.getInstance().log("getResource isOpeningDB"), r({
                    code: -1,
                    msg: "db is opening"
                }), n) : (this.openDB().then(() => {
                    this.readDBData(e).then(e => {
                        t(e)
                    }, e => {
                        r(e)
                    })
                }, () => {}), n)
            }
            getDBAllResource() {
                let e, t;
                const r = new Promise((r, n) => {
                    e = r, t = n
                });
                return this.db ? this.readDBAllData() : this.isOpeningDB ? (d.default.getInstance().log("getDBAllResource isOpeningDB"), t({
                    code: -1,
                    msg: "db is opening"
                }), r) : (this.openDB().then(() => {
                    this.readDBAllData().then(t => {
                        e(t)
                    }, e => {
                        t(e)
                    })
                }, () => {}), r)
            }
            readDBAllData() {
                let e, t;
                const r = new Promise((r, n) => {
                    e = r, t = n
                });
                if (!this.db.objectStoreNames.contains(this.objectStoreName)) return t({
                    code: -1,
                    msg: "db not contains objectStoreName"
                }), r;
                const n = this.db.transaction([this.objectStoreName]).objectStore(this.objectStoreName).openCursor(null, "prev");
                let s = [];
                return n.onsuccess = () => {
                    const t = n.result;
                    if (t) {
                        if (t.value && t.value.resource) {
                            let e = t.value.resource;
                            if (e.blocks && e.blocks.length)
                                for (let t = 0; t < e.blocks.length; t++) e.blocks[t] && (e.blocks[t].data = void 0);
                            s.push(e)
                        }
                        t.continue()
                    } else e({
                        code: 1,
                        msg: "success",
                        data: s
                    })
                }, n.onerror = e => {
                    t({
                        code: -1,
                        msg: "readDBAllData cursorObjectStoreRequest error"
                    })
                }, r
            }
            readDBData(e) {
                let t, r;
                const n = new Promise((e, n) => {
                    t = e, r = n
                });
                if (!this.db.objectStoreNames.contains(this.objectStoreName)) return r({
                    code: -1,
                    msg: "db not contains objectStoreName"
                }), n;
                let s = e.path,
                    o = e.rangeStart,
                    a = e.rangeEnd;
                const l = e.startTime,
                    u = this.db.transaction([this.objectStoreName]).objectStore(this.objectStoreName);
                d.default.getInstance().log("read db get data -- path: " + s);
                const h = u.get(s);
                return h.onsuccess = e => {
                    var n, u;
                    let p;
                    if (d.default.getInstance().log(`read db get data success -- path: ${s}, blockNum: ${null===(u=null===(n=h.result)||void 0===n?void 0:n.resource)||void 0===u?void 0:u.blockNum}`), h.result && (p = h.result.resource), p && p.blocks && p.blocks.length) {
                        const e = Math.floor(o / i.default.BLOCK_SIZE),
                            n = Math.floor(a / i.default.BLOCK_SIZE);
                        let u = [],
                            h = null;
                        for (let t = e; t <= n; t++) {
                            if (!p.blocks[t] || !p.blocks[t].data) return void r({
                                code: -1,
                                msg: "data not enough"
                            });
                            u.push(p.blocks[t].data)
                        }
                        if (!u.length || u.length !== n - e + 1) return void r({
                            code: -1,
                            msg: "data not enough"
                        }); {
                            let p;
                            e === n ? u[0] = u[0].slice(o % i.default.BLOCK_SIZE, a % i.default.BLOCK_SIZE + 1, "multipart/byteranges") : (u[0] = u[0].slice(o % i.default.BLOCK_SIZE, u[0].size, "multipart/byteranges"), u[u.length - 1] = u[u.length - 1].slice(0, a % i.default.BLOCK_SIZE + 1, "multipart/byteranges")), h = new Blob(u, {
                                type: "multipart/byteranges"
                            });
                            let f = new FileReader;
                            f.onload = e => {
                                if (p = e.target.result, p && p.byteLength && p.byteLength === a - o + 1) {
                                    let e = {
                                        range: o + "-" + a,
                                        from: 1,
                                        path: s,
                                        getDataTime: Date.now() - l,
                                        data: p,
                                        gotDataByte: p.byteLength,
                                        cPeerSID: ""
                                    };
                                    t({
                                        code: 1,
                                        msg: "success",
                                        responseData: e
                                    })
                                } else r({
                                    code: -1,
                                    msg: "data not enough"
                                })
                            }, f.onerror = e => {
                                f.onerror = null, f.onload = null, r({
                                    code: c.default.RESPONSE_CODE.FILE_READER_ERROR,
                                    msg: "read db fileReader error"
                                });
                                let t = "";
                                e && e.target && e.target.error && (t = e.target.error.message || ""), d.default.getInstance().error(`read db fileReader error -- path: ${s}, errorMessage: ${t}`), this.stateDBStatistic.fileReaderError = this.stateDBStatistic.fileReaderError ? this.stateDBStatistic.fileReaderError + 1 : 1
                            }, f.readAsArrayBuffer(h)
                        }
                    } else r({
                        code: -1,
                        msg: "data not enough"
                    })
                }, h.onerror = e => {
                    let t = "";
                    e && e.target && e.target.error && (t = e.target.error.message || ""), d.default.getInstance().error(`read db get data error -- path: ${s}, errorMessage: ${t}`), r({
                        code: -1,
                        msg: "get ObjectStoreRequest error"
                    })
                }, n
            }
            openDB(e = 0) {
                let t = {
                    type: c.default.TRACK_TYPE.OPEN_DB,
                    version: i.default.getInstance().version,
                    dbVersion: this.dbVersion,
                    openVersion: e,
                    dbName: this.dbName
                };
                o.default.getInstance().trigger(a.default.TRACK, t), d.default.getInstance().log(`openDB -- dbVersion: ${this.dbVersion}, openVersion: ${e}`), this.isOpeningDB = !0;
                let r, n = null,
                    s = null,
                    l = new Promise((e, t) => {
                        n = e, s = t
                    });
                return r = e > 0 ? window.indexedDB.open(this.dbName, e) : window.indexedDB.open(this.dbName), r.onupgradeneeded = e => {
                    d.default.getInstance().log("db onupgradeneeded");
                    const t = r.result;
                    if (!t.objectStoreNames.contains(this.objectStoreName)) {
                        let e;
                        e = t.createObjectStore(this.objectStoreName, {
                            keyPath: "id"
                        }), e.createIndex("id", "id", {
                            unique: !0
                        }), e.createIndex("resource", "resource", {
                            unique: !1
                        })
                    }
                }, r.onerror = t => {
                    this.isOpeningDB = !1, this.openDBErrNum++, this.openDBErrNum >= this.openDBErrMaxNum && (this.sdk.disableSaveDataByDB = !0);
                    let r = {
                        type: c.default.TRACK_TYPE.OPEN_DB_ERROR,
                        version: i.default.getInstance().version,
                        dbVersion: this.dbVersion,
                        openVersion: e,
                        dbName: this.dbName,
                        errorName: "",
                        errorMessage: ""
                    };
                    if (t && t.target && t.target.error) {
                        const e = t.target.error;
                        r.errorName = e.name || "", r.errorMessage = e.message || ""
                    }
                    o.default.getInstance().trigger(a.default.TRACK, r), d.default.getInstance().error("openDB error -- errorMessage: " + r.errorMessage), s()
                }, r.onsuccess = t => {
                    if (this.isOpeningDB = !1, this.dbVersion = r.result.version, this.db = r.result, e > 0 && !this.db.objectStoreNames.contains(this.objectStoreName)) {
                        this.dbClose(), this.openDBErrNum++, this.openDBErrNum >= this.openDBErrMaxNum && (this.sdk.disableSaveDataByDB = !0);
                        let t = {
                            type: c.default.TRACK_TYPE.OPEN_DB_ERROR,
                            version: i.default.getInstance().version,
                            dbVersion: this.dbVersion,
                            openVersion: e,
                            dbName: this.dbName,
                            errorName: "noObjectStoreName",
                            errorMessage: "no objectStoreName"
                        };
                        return o.default.getInstance().trigger(a.default.TRACK, t), d.default.getInstance().error("openDB error -- errorMessage: " + t.errorMessage), void s()
                    }
                    this.openDBErrNum = 0, this.db.onclose = t => {
                        let r = {
                            type: c.default.TRACK_TYPE.DB_CLOSE,
                            version: i.default.getInstance().version,
                            dbVersion: this.dbVersion,
                            openVersion: e,
                            dbName: this.dbName
                        };
                        o.default.getInstance().trigger(a.default.TRACK, r), d.default.getInstance().log("db onclose"), this.dbClose()
                    }, d.default.getInstance().log("openDB success -- dbVersion: " + this.dbVersion), n()
                }, l
            }
            writeDBData() {
                let e, t;
                const r = new Promise((r, n) => {
                    e = r, t = n
                });
                if (!this.db.objectStoreNames.contains(this.objectStoreName)) return t({
                    code: -1,
                    msg: "db not contains objectStoreName"
                }), r;
                const n = this.db.transaction([this.objectStoreName], "readwrite").objectStore(this.objectStoreName);
                return this.handleDBMaxLimit(n).then(r => {
                    r && r.countNum <= this.resourceMaxNum && 1024 * r.countBlockNum * 1024 <= this.resourceMaxSize ? this.saveNeedSaveData(n).then(() => {
                        e({
                            code: 1,
                            msg: "save data success"
                        })
                    }, () => {
                        t({
                            code: -1,
                            msg: "save data fail"
                        })
                    }) : (this.sdk.disableSaveDataByDB = !0, t({
                        code: -1,
                        msg: "db data more than max limit, cancel save"
                    }))
                }, () => {
                    this.sdk.disableSaveDataByDB = !0, t({
                        code: -1,
                        msg: "before save data handleDBMaxLimit error"
                    })
                }), r
            }
            saveNeedSaveData(e) {
                let t, r;
                const n = new Promise((e, n) => {
                    t = e, r = n
                });
                let s = 0,
                    l = 0,
                    u = 0;
                for (let n in this.needSaveResources) {
                    let h = {
                            id: n,
                            blockIDs: []
                        },
                        p = this.needSaveResources[n];
                    if (d.default.getInstance().log(`write db -- curNeedSaveResourceID: ${n}, curNeedSaveResourceBlockNum: ${null==p?void 0:p.blockNum}`), !p || !p.blocks || !p.blocks.length) continue;
                    s++;
                    const f = e.get(n);
                    f.onsuccess = m => {
                        var g, v;
                        let y;
                        if (d.default.getInstance().log(`write db get success -- id: ${n}, blockNum: ${null===(v=null===(g=f.result)||void 0===g?void 0:g.resource)||void 0===v?void 0:v.blockNum}`), f.result && (y = f.result.resource), y) {
                            if (y.blocks || (y.blocks = []), y.blockNum || (y.blockNum = 0), p.priority >= 0 && (y.priority = p.priority), p.blocks && p.blocks.length)
                                for (let e = 0; e < p.blocks.length; e++) p.blocks[e] && !y.blocks[e] && (y.blocks[e] = p.blocks[e], y.blockNum++, h.blockIDs.push(e));
                            p.totalSize > 0 && (y.totalSize = p.totalSize)
                        }
                        let C = null;
                        if (!y) {
                            C = p.waitConcatData, delete p.waitConcatData, y = p;
                            for (let e = 0; e < y.blocks.length; e++) y.blocks[e] && h.blockIDs.push(e)
                        }
                        try {
                            if (!this.isReportedPutDB) {
                                this.isReportedPutDB = !0;
                                let e = {
                                    type: c.default.TRACK_TYPE.PUT_DB,
                                    version: i.default.getInstance().version,
                                    dbVersion: this.dbVersion,
                                    dbName: this.dbName,
                                    resourceID: n,
                                    resourceBlockNum: y.blockNum,
                                    resourceTotalSize: y.totalSize,
                                    resourcePriority: y.priority
                                };
                                o.default.getInstance().trigger(a.default.TRACK, e)
                            }
                            d.default.getInstance().log(`put data -- id: ${n}, blockNum: ${y.blockNum}`);
                            const p = e.put({
                                id: n,
                                resource: y
                            });
                            p.onsuccess = e => {
                                var i;
                                d.default.getInstance().log(`put data success -- id: ${n}, blockNum: ${y.blockNum}`), h.blockIDs.length && (null === (i = this.socketController) || void 0 === i || i.report(c.default.RESOURCE_OPTION.ADD, [h])), l++, s === l + u && (s === l ? t({
                                    code: 1,
                                    msg: "save data success"
                                }) : r({
                                    code: -1,
                                    msg: "save data fail"
                                }))
                            }, p.onerror = e => {
                                let h = {
                                    type: c.default.TRACK_TYPE.PUT_DB_ERROR,
                                    version: i.default.getInstance().version,
                                    from: 1,
                                    dbVersion: this.dbVersion,
                                    dbName: this.dbName,
                                    resourceID: n,
                                    resourceBlockNum: y.blockNum,
                                    resourceTotalSize: y.totalSize,
                                    resourcePriority: y.priority,
                                    errorName: "",
                                    errorMessage: ""
                                };
                                if (e && e.target && e.target.error) {
                                    const t = e.target.error;
                                    h.errorName = t.name || "", h.errorMessage = t.message || ""
                                }
                                o.default.getInstance().trigger(a.default.TRACK, h), d.default.getInstance().error(`put data error -- id: ${n},  from: onerror, errorMessage: ${h.errorMessage}`), u++, s === l + u && (s === l ? t({
                                    code: 1,
                                    msg: "save data success"
                                }) : r({
                                    code: -1,
                                    msg: "save data fail"
                                }))
                            }
                        } catch (e) {
                            let h = {
                                type: c.default.TRACK_TYPE.PUT_DB_ERROR,
                                version: i.default.getInstance().version,
                                from: 2,
                                dbVersion: this.dbVersion,
                                dbName: this.dbName,
                                resourceID: n,
                                resourceBlockNum: y.blockNum,
                                resourceTotalSize: y.totalSize,
                                resourcePriority: y.priority,
                                errorName: "",
                                errorMessage: e ? "" + e : ""
                            };
                            o.default.getInstance().trigger(a.default.TRACK, h), d.default.getInstance().error(`put data error -- id: ${n}, from: try catch, errorMessage: ${h.errorMessage}`), u++, s === l + u && (s === l ? t({
                                code: 1,
                                msg: "save data success"
                            }) : r({
                                code: -1,
                                msg: "save data fail"
                            }))
                        }
                        C && (p.waitConcatData = C), p.blockNum = 0, p.blocks = []
                    }, f.onerror = e => {
                        let i = "";
                        e && e.target && e.target.error && (i = e.target.error.message || ""), d.default.getInstance().error(`write db get error -- id: ${n}, errorMessage: ${i}`), p.blockNum = 0, p.blocks = [], u++, s === l + u && (s === l ? t({
                            code: 1,
                            msg: "save data success"
                        }) : r({
                            code: -1,
                            msg: "save data fail"
                        }))
                    }
                }
                return 0 === s && t({
                    code: 1,
                    msg: "save data success"
                }), n
            }
            dbClose() {
                d.default.getInstance().log("dbClose"), this.db && (this.db.onclose = null, this.db.close(), this.db = null)
            }
            handleDBMaxLimit(e) {
                let t, r;
                const n = new Promise((e, n) => {
                    t = e, r = n
                });
                let s = 0,
                    l = 0,
                    u = [];
                const h = e.openCursor(null, "prev");
                let p = [];
                return h.onsuccess = () => {
                    const n = h.result;
                    if (n) {
                        if (n.value && n.value.resource) {
                            let e = {
                                id: n.value.resource.id,
                                blocks: [],
                                blockNum: n.value.resource.blockNum,
                                priority: n.value.resource.priority,
                                updateTime: n.value.resource.updateTime
                            };
                            p.push(e)
                        }
                        n.continue()
                    } else {
                        p.sort((function(e, t) {
                            return t.updateTime - e.updateTime
                        }));
                        let n = p.length;
                        for (let f = this.resourceMaxNum; f < p.length && !((new Date).getTime() - p[f].updateTime < this.resourceUpdateInterval); f++) {
                            s++, d.default.getInstance().log("more than maxNum delete -- id: " + p[f].id);
                            const m = e.delete(p[f].id);
                            m.onsuccess = () => {
                                var e;
                                d.default.getInstance().log("more than maxNum delete success -- id: " + p[f].id), l++, u.push({
                                    id: p[f].id,
                                    blockIDs: []
                                }), l === s && (null === (e = this.socketController) || void 0 === e || e.report(c.default.RESOURCE_OPTION.DEL, u), t({
                                    countNum: n,
                                    countBlockNum: h,
                                    delResources: u
                                }))
                            }, m.onerror = e => {
                                let t = {
                                    type: c.default.TRACK_TYPE.DEL_DB_ERROR,
                                    version: i.default.getInstance().version,
                                    from: 1,
                                    dbVersion: this.dbVersion,
                                    dbName: this.dbName,
                                    resourceID: p[f].id,
                                    errorName: "",
                                    errorMessage: ""
                                };
                                if (e && e.target && e.target.error) {
                                    const r = e.target.error;
                                    t.errorName = r.name || "", t.errorMessage = r.message || ""
                                }
                                this.isReportedDelDBErr || (this.isReportedDelDBErr = !0, o.default.getInstance().trigger(a.default.TRACK, t)), d.default.getInstance().error(`more than maxNum delete error -- id: ${p[f].id}, errorMessage: ${t.errorMessage}`), r()
                            }, n--
                        }
                        let h = 0;
                        for (let f = 0; f < p.length && f < n; f++)
                            if (h += p[f].blockNum, 1024 * h * 1024 > this.resourceMaxSize) {
                                if ((new Date).getTime() - p[f].updateTime < this.resourceUpdateInterval) break;
                                s++, d.default.getInstance().log("more than maxSize delete -- id: " + p[f].id);
                                const m = e.delete(p[f].id);
                                m.onsuccess = () => {
                                    var e;
                                    d.default.getInstance().log("more than maxSize delete success -- id: " + p[f].id), l++, u.push({
                                        id: p[f].id,
                                        blockIDs: []
                                    }), l === s && (null === (e = this.socketController) || void 0 === e || e.report(c.default.RESOURCE_OPTION.DEL, u), t({
                                        countNum: n,
                                        countBlockNum: h,
                                        delResources: u
                                    }))
                                }, m.onerror = e => {
                                    let t = {
                                        type: c.default.TRACK_TYPE.DEL_DB_ERROR,
                                        version: i.default.getInstance().version,
                                        from: 2,
                                        dbVersion: this.dbVersion,
                                        dbName: this.dbName,
                                        resourceID: p[f].id,
                                        errorName: "",
                                        errorMessage: ""
                                    };
                                    if (e && e.target && e.target.error) {
                                        const r = e.target.error;
                                        t.errorName = r.name || "", t.errorMessage = r.message || ""
                                    }
                                    this.isReportedDelDBErr || (this.isReportedDelDBErr = !0, o.default.getInstance().trigger(a.default.TRACK, t)), d.default.getInstance().error(`more than maxSize delete error -- id: ${p[f].id}, errorMessage: ${t.errorMessage}`), r()
                                }, h -= p[f].blockNum, n--
                            }
                        d.default.getInstance().log(`handleDBMaxLimit -- countNum: ${n}, countBlockNum: ${h}`), 0 === s && t({
                            countNum: n,
                            countBlockNum: h,
                            delResources: u
                        })
                    }
                }, h.onerror = e => {
                    let t = "";
                    e && e.target && e.target.error && (t = e.target.error.message || ""), d.default.getInstance().error("handleDBMaxLimit openCursor error -- errorMessage: " + t), r()
                }, n
            }
        }
        n.__decorate([s.default], l.prototype, "onSocketConnect", null), t.default = l
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0),
            s = n.__importDefault(r(11)),
            i = n.__importDefault(r(3)),
            o = n.__importDefault(r(13)),
            a = r(36),
            c = n.__importDefault(r(2)),
            d = n.__importDefault(r(5)),
            l = r(58),
            u = r(59);
        t.default = class {
            constructor(e) {
                this.sdk = e, this.init()
            }
            init() {
                this.urlReportRecord = {}, this.events = new o.default;
                let e = "https://web-player-tracker.biliapi.net";
                try {
                    const t = JSON.parse(s.default.getLocalSettings("bp_nc_config"));
                    (null == t ? void 0 : t.socketURL) && "string" == typeof t.socketURL && (e = t.socketURL)
                } catch (e) {}
                let t = 1e4;
                s.default.RUNTIME_MODE === l.RUNTIME_MODE.DEV && (t = 3e3);
                let r = {
                    buvid: this.sdk.config.buvid ? this.sdk.config.buvid : "",
                    sdkVersion: d.default.getInstance().version,
                    aid: this.sdk.config.aid,
                    cid: this.sdk.config.cid
                };
                this.sdk.config.isAdmin && (r.isAdmin = 1), this.sdk.config.debugKey && (r.debugKey = this.sdk.config.debugKey), this.socket = a.io(e, {
                    autoConnect: !1,
                    reconnectionAttempts: 3,
                    reconnectionDelay: t,
                    reconnectionDelayMax: 6e4,
                    transports: ["websocket"],
                    secure: !0,
                    parser: u,
                    query: r
                }), this.socket.on("connect", () => {
                    this.socketID = this.socket.id, this.sdk.saveAndGetDataSwitch = !0, this.trigger(c.default.SOCKET_CONNECT)
                }), this.socket.on("disconnect", e => {
                    this.socketID = "", this.sdk.saveAndGetDataSwitch = !1, this.sdk.saveDataBuvidSwitch = !1
                }), this.socket.on("message", e => {
                    this.trigger(c.default.SOCKET_MESSAGE, e), e && e.fromSocketID && ("activePeer" === e.type ? this.sdk.saveDataBuvidSwitch = !0 : "trackerVersion" === e.type ? (this.sdk.trackerVersion = e.version, i.default.getInstance().log("tracker version is: " + this.sdk.trackerVersion)) : "disableGetData" === e.type && (this.sdk.disableGetData = !0, i.default.getInstance().log(`tracker disable getData, aid is ${this.sdk.config.aid}, cid is ${this.sdk.config.cid}`)))
                }), this.socket.connect()
            }
            on(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.on(e, t)
            }
            off(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.off(e, t)
            }
            trigger(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.trigger(e, t)
            }
            getPeerInfo(e, t, r) {
                return new Promise((n, s) => {
                    var i;
                    e && t && (null === (i = this.socket) || void 0 === i ? void 0 : i.connected) ? (r = this.handleResourceURL(e, r), this.socket.emit("getPeerInfoV2", e, t, r, e => {
                        n(e)
                    })) : s({
                        code: -1,
                        msg: "no valid peer, getPeerInfo sdk internal error"
                    })
                })
            }
            handleResourceURL(e, t) {
                return e && t ? this.urlReportRecord[e] ? "" : Object.keys(this.urlReportRecord).length >= 1e3 ? (i.default.getInstance().log("urlReportRecord is reached the limit: 1000"), "") : ((t = t.replace(/^https?\:\/\//i, "")) && (this.urlReportRecord[e] = !0), t) : ""
            }
            releasePeerInfo(e) {
                var t;
                (null === (t = this.socket) || void 0 === t ? void 0 : t.connected) && this.socket.emit("releasePeerInfo", e)
            }
            sendMessage(e, t) {
                var r;
                (null === (r = this.socket) || void 0 === r ? void 0 : r.connected) && this.socket.emit("message", e, t)
            }
            report(e, t) {
                var r;
                e && (null == t ? void 0 : t.length) && (null === (r = this.socket) || void 0 === r ? void 0 : r.connected) && this.socket.emit("report", e, t)
            }
            reportRTCState(e, t, r, n) {
                var s;
                (null === (s = this.socket) || void 0 === s ? void 0 : s.connected) && this.socket.emit("reportRTCState", e, t, r, n)
            }
            getNodeVar(e, t) {
                var r;
                (null === (r = this.socket) || void 0 === r ? void 0 : r.connected) && this.socket.emit("getVar", e, t)
            }
            hotPushToTracker(e, t) {
                var r;
                (null === (r = this.socket) || void 0 === r ? void 0 : r.connected) && this.socket.emit("hotPushToTracker", e, t)
            }
            destroy() {
                this.socket && (this.socket.off("connect"), this.socket.off("disconnect"), this.socket.off("message"), this.socketID = "", this.socket.disconnect(), this.socket = null), this.events && (this.events.destroy(), this.events = null), this.urlReportRecord = {}
            }
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.Socket = t.io = t.Manager = t.protocol = void 0;
        const n = r(37),
            s = r(20),
            i = r(27);
        Object.defineProperty(t, "Socket", {
            enumerable: !0,
            get: function() {
                return i.Socket
            }
        });
        const o = r(7)("socket.io-client");
        e.exports = t = c;
        const a = t.managers = {};

        function c(e, t) {
            "object" == typeof e && (t = e, e = void 0), t = t || {};
            const r = n.url(e),
                i = r.source,
                c = r.id,
                d = r.path,
                l = a[c] && d in a[c].nsps;
            let u;
            return t.forceNew || t["force new connection"] || !1 === t.multiplex || l ? (o("ignoring socket cache for %s", i), u = new s.Manager(i, t)) : (a[c] || (o("new io instance for %s", i), a[c] = new s.Manager(i, t)), u = a[c]), r.query && !t.query && (t.query = r.query), u.socket(r.path, t)
        }
        t.io = c;
        var d = r(17);
        Object.defineProperty(t, "protocol", {
            enumerable: !0,
            get: function() {
                return d.protocol
            }
        }), t.connect = c;
        var l = r(20);
        Object.defineProperty(t, "Manager", {
            enumerable: !0,
            get: function() {
                return l.Manager
            }
        })
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.url = void 0;
        const n = r(19),
            s = r(7)("socket.io-client:url");
        t.url = function(e, t) {
            let r = e;
            t = t || "undefined" != typeof location && location, null == e && (e = t.protocol + "//" + t.host), "string" == typeof e && ("/" === e.charAt(0) && (e = "/" === e.charAt(1) ? t.protocol + e : t.host + e), /^(https?|wss?):\/\//.test(e) || (s("protocol-less url %s", e), e = void 0 !== t ? t.protocol + "//" + e : "https://" + e), s("parse %s", e), r = n(e)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
            const i = -1 !== r.host.indexOf(":") ? "[" + r.host + "]" : r.host;
            return r.id = r.protocol + "://" + i + ":" + r.port, r.href = r.protocol + "://" + i + (t && t.port === r.port ? "" : ":" + r.port), r
        }
    }, function(e, t, r) {
        e.exports = function(e) {
            function t(e) {
                let r, s = null;

                function i(...e) {
                    if (!i.enabled) return;
                    const n = i,
                        s = Number(new Date),
                        o = s - (r || s);
                    n.diff = o, n.prev = r, n.curr = s, r = s, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
                    let a = 0;
                    e[0] = e[0].replace(/%([a-zA-Z%])/g, (r, s) => {
                        if ("%%" === r) return "%";
                        a++;
                        const i = t.formatters[s];
                        if ("function" == typeof i) {
                            const t = e[a];
                            r = i.call(n, t), e.splice(a, 1), a--
                        }
                        return r
                    }), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e)
                }
                return i.namespace = e, i.useColors = t.useColors(), i.color = t.selectColor(e), i.extend = n, i.destroy = t.destroy, Object.defineProperty(i, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => null === s ? t.enabled(e) : s,
                    set: e => {
                        s = e
                    }
                }), "function" == typeof t.init && t.init(i), i
            }

            function n(e, r) {
                const n = t(this.namespace + (void 0 === r ? ":" : r) + e);
                return n.log = this.log, n
            }

            function s(e) {
                return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*")
            }
            return t.debug = t, t.default = t, t.coerce = function(e) {
                return e instanceof Error ? e.stack || e.message : e
            }, t.disable = function() {
                const e = [...t.names.map(s), ...t.skips.map(s).map(e => "-" + e)].join(",");
                return t.enable(""), e
            }, t.enable = function(e) {
                let r;
                t.save(e), t.names = [], t.skips = [];
                const n = ("string" == typeof e ? e : "").split(/[\s,]+/),
                    s = n.length;
                for (r = 0; r < s; r++) n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.substr(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
            }, t.enabled = function(e) {
                if ("*" === e[e.length - 1]) return !0;
                let r, n;
                for (r = 0, n = t.skips.length; r < n; r++)
                    if (t.skips[r].test(e)) return !1;
                for (r = 0, n = t.names.length; r < n; r++)
                    if (t.names[r].test(e)) return !0;
                return !1
            }, t.humanize = r(39), t.destroy = function() {}, Object.keys(e).forEach(r => {
                t[r] = e[r]
            }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function(e) {
                let r = 0;
                for (let t = 0; t < e.length; t++) r = (r << 5) - r + e.charCodeAt(t), r |= 0;
                return t.colors[Math.abs(r) % t.colors.length]
            }, t.enable(t.load()), t
        }
    }, function(e, t) {
        var r = 1e3,
            n = 6e4,
            s = 60 * n,
            i = 24 * s;

        function o(e, t, r, n) {
            var s = t >= 1.5 * r;
            return Math.round(e / r) + " " + n + (s ? "s" : "")
        }
        e.exports = function(e, t) {
            t = t || {};
            var a, c, d = typeof e;
            if ("string" === d && e.length > 0) return function(e) {
                if (!((e = String(e)).length > 100)) {
                    var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                    if (t) {
                        var o = parseFloat(t[1]);
                        switch ((t[2] || "ms").toLowerCase()) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                                return 315576e5 * o;
                            case "weeks":
                            case "week":
                            case "w":
                                return 6048e5 * o;
                            case "days":
                            case "day":
                            case "d":
                                return o * i;
                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                                return o * s;
                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                                return o * n;
                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                                return o * r;
                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                                return o;
                            default:
                                return
                        }
                    }
                }
            }(e);
            if ("number" === d && isFinite(e)) return t.long ? (a = e, (c = Math.abs(a)) >= i ? o(a, c, i, "day") : c >= s ? o(a, c, s, "hour") : c >= n ? o(a, c, n, "minute") : c >= r ? o(a, c, r, "second") : a + " ms") : function(e) {
                var t = Math.abs(e);
                return t >= i ? Math.round(e / i) + "d" : t >= s ? Math.round(e / s) + "h" : t >= n ? Math.round(e / n) + "m" : t >= r ? Math.round(e / r) + "s" : e + "ms"
            }(e);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
        }
    }, function(e, t, r) {
        const n = r(41);
        e.exports = (e, t) => new n(e, t), e.exports.Socket = n, e.exports.protocol = n.protocol, e.exports.Transport = r(14), e.exports.transports = r(21), e.exports.parser = r(4)
    }, function(e, t, r) {
        const n = r(21),
            s = r(15),
            i = r(9)("engine.io-client:socket"),
            o = r(4),
            a = r(19),
            c = r(16);
        class d extends s {
            constructor(e, t = {}) {
                super(), e && "object" == typeof e && (t = e, e = null), e ? (e = a(e), t.hostname = e.host, t.secure = "https" === e.protocol || "wss" === e.protocol, t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = a(t.host).host), this.secure = null != t.secure ? t.secure : "undefined" != typeof location && "https:" === location.protocol, t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = t.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? 443 : 80), this.transports = t.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
                    path: "/engine.io",
                    agent: !1,
                    withCredentials: !1,
                    upgrade: !0,
                    jsonp: !0,
                    timestampParam: "t",
                    rememberUpgrade: !1,
                    rejectUnauthorized: !0,
                    perMessageDeflate: {
                        threshold: 1024
                    },
                    transportOptions: {}
                }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", "string" == typeof this.opts.query && (this.opts.query = c.decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, this.open()
            }
            createTransport(e) {
                i('creating transport "%s"', e);
                const t = function(e) {
                    const t = {};
                    for (let r in e) e.hasOwnProperty(r) && (t[r] = e[r]);
                    return t
                }(this.opts.query);
                t.EIO = o.protocol, t.transport = e, this.id && (t.sid = this.id);
                const r = Object.assign({}, this.opts.transportOptions[e], this.opts, {
                    query: t,
                    socket: this,
                    hostname: this.hostname,
                    secure: this.secure,
                    port: this.port
                });
                return i("options: %j", r), new n[e](r)
            }
            open() {
                let e;
                if (this.opts.rememberUpgrade && d.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) e = "websocket";
                else {
                    if (0 === this.transports.length) {
                        const e = this;
                        return void setTimeout((function() {
                            e.emit("error", "No transports available")
                        }), 0)
                    }
                    e = this.transports[0]
                }
                this.readyState = "opening";
                try {
                    e = this.createTransport(e)
                } catch (e) {
                    return i("error while creating transport: %s", e), this.transports.shift(), void this.open()
                }
                e.open(), this.setTransport(e)
            }
            setTransport(e) {
                i("setting transport %s", e.name);
                const t = this;
                this.transport && (i("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = e, e.on("drain", (function() {
                    t.onDrain()
                })).on("packet", (function(e) {
                    t.onPacket(e)
                })).on("error", (function(e) {
                    t.onError(e)
                })).on("close", (function() {
                    t.onClose("transport close")
                }))
            }
            probe(e) {
                i('probing transport "%s"', e);
                let t = this.createTransport(e, {
                        probe: 1
                    }),
                    r = !1;
                const n = this;

                function s() {
                    if (n.onlyBinaryUpgrades) {
                        const e = !this.supportsBinary && n.transport.supportsBinary;
                        r = r || e
                    }
                    r || (i('probe transport "%s" opened', e), t.send([{
                        type: "ping",
                        data: "probe"
                    }]), t.once("packet", (function(s) {
                        if (!r)
                            if ("pong" === s.type && "probe" === s.data) {
                                if (i('probe transport "%s" pong', e), n.upgrading = !0, n.emit("upgrading", t), !t) return;
                                d.priorWebsocketSuccess = "websocket" === t.name, i('pausing current transport "%s"', n.transport.name), n.transport.pause((function() {
                                    r || "closed" !== n.readyState && (i("changing transport and sending upgrade packet"), h(), n.setTransport(t), t.send([{
                                        type: "upgrade"
                                    }]), n.emit("upgrade", t), t = null, n.upgrading = !1, n.flush())
                                }))
                            } else {
                                i('probe transport "%s" failed', e);
                                const r = new Error("probe error");
                                r.transport = t.name, n.emit("upgradeError", r)
                            }
                    })))
                }

                function o() {
                    r || (r = !0, h(), t.close(), t = null)
                }

                function a(r) {
                    const s = new Error("probe error: " + r);
                    s.transport = t.name, o(), i('probe transport "%s" failed because of error: %s', e, r), n.emit("upgradeError", s)
                }

                function c() {
                    a("transport closed")
                }

                function l() {
                    a("socket closed")
                }

                function u(e) {
                    t && e.name !== t.name && (i('"%s" works - aborting "%s"', e.name, t.name), o())
                }

                function h() {
                    t.removeListener("open", s), t.removeListener("error", a), t.removeListener("close", c), n.removeListener("close", l), n.removeListener("upgrading", u)
                }
                d.priorWebsocketSuccess = !1, t.once("open", s), t.once("error", a), t.once("close", c), this.once("close", l), this.once("upgrading", u), t.open()
            }
            onOpen() {
                if (i("socket open"), this.readyState = "open", d.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause) {
                    i("starting upgrade probes");
                    let e = 0;
                    const t = this.upgrades.length;
                    for (; e < t; e++) this.probe(this.upgrades[e])
                }
            }
            onPacket(e) {
                if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (i('socket receive: type "%s", data "%s"', e.type, e.data), this.emit("packet", e), this.emit("heartbeat"), e.type) {
                    case "open":
                        this.onHandshake(JSON.parse(e.data));
                        break;
                    case "ping":
                        this.resetPingTimeout(), this.sendPacket("pong"), this.emit("pong");
                        break;
                    case "error":
                        const t = new Error("server error");
                        t.code = e.data, this.onError(t);
                        break;
                    case "message":
                        this.emit("data", e.data), this.emit("message", e.data)
                } else i('packet received with socket readyState "%s"', this.readyState)
            }
            onHandshake(e) {
                this.emit("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout()
            }
            resetPingTimeout() {
                clearTimeout(this.pingTimeoutTimer), this.pingTimeoutTimer = setTimeout(() => {
                    this.onClose("ping timeout")
                }, this.pingInterval + this.pingTimeout)
            }
            onDrain() {
                this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush()
            }
            flush() {
                "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (i("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
            }
            write(e, t, r) {
                return this.sendPacket("message", e, t, r), this
            }
            send(e, t, r) {
                return this.sendPacket("message", e, t, r), this
            }
            sendPacket(e, t, r, n) {
                if ("function" == typeof t && (n = t, t = void 0), "function" == typeof r && (n = r, r = null), "closing" === this.readyState || "closed" === this.readyState) return;
                (r = r || {}).compress = !1 !== r.compress;
                const s = {
                    type: e,
                    data: t,
                    options: r
                };
                this.emit("packetCreate", s), this.writeBuffer.push(s), n && this.once("flush", n), this.flush()
            }
            close() {
                const e = this;

                function t() {
                    e.onClose("forced close"), i("socket closing - telling transport to close"), e.transport.close()
                }

                function r() {
                    e.removeListener("upgrade", r), e.removeListener("upgradeError", r), t()
                }

                function n() {
                    e.once("upgrade", r), e.once("upgradeError", r)
                }
                return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", (function() {
                    this.upgrading ? n() : t()
                })) : this.upgrading ? n() : t()), this
            }
            onError(e) {
                i("socket error %j", e), d.priorWebsocketSuccess = !1, this.emit("error", e), this.onClose("transport error", e)
            }
            onClose(e, t) {
                if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                    i('socket close with reason: "%s"', e);
                    const r = this;
                    clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", e, t), r.writeBuffer = [], r.prevBufferLen = 0
                }
            }
            filterUpgrades(e) {
                const t = [];
                let r = 0;
                const n = e.length;
                for (; r < n; r++) ~this.transports.indexOf(e[r]) && t.push(e[r]);
                return t
            }
        }
        d.priorWebsocketSuccess = !1, d.protocol = o.protocol, e.exports = d
    }, function(e, t) {
        try {
            e.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
        } catch (t) {
            e.exports = !1
        }
    }, function(e, t, r) {
        const n = r(22),
            s = r(23),
            i = r(15),
            {
                pick: o
            } = r(26),
            a = r(8),
            c = r(9)("engine.io-client:polling-xhr");

        function d() {}
        const l = null != new n({
            xdomain: !1
        }).responseType;
        class u extends i {
            constructor(e, t) {
                super(), this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.create()
            }
            create() {
                const e = o(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized");
                e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs;
                const t = this.xhr = new n(e),
                    r = this;
                try {
                    c("xhr open %s: %s", this.method, this.uri), t.open(this.method, this.uri, this.async);
                    try {
                        if (this.opts.extraHeaders) {
                            t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
                            for (let e in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(e) && t.setRequestHeader(e, this.opts.extraHeaders[e])
                        }
                    } catch (e) {}
                    if ("POST" === this.method) try {
                        t.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                    } catch (e) {}
                    try {
                        t.setRequestHeader("Accept", "*/*")
                    } catch (e) {}
                    "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), this.hasXDR() ? (t.onload = function() {
                        r.onLoad()
                    }, t.onerror = function() {
                        r.onError(t.responseText)
                    }) : t.onreadystatechange = function() {
                        4 === t.readyState && (200 === t.status || 1223 === t.status ? r.onLoad() : setTimeout((function() {
                            r.onError("number" == typeof t.status ? t.status : 0)
                        }), 0))
                    }, c("xhr data %s", this.data), t.send(this.data)
                } catch (e) {
                    return void setTimeout((function() {
                        r.onError(e)
                    }), 0)
                }
                "undefined" != typeof document && (this.index = u.requestsCount++, u.requests[this.index] = this)
            }
            onSuccess() {
                this.emit("success"), this.cleanup()
            }
            onData(e) {
                this.emit("data", e), this.onSuccess()
            }
            onError(e) {
                this.emit("error", e), this.cleanup(!0)
            }
            cleanup(e) {
                if (void 0 !== this.xhr && null !== this.xhr) {
                    if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = d : this.xhr.onreadystatechange = d, e) try {
                        this.xhr.abort()
                    } catch (e) {}
                    "undefined" != typeof document && delete u.requests[this.index], this.xhr = null
                }
            }
            onLoad() {
                const e = this.xhr.responseText;
                null !== e && this.onData(e)
            }
            hasXDR() {
                return "undefined" != typeof XDomainRequest && !this.xs && this.enablesXDR
            }
            abort() {
                this.cleanup()
            }
        }

        function h() {
            for (let e in u.requests) u.requests.hasOwnProperty(e) && u.requests[e].abort()
        }
        u.requestsCount = 0, u.requests = {}, "undefined" != typeof document && ("function" == typeof attachEvent ? attachEvent("onunload", h) : "function" == typeof addEventListener && addEventListener("onpagehide" in a ? "pagehide" : "unload", h, !1)), e.exports = class extends s {
            constructor(e) {
                if (super(e), "undefined" != typeof location) {
                    const t = "https:" === location.protocol;
                    let r = location.port;
                    r || (r = t ? 443 : 80), this.xd = "undefined" != typeof location && e.hostname !== location.hostname || r !== e.port, this.xs = e.secure !== t
                }
                const t = e && e.forceBase64;
                this.supportsBinary = l && !t
            }
            request(e = {}) {
                return Object.assign(e, {
                    xd: this.xd,
                    xs: this.xs
                }, this.opts), new u(this.uri(), e)
            }
            doWrite(e, t) {
                const r = this.request({
                        method: "POST",
                        data: e
                    }),
                    n = this;
                r.on("success", t), r.on("error", (function(e) {
                    n.onError("xhr post error", e)
                }))
            }
            doPoll() {
                c("xhr poll");
                const e = this.request(),
                    t = this;
                e.on("data", (function(e) {
                    t.onData(e)
                })), e.on("error", (function(e) {
                    t.onError("xhr poll error", e)
                })), this.pollXhr = e
            }
        }, e.exports.Request = u
    }, function(e, t, r) {
        const {
            PACKET_TYPES: n
        } = r(24), s = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob), i = "function" == typeof ArrayBuffer, o = (e, t) => {
            const r = new FileReader;
            return r.onload = function() {
                const e = r.result.split(",")[1];
                t("b" + e)
            }, r.readAsDataURL(e)
        };
        e.exports = ({
            type: e,
            data: t
        }, r, a) => {
            return s && t instanceof Blob ? r ? a(t) : o(t, a) : i && (t instanceof ArrayBuffer || (c = t, "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(c) : c && c.buffer instanceof ArrayBuffer)) ? r ? a(t instanceof ArrayBuffer ? t : t.buffer) : o(new Blob([t]), a) : a(n[e] + (t || ""));
            var c
        }
    }, function(e, t, r) {
        const {
            PACKET_TYPES_REVERSE: n,
            ERROR_PACKET: s
        } = r(24);
        let i;
        "function" == typeof ArrayBuffer && (i = r(46));
        const o = (e, t) => {
                if (i) {
                    const r = i.decode(e);
                    return a(r, t)
                }
                return {
                    base64: !0,
                    data: e
                }
            },
            a = (e, t) => {
                switch (t) {
                    case "blob":
                        return e instanceof ArrayBuffer ? new Blob([e]) : e;
                    case "arraybuffer":
                    default:
                        return e
                }
            };
        e.exports = (e, t) => {
            if ("string" != typeof e) return {
                type: "message",
                data: a(e, t)
            };
            const r = e.charAt(0);
            return "b" === r ? {
                type: "message",
                data: o(e.substring(1), t)
            } : n[r] ? e.length > 1 ? {
                type: n[r],
                data: e.substring(1)
            } : {
                type: n[r]
            } : s
        }
    }, function(e, t) {
        ! function(e) {
            "use strict";
            t.encode = function(t) {
                var r, n = new Uint8Array(t),
                    s = n.length,
                    i = "";
                for (r = 0; r < s; r += 3) i += e[n[r] >> 2], i += e[(3 & n[r]) << 4 | n[r + 1] >> 4], i += e[(15 & n[r + 1]) << 2 | n[r + 2] >> 6], i += e[63 & n[r + 2]];
                return s % 3 == 2 ? i = i.substring(0, i.length - 1) + "=" : s % 3 == 1 && (i = i.substring(0, i.length - 2) + "=="), i
            }, t.decode = function(t) {
                var r, n, s, i, o, a = .75 * t.length,
                    c = t.length,
                    d = 0;
                "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--);
                var l = new ArrayBuffer(a),
                    u = new Uint8Array(l);
                for (r = 0; r < c; r += 4) n = e.indexOf(t[r]), s = e.indexOf(t[r + 1]), i = e.indexOf(t[r + 2]), o = e.indexOf(t[r + 3]), u[d++] = n << 2 | s >> 4, u[d++] = (15 & s) << 4 | i >> 2, u[d++] = (3 & i) << 6 | 63 & o;
                return l
            }
        }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
    }, function(e, t, r) {
        e.exports = function(e) {
            function t(e) {
                let r, s = null;

                function i(...e) {
                    if (!i.enabled) return;
                    const n = i,
                        s = Number(new Date),
                        o = s - (r || s);
                    n.diff = o, n.prev = r, n.curr = s, r = s, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
                    let a = 0;
                    e[0] = e[0].replace(/%([a-zA-Z%])/g, (r, s) => {
                        if ("%%" === r) return "%";
                        a++;
                        const i = t.formatters[s];
                        if ("function" == typeof i) {
                            const t = e[a];
                            r = i.call(n, t), e.splice(a, 1), a--
                        }
                        return r
                    }), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e)
                }
                return i.namespace = e, i.useColors = t.useColors(), i.color = t.selectColor(e), i.extend = n, i.destroy = t.destroy, Object.defineProperty(i, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => null === s ? t.enabled(e) : s,
                    set: e => {
                        s = e
                    }
                }), "function" == typeof t.init && t.init(i), i
            }

            function n(e, r) {
                const n = t(this.namespace + (void 0 === r ? ":" : r) + e);
                return n.log = this.log, n
            }

            function s(e) {
                return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*")
            }
            return t.debug = t, t.default = t, t.coerce = function(e) {
                return e instanceof Error ? e.stack || e.message : e
            }, t.disable = function() {
                const e = [...t.names.map(s), ...t.skips.map(s).map(e => "-" + e)].join(",");
                return t.enable(""), e
            }, t.enable = function(e) {
                let r;
                t.save(e), t.names = [], t.skips = [];
                const n = ("string" == typeof e ? e : "").split(/[\s,]+/),
                    s = n.length;
                for (r = 0; r < s; r++) n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.substr(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
            }, t.enabled = function(e) {
                if ("*" === e[e.length - 1]) return !0;
                let r, n;
                for (r = 0, n = t.skips.length; r < n; r++)
                    if (t.skips[r].test(e)) return !1;
                for (r = 0, n = t.names.length; r < n; r++)
                    if (t.names[r].test(e)) return !0;
                return !1
            }, t.humanize = r(48), t.destroy = function() {}, Object.keys(e).forEach(r => {
                t[r] = e[r]
            }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function(e) {
                let r = 0;
                for (let t = 0; t < e.length; t++) r = (r << 5) - r + e.charCodeAt(t), r |= 0;
                return t.colors[Math.abs(r) % t.colors.length]
            }, t.enable(t.load()), t
        }
    }, function(e, t) {
        var r = 1e3,
            n = 6e4,
            s = 60 * n,
            i = 24 * s;

        function o(e, t, r, n) {
            var s = t >= 1.5 * r;
            return Math.round(e / r) + " " + n + (s ? "s" : "")
        }
        e.exports = function(e, t) {
            t = t || {};
            var a, c, d = typeof e;
            if ("string" === d && e.length > 0) return function(e) {
                if (!((e = String(e)).length > 100)) {
                    var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                    if (t) {
                        var o = parseFloat(t[1]);
                        switch ((t[2] || "ms").toLowerCase()) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                                return 315576e5 * o;
                            case "weeks":
                            case "week":
                            case "w":
                                return 6048e5 * o;
                            case "days":
                            case "day":
                            case "d":
                                return o * i;
                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                                return o * s;
                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                                return o * n;
                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                                return o * r;
                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                                return o;
                            default:
                                return
                        }
                    }
                }
            }(e);
            if ("number" === d && isFinite(e)) return t.long ? (a = e, (c = Math.abs(a)) >= i ? o(a, c, i, "day") : c >= s ? o(a, c, s, "hour") : c >= n ? o(a, c, n, "minute") : c >= r ? o(a, c, r, "second") : a + " ms") : function(e) {
                var t = Math.abs(e);
                return t >= i ? Math.round(e / i) + "d" : t >= s ? Math.round(e / s) + "h" : t >= n ? Math.round(e / n) + "m" : t >= r ? Math.round(e / r) + "s" : e + "ms"
            }(e);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
        }
    }, function(e, t, r) {
        const n = r(23),
            s = r(8),
            i = /\n/g,
            o = /\\n/g;
        let a;

        function c() {}
        e.exports = class extends n {
            constructor(e) {
                super(e), this.query = this.query || {}, a || (a = s.___eio = s.___eio || []), this.index = a.length;
                const t = this;
                a.push((function(e) {
                    t.onData(e)
                })), this.query.j = this.index, "function" == typeof addEventListener && addEventListener("beforeunload", (function() {
                    t.script && (t.script.onerror = c)
                }), !1)
            }
            get supportsBinary() {
                return !1
            }
            doClose() {
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), super.doClose()
            }
            doPoll() {
                const e = this,
                    t = document.createElement("script");
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), t.async = !0, t.src = this.uri(), t.onerror = function(t) {
                    e.onError("jsonp poll error", t)
                };
                const r = document.getElementsByTagName("script")[0];
                r ? r.parentNode.insertBefore(t, r) : (document.head || document.body).appendChild(t), this.script = t, "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout((function() {
                    const e = document.createElement("iframe");
                    document.body.appendChild(e), document.body.removeChild(e)
                }), 100)
            }
            doWrite(e, t) {
                const r = this;
                let n;
                if (!this.form) {
                    const e = document.createElement("form"),
                        t = document.createElement("textarea"),
                        r = this.iframeId = "eio_iframe_" + this.index;
                    e.className = "socketio", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.target = r, e.method = "POST", e.setAttribute("accept-charset", "utf-8"), t.name = "d", e.appendChild(t), document.body.appendChild(e), this.form = e, this.area = t
                }

                function s() {
                    a(), t()
                }

                function a() {
                    if (r.iframe) try {
                        r.form.removeChild(r.iframe)
                    } catch (e) {
                        r.onError("jsonp polling iframe removal error", e)
                    }
                    try {
                        const e = '<iframe src="javascript:0" name="' + r.iframeId + '">';
                        n = document.createElement(e)
                    } catch (e) {
                        n = document.createElement("iframe"), n.name = r.iframeId, n.src = "javascript:0"
                    }
                    n.id = r.iframeId, r.form.appendChild(n), r.iframe = n
                }
                this.form.action = this.uri(), a(), e = e.replace(o, "\\\n"), this.area.value = e.replace(i, "\\n");
                try {
                    this.form.submit()
                } catch (e) {}
                this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
                    "complete" === r.iframe.readyState && s()
                } : this.iframe.onload = s
            }
        }
    }, function(e, t, r) {
        const n = r(14),
            s = r(4),
            i = r(16),
            o = r(25),
            {
                pick: a
            } = r(26),
            {
                WebSocket: c,
                usingBrowserWebSocket: d,
                defaultBinaryType: l
            } = r(51),
            u = r(9)("engine.io-client:websocket"),
            h = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase();
        class p extends n {
            constructor(e) {
                super(e), this.supportsBinary = !e.forceBase64
            }
            get name() {
                return "websocket"
            }
            doOpen() {
                if (!this.check()) return;
                const e = this.uri(),
                    t = this.opts.protocols,
                    r = h ? {} : a(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
                this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
                try {
                    this.ws = d && !h ? t ? new c(e, t) : new c(e) : new c(e, t, r)
                } catch (e) {
                    return this.emit("error", e)
                }
                this.ws.binaryType = this.socket.binaryType || l, this.addEventListeners()
            }
            addEventListeners() {
                const e = this;
                this.ws.onopen = function() {
                    e.onOpen()
                }, this.ws.onclose = function() {
                    e.onClose()
                }, this.ws.onmessage = function(t) {
                    e.onData(t.data)
                }, this.ws.onerror = function(t) {
                    e.onError("websocket error", t)
                }
            }
            write(e) {
                const t = this;
                this.writable = !1;
                let r = e.length,
                    n = 0;
                const i = r;
                for (; n < i; n++) ! function(e) {
                    s.encodePacket(e, t.supportsBinary, (function(n) {
                        const s = {};
                        !d && (e.options && (s.compress = e.options.compress), t.opts.perMessageDeflate) && ("string" == typeof n ? Buffer.byteLength(n) : n.length) < t.opts.perMessageDeflate.threshold && (s.compress = !1);
                        try {
                            d ? t.ws.send(n) : t.ws.send(n, s)
                        } catch (e) {
                            u("websocket closed before onclose event")
                        }--r || (t.emit("flush"), setTimeout((function() {
                            t.writable = !0, t.emit("drain")
                        }), 0))
                    }))
                }(e[n])
            }
            onClose() {
                n.prototype.onClose.call(this)
            }
            doClose() {
                void 0 !== this.ws && this.ws.close()
            }
            uri() {
                let e = this.query || {};
                const t = this.opts.secure ? "wss" : "ws";
                let r = "";
                return this.opts.port && ("wss" === t && 443 !== Number(this.opts.port) || "ws" === t && 80 !== Number(this.opts.port)) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = o()), this.supportsBinary || (e.b64 = 1), e = i.encode(e), e.length && (e = "?" + e), t + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + e
            }
            check() {
                return !(!c || "__initialize" in c && this.name === p.prototype.name)
            }
        }
        e.exports = p
    }, function(e, t, r) {
        const n = r(8);
        e.exports = {
            WebSocket: n.WebSocket || n.MozWebSocket,
            usingBrowserWebSocket: !0,
            defaultBinaryType: "arraybuffer"
        }
    }, function(e, t, r) {
        function n(e) {
            if (e) return function(e) {
                for (var t in n.prototype) e[t] = n.prototype[t];
                return e
            }(e)
        }
        e.exports = n, n.prototype.on = n.prototype.addEventListener = function(e, t) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
        }, n.prototype.once = function(e, t) {
            function r() {
                this.off(e, r), t.apply(this, arguments)
            }
            return r.fn = t, this.on(e, r), this
        }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function(e, t) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var r, n = this._callbacks["$" + e];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + e], this;
            for (var s = 0; s < n.length; s++)
                if ((r = n[s]) === t || r.fn === t) {
                    n.splice(s, 1);
                    break
                }
            return 0 === n.length && delete this._callbacks["$" + e], this
        }, n.prototype.emit = function(e) {
            this._callbacks = this._callbacks || {};
            for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            if (r) {
                n = 0;
                for (var s = (r = r.slice(0)).length; n < s; ++n) r[n].apply(this, t)
            }
            return this
        }, n.prototype.listeners = function(e) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
        }, n.prototype.hasListeners = function(e) {
            return !!this.listeners(e).length
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.reconstructPacket = t.deconstructPacket = void 0;
        const n = r(28);
        t.deconstructPacket = function(e) {
            const t = [],
                r = e.data,
                s = e;
            return s.data = function e(t, r) {
                if (!t) return t;
                if (n.isBinary(t)) {
                    const e = {
                        _placeholder: !0,
                        num: r.length
                    };
                    return r.push(t), e
                }
                if (Array.isArray(t)) {
                    const n = new Array(t.length);
                    for (let s = 0; s < t.length; s++) n[s] = e(t[s], r);
                    return n
                }
                if ("object" == typeof t && !(t instanceof Date)) {
                    const n = {};
                    for (const s in t) t.hasOwnProperty(s) && (n[s] = e(t[s], r));
                    return n
                }
                return t
            }(r, t), s.attachments = t.length, {
                packet: s,
                buffers: t
            }
        }, t.reconstructPacket = function(e, t) {
            return e.data = function e(t, r) {
                if (!t) return t;
                if (t && t._placeholder) return r[t.num];
                if (Array.isArray(t))
                    for (let n = 0; n < t.length; n++) t[n] = e(t[n], r);
                else if ("object" == typeof t)
                    for (const n in t) t.hasOwnProperty(n) && (t[n] = e(t[n], r));
                return t
            }(e.data, t), e.attachments = void 0, e
        }
    }, function(e, t, r) {
        t.formatArgs = function(t) {
            if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
            const r = "color: " + this.color;
            t.splice(1, 0, r, "color: inherit");
            let n = 0,
                s = 0;
            t[0].replace(/%[a-zA-Z%]/g, e => {
                "%%" !== e && (n++, "%c" === e && (s = n))
            }), t.splice(s, 0, r)
        }, t.save = function(e) {
            try {
                e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug")
            } catch (e) {}
        }, t.load = function() {
            let e;
            try {
                e = t.storage.getItem("debug")
            } catch (e) {}
            return !e && "undefined" != typeof process && "env" in process && (e = process.env.DEBUG), e
        }, t.useColors = function() {
            return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        }, t.storage = function() {
            try {
                return localStorage
            } catch (e) {}
        }(), t.destroy = (() => {
            let e = !1;
            return () => {
                e || (e = !0)
            }
        })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {}), e.exports = r(55)(t);
        const {
            formatters: n
        } = e.exports;
        n.j = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[UnexpectedJSONParseError]: " + e.message
            }
        }
    }, function(e, t, r) {
        e.exports = function(e) {
            function t(e) {
                let r, s = null;

                function i(...e) {
                    if (!i.enabled) return;
                    const n = i,
                        s = Number(new Date),
                        o = s - (r || s);
                    n.diff = o, n.prev = r, n.curr = s, r = s, e[0] = t.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
                    let a = 0;
                    e[0] = e[0].replace(/%([a-zA-Z%])/g, (r, s) => {
                        if ("%%" === r) return "%";
                        a++;
                        const i = t.formatters[s];
                        if ("function" == typeof i) {
                            const t = e[a];
                            r = i.call(n, t), e.splice(a, 1), a--
                        }
                        return r
                    }), t.formatArgs.call(n, e), (n.log || t.log).apply(n, e)
                }
                return i.namespace = e, i.useColors = t.useColors(), i.color = t.selectColor(e), i.extend = n, i.destroy = t.destroy, Object.defineProperty(i, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => null === s ? t.enabled(e) : s,
                    set: e => {
                        s = e
                    }
                }), "function" == typeof t.init && t.init(i), i
            }

            function n(e, r) {
                const n = t(this.namespace + (void 0 === r ? ":" : r) + e);
                return n.log = this.log, n
            }

            function s(e) {
                return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*")
            }
            return t.debug = t, t.default = t, t.coerce = function(e) {
                return e instanceof Error ? e.stack || e.message : e
            }, t.disable = function() {
                const e = [...t.names.map(s), ...t.skips.map(s).map(e => "-" + e)].join(",");
                return t.enable(""), e
            }, t.enable = function(e) {
                let r;
                t.save(e), t.names = [], t.skips = [];
                const n = ("string" == typeof e ? e : "").split(/[\s,]+/),
                    s = n.length;
                for (r = 0; r < s; r++) n[r] && ("-" === (e = n[r].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.substr(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
            }, t.enabled = function(e) {
                if ("*" === e[e.length - 1]) return !0;
                let r, n;
                for (r = 0, n = t.skips.length; r < n; r++)
                    if (t.skips[r].test(e)) return !1;
                for (r = 0, n = t.names.length; r < n; r++)
                    if (t.names[r].test(e)) return !0;
                return !1
            }, t.humanize = r(56), t.destroy = function() {}, Object.keys(e).forEach(r => {
                t[r] = e[r]
            }), t.names = [], t.skips = [], t.formatters = {}, t.selectColor = function(e) {
                let r = 0;
                for (let t = 0; t < e.length; t++) r = (r << 5) - r + e.charCodeAt(t), r |= 0;
                return t.colors[Math.abs(r) % t.colors.length]
            }, t.enable(t.load()), t
        }
    }, function(e, t) {
        var r = 1e3,
            n = 6e4,
            s = 60 * n,
            i = 24 * s;

        function o(e, t, r, n) {
            var s = t >= 1.5 * r;
            return Math.round(e / r) + " " + n + (s ? "s" : "")
        }
        e.exports = function(e, t) {
            t = t || {};
            var a, c, d = typeof e;
            if ("string" === d && e.length > 0) return function(e) {
                if (!((e = String(e)).length > 100)) {
                    var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
                    if (t) {
                        var o = parseFloat(t[1]);
                        switch ((t[2] || "ms").toLowerCase()) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                                return 315576e5 * o;
                            case "weeks":
                            case "week":
                            case "w":
                                return 6048e5 * o;
                            case "days":
                            case "day":
                            case "d":
                                return o * i;
                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                                return o * s;
                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                                return o * n;
                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                                return o * r;
                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                                return o;
                            default:
                                return
                        }
                    }
                }
            }(e);
            if ("number" === d && isFinite(e)) return t.long ? (a = e, (c = Math.abs(a)) >= i ? o(a, c, i, "day") : c >= s ? o(a, c, s, "hour") : c >= n ? o(a, c, n, "minute") : c >= r ? o(a, c, r, "second") : a + " ms") : function(e) {
                var t = Math.abs(e);
                return t >= i ? Math.round(e / i) + "d" : t >= s ? Math.round(e / s) + "h" : t >= n ? Math.round(e / n) + "m" : t >= r ? Math.round(e / r) + "s" : e + "ms"
            }(e);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
        }
    }, function(e, t) {
        function r(e) {
            e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0
        }
        e.exports = r, r.prototype.duration = function() {
            var e = this.ms * Math.pow(this.factor, this.attempts++);
            if (this.jitter) {
                var t = Math.random(),
                    r = Math.floor(t * this.jitter * e);
                e = 0 == (1 & Math.floor(10 * t)) ? e - r : e + r
            }
            return 0 | Math.min(e, this.max)
        }, r.prototype.reset = function() {
            this.attempts = 0
        }, r.prototype.setMin = function(e) {
            this.ms = e
        }, r.prototype.setMax = function(e) {
            this.max = e
        }, r.prototype.setJitter = function(e) {
            this.jitter = e
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        }), t.RTC_LOAD_TYPE = t.RUNTIME_MODE = t.OPERATION = t.HOT_PUSH_FROM = t.DEVICE_TYPE = t.REDIS_KEY = t.STRING = void 0, t.STRING = {
            BOX: "box",
            BROWSER: "browser",
            AUTO_HOT_PUSH: "autoHotPush",
            CLIENT: "client",
            RESOURCE: "resource",
            RESOURCES: "resources",
            HOT_RESOURCES: "hotResources",
            NO_RESOURCES: "noResources",
            SIDS: "sids",
            PRID: "prid",
            PRIDS: "prids",
            BP_NC_TRACKER: "bpNcTracker",
            CLIENT_NUM: "clientNum",
            LAST_ACTIVE_TIME: "lastActiveTime",
            URLS: "urls"
        }, t.REDIS_KEY = {
            SIDS_BOX: "sids:box",
            PRIDS_QUIT: "prids:quit",
            PRIDS_CONNECT: "prids:connect",
            PRIDS_LAST_ACTIVE_TIME: "prids:lastActiveTime",
            CONNECT_NUM_BOX: "connect:num:box",
            TOP_CID_LIST_SET_NAME: "topCIDListKey",
            TOP_AID_LIST_SET_NAME: "topAIDListKey",
            ENABLED_CID_LIST_SET_NAME: "enabledCIDListKey"
        }, t.DEVICE_TYPE = {
            BROWSER: 0,
            BOX: 1,
            AUTO_HOT_PUSH: 2
        }, t.HOT_PUSH_FROM = {
            HAND_HOT_PUSH: 1,
            AUTO_HOT_PUSH: 2
        }, t.OPERATION = {
            UPDATE: 1,
            ADD: 2,
            REMOVE: 3
        }, t.RUNTIME_MODE = {
            PROD: "production",
            DEV: "development"
        }, t.RTC_LOAD_TYPE = {
            SEND: 1,
            GET: 2
        }
    }, function(e, t, r) {
        var n = r(60),
            s = r(63);
        t.protocol = 5;
        var i = t.PacketType = {
                CONNECT: 0,
                DISCONNECT: 1,
                EVENT: 2,
                ACK: 3,
                CONNECT_ERROR: 4
            },
            o = Number.isInteger || function(e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            },
            a = function(e) {
                return "string" == typeof e
            },
            c = function(e) {
                return "[object Object]" === Object.prototype.toString.call(e)
            };

        function d() {}

        function l() {}
        d.prototype.encode = function(e) {
            return [n.encode(e)]
        }, s(l.prototype), l.prototype.add = function(e) {
            var t = n.decode(e);
            this.checkPacket(t), this.emit("decoded", t)
        }, l.prototype.checkPacket = function(e) {
            if (!(o(e.type) && e.type >= i.CONNECT && e.type <= i.CONNECT_ERROR)) throw new Error("invalid packet type");
            if (!a(e.nsp)) throw new Error("invalid namespace");
            if (! function(e) {
                    switch (e.type) {
                        case i.CONNECT:
                            return void 0 === e.data || c(e.data);
                        case i.DISCONNECT:
                            return void 0 === e.data;
                        case i.CONNECT_ERROR:
                            return a(e.data) || c(e.data);
                        default:
                            return Array.isArray(e.data)
                    }
                }(e)) throw new Error("invalid payload");
            if (void 0 !== e.id && !o(e.id)) throw new Error("invalid packet id")
        }, l.prototype.destroy = function() {}, t.Encoder = d, t.Decoder = l
    }, function(e, t, r) {
        t.encode = r(61), t.decode = r(62)
    }, function(e, t, r) {
        "use strict";

        function n(e, t, r) {
            for (var n = 0, s = 0, i = r.length; s < i; s++)(n = r.charCodeAt(s)) < 128 ? e.setUint8(t++, n) : n < 2048 ? (e.setUint8(t++, 192 | n >> 6), e.setUint8(t++, 128 | 63 & n)) : n < 55296 || n >= 57344 ? (e.setUint8(t++, 224 | n >> 12), e.setUint8(t++, 128 | n >> 6 & 63), e.setUint8(t++, 128 | 63 & n)) : (s++, n = 65536 + ((1023 & n) << 10 | 1023 & r.charCodeAt(s)), e.setUint8(t++, 240 | n >> 18), e.setUint8(t++, 128 | n >> 12 & 63), e.setUint8(t++, 128 | n >> 6 & 63), e.setUint8(t++, 128 | 63 & n))
        }
        e.exports = function(e) {
            var t = [],
                r = [],
                s = function e(t, r, n) {
                    var s = typeof n,
                        i = 0,
                        o = 0,
                        a = 0,
                        c = 0,
                        d = 0,
                        l = 0;
                    if ("string" === s) {
                        if ((d = function(e) {
                                for (var t = 0, r = 0, n = 0, s = e.length; n < s; n++)(t = e.charCodeAt(n)) < 128 ? r += 1 : t < 2048 ? r += 2 : t < 55296 || t >= 57344 ? r += 3 : (n++, r += 4);
                                return r
                            }(n)) < 32) t.push(160 | d), l = 1;
                        else if (d < 256) t.push(217, d), l = 2;
                        else if (d < 65536) t.push(218, d >> 8, d), l = 3;
                        else {
                            if (!(d < 4294967296)) throw new Error("String too long");
                            t.push(219, d >> 24, d >> 16, d >> 8, d), l = 5
                        }
                        return r.push({
                            _str: n,
                            _length: d,
                            _offset: t.length
                        }), l + d
                    }
                    if ("number" === s) return Math.floor(n) === n && isFinite(n) ? n >= 0 ? n < 128 ? (t.push(n), 1) : n < 256 ? (t.push(204, n), 2) : n < 65536 ? (t.push(205, n >> 8, n), 3) : n < 4294967296 ? (t.push(206, n >> 24, n >> 16, n >> 8, n), 5) : (a = n / Math.pow(2, 32) >> 0, c = n >>> 0, t.push(207, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 9) : n >= -32 ? (t.push(n), 1) : n >= -128 ? (t.push(208, n), 2) : n >= -32768 ? (t.push(209, n >> 8, n), 3) : n >= -2147483648 ? (t.push(210, n >> 24, n >> 16, n >> 8, n), 5) : (a = Math.floor(n / Math.pow(2, 32)), c = n >>> 0, t.push(211, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 9) : (t.push(203), r.push({
                        _float: n,
                        _length: 8,
                        _offset: t.length
                    }), 9);
                    if ("object" === s) {
                        if (null === n) return t.push(192), 1;
                        if (Array.isArray(n)) {
                            if ((d = n.length) < 16) t.push(144 | d), l = 1;
                            else if (d < 65536) t.push(220, d >> 8, d), l = 3;
                            else {
                                if (!(d < 4294967296)) throw new Error("Array too large");
                                t.push(221, d >> 24, d >> 16, d >> 8, d), l = 5
                            }
                            for (i = 0; i < d; i++) l += e(t, r, n[i]);
                            return l
                        }
                        if (n instanceof Date) {
                            var u = n.getTime();
                            return a = Math.floor(u / Math.pow(2, 32)), c = u >>> 0, t.push(215, 0, a >> 24, a >> 16, a >> 8, a, c >> 24, c >> 16, c >> 8, c), 10
                        }
                        if (n instanceof ArrayBuffer) {
                            if ((d = n.byteLength) < 256) t.push(196, d), l = 2;
                            else if (d < 65536) t.push(197, d >> 8, d), l = 3;
                            else {
                                if (!(d < 4294967296)) throw new Error("Buffer too large");
                                t.push(198, d >> 24, d >> 16, d >> 8, d), l = 5
                            }
                            return r.push({
                                _bin: n,
                                _length: d,
                                _offset: t.length
                            }), l + d
                        }
                        if ("function" == typeof n.toJSON) return e(t, r, n.toJSON());
                        var h = [],
                            p = "",
                            f = Object.keys(n);
                        for (i = 0, o = f.length; i < o; i++) "function" != typeof n[p = f[i]] && h.push(p);
                        if ((d = h.length) < 16) t.push(128 | d), l = 1;
                        else if (d < 65536) t.push(222, d >> 8, d), l = 3;
                        else {
                            if (!(d < 4294967296)) throw new Error("Object too large");
                            t.push(223, d >> 24, d >> 16, d >> 8, d), l = 5
                        }
                        for (i = 0; i < d; i++) l += e(t, r, p = h[i]), l += e(t, r, n[p]);
                        return l
                    }
                    if ("boolean" === s) return t.push(n ? 195 : 194), 1;
                    if ("undefined" === s) return t.push(212, 0, 0), 3;
                    throw new Error("Could not encode")
                }(t, r, e),
                i = new ArrayBuffer(s),
                o = new DataView(i),
                a = 0,
                c = 0,
                d = -1;
            r.length > 0 && (d = r[0]._offset);
            for (var l, u = 0, h = 0, p = 0, f = t.length; p < f; p++)
                if (o.setUint8(c + p, t[p]), p + 1 === d) {
                    if (u = (l = r[a])._length, h = c + d, l._bin)
                        for (var m = new Uint8Array(l._bin), g = 0; g < u; g++) o.setUint8(h + g, m[g]);
                    else l._str ? n(o, h, l._str) : void 0 !== l._float && o.setFloat64(h, l._float);
                    c += u, r[++a] && (d = r[a]._offset)
                }
            return i
        }
    }, function(e, t, r) {
        "use strict";

        function n(e) {
            if (this._offset = 0, e instanceof ArrayBuffer) this._buffer = e, this._view = new DataView(this._buffer);
            else {
                if (!ArrayBuffer.isView(e)) throw new Error("Invalid argument");
                this._buffer = e.buffer, this._view = new DataView(this._buffer, e.byteOffset, e.byteLength)
            }
        }
        n.prototype._array = function(e) {
            for (var t = new Array(e), r = 0; r < e; r++) t[r] = this._parse();
            return t
        }, n.prototype._map = function(e) {
            for (var t = {}, r = 0; r < e; r++) t[this._parse()] = this._parse();
            return t
        }, n.prototype._str = function(e) {
            var t = function(e, t, r) {
                for (var n = "", s = 0, i = t, o = t + r; i < o; i++) {
                    var a = e.getUint8(i);
                    if (0 != (128 & a))
                        if (192 != (224 & a))
                            if (224 != (240 & a)) {
                                if (240 != (248 & a)) throw new Error("Invalid byte " + a.toString(16));
                                (s = (7 & a) << 18 | (63 & e.getUint8(++i)) << 12 | (63 & e.getUint8(++i)) << 6 | (63 & e.getUint8(++i)) << 0) >= 65536 ? (s -= 65536, n += String.fromCharCode(55296 + (s >>> 10), 56320 + (1023 & s))) : n += String.fromCharCode(s)
                            } else n += String.fromCharCode((15 & a) << 12 | (63 & e.getUint8(++i)) << 6 | (63 & e.getUint8(++i)) << 0);
                    else n += String.fromCharCode((31 & a) << 6 | 63 & e.getUint8(++i));
                    else n += String.fromCharCode(a)
                }
                return n
            }(this._view, this._offset, e);
            return this._offset += e, t
        }, n.prototype._bin = function(e) {
            var t = this._buffer.slice(this._offset, this._offset + e);
            return this._offset += e, t
        }, n.prototype._parse = function() {
            var e, t = this._view.getUint8(this._offset++),
                r = 0,
                n = 0,
                s = 0,
                i = 0;
            if (t < 192) return t < 128 ? t : t < 144 ? this._map(15 & t) : t < 160 ? this._array(15 & t) : this._str(31 & t);
            if (t > 223) return -1 * (255 - t + 1);
            switch (t) {
                case 192:
                    return null;
                case 194:
                    return !1;
                case 195:
                    return !0;
                case 196:
                    return r = this._view.getUint8(this._offset), this._offset += 1, this._bin(r);
                case 197:
                    return r = this._view.getUint16(this._offset), this._offset += 2, this._bin(r);
                case 198:
                    return r = this._view.getUint32(this._offset), this._offset += 4, this._bin(r);
                case 199:
                    return r = this._view.getUint8(this._offset), n = this._view.getInt8(this._offset + 1), this._offset += 2, [n, this._bin(r)];
                case 200:
                    return r = this._view.getUint16(this._offset), n = this._view.getInt8(this._offset + 2), this._offset += 3, [n, this._bin(r)];
                case 201:
                    return r = this._view.getUint32(this._offset), n = this._view.getInt8(this._offset + 4), this._offset += 5, [n, this._bin(r)];
                case 202:
                    return e = this._view.getFloat32(this._offset), this._offset += 4, e;
                case 203:
                    return e = this._view.getFloat64(this._offset), this._offset += 8, e;
                case 204:
                    return e = this._view.getUint8(this._offset), this._offset += 1, e;
                case 205:
                    return e = this._view.getUint16(this._offset), this._offset += 2, e;
                case 206:
                    return e = this._view.getUint32(this._offset), this._offset += 4, e;
                case 207:
                    return s = this._view.getUint32(this._offset) * Math.pow(2, 32), i = this._view.getUint32(this._offset + 4), this._offset += 8, s + i;
                case 208:
                    return e = this._view.getInt8(this._offset), this._offset += 1, e;
                case 209:
                    return e = this._view.getInt16(this._offset), this._offset += 2, e;
                case 210:
                    return e = this._view.getInt32(this._offset), this._offset += 4, e;
                case 211:
                    return s = this._view.getInt32(this._offset) * Math.pow(2, 32), i = this._view.getUint32(this._offset + 4), this._offset += 8, s + i;
                case 212:
                    return n = this._view.getInt8(this._offset), this._offset += 1, 0 === n ? void(this._offset += 1) : [n, this._bin(1)];
                case 213:
                    return n = this._view.getInt8(this._offset), this._offset += 1, [n, this._bin(2)];
                case 214:
                    return n = this._view.getInt8(this._offset), this._offset += 1, [n, this._bin(4)];
                case 215:
                    return n = this._view.getInt8(this._offset), this._offset += 1, 0 === n ? (s = this._view.getInt32(this._offset) * Math.pow(2, 32), i = this._view.getUint32(this._offset + 4), this._offset += 8, new Date(s + i)) : [n, this._bin(8)];
                case 216:
                    return n = this._view.getInt8(this._offset), this._offset += 1, [n, this._bin(16)];
                case 217:
                    return r = this._view.getUint8(this._offset), this._offset += 1, this._str(r);
                case 218:
                    return r = this._view.getUint16(this._offset), this._offset += 2, this._str(r);
                case 219:
                    return r = this._view.getUint32(this._offset), this._offset += 4, this._str(r);
                case 220:
                    return r = this._view.getUint16(this._offset), this._offset += 2, this._array(r);
                case 221:
                    return r = this._view.getUint32(this._offset), this._offset += 4, this._array(r);
                case 222:
                    return r = this._view.getUint16(this._offset), this._offset += 2, this._map(r);
                case 223:
                    return r = this._view.getUint32(this._offset), this._offset += 4, this._map(r)
            }
            throw new Error("Could not parse")
        }, e.exports = function(e) {
            var t = new n(e),
                r = t._parse();
            if (t._offset !== e.byteLength) throw new Error(e.byteLength - t._offset + " trailing bytes");
            return r
        }
    }, function(e, t, r) {
        function n(e) {
            if (e) return function(e) {
                for (var t in n.prototype) e[t] = n.prototype[t];
                return e
            }(e)
        }
        e.exports = n, n.prototype.on = n.prototype.addEventListener = function(e, t) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
        }, n.prototype.once = function(e, t) {
            function r() {
                this.off(e, r), t.apply(this, arguments)
            }
            return r.fn = t, this.on(e, r), this
        }, n.prototype.off = n.prototype.removeListener = n.prototype.removeAllListeners = n.prototype.removeEventListener = function(e, t) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var r, n = this._callbacks["$" + e];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + e], this;
            for (var s = 0; s < n.length; s++)
                if ((r = n[s]) === t || r.fn === t) {
                    n.splice(s, 1);
                    break
                }
            return 0 === n.length && delete this._callbacks["$" + e], this
        }, n.prototype.emit = function(e) {
            this._callbacks = this._callbacks || {};
            for (var t = new Array(arguments.length - 1), r = this._callbacks["$" + e], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            if (r) {
                n = 0;
                for (var s = (r = r.slice(0)).length; n < s; ++n) r[n].apply(this, t)
            }
            return this
        }, n.prototype.listeners = function(e) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
        }, n.prototype.hasListeners = function(e) {
            return !!this.listeners(e).length
        }
    }, function(e, t, r) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
            value: !0
        });
        const n = r(0),
            s = n.__importDefault(r(10)),
            i = n.__importDefault(r(3)),
            o = n.__importDefault(r(2)),
            a = n.__importDefault(r(6)),
            c = n.__importDefault(r(13));
        class d {
            constructor(e, t, r, n, s, i) {
                this.isOfferPeer = !0, this.isSameIP = !1, this.maxMessageSize = 64e3, this.receivedDataByte = 0, this.isDestroyed = !1, this.stateRTCStatistic = {}, this.openTimeoutTime = 2e3, this.answerTimeoutTime = 5e3, this.hasLocalDescription = !1, this.hasRemoteDescription = !1, this.hasReceivedCandidate = !1, this.hasAddCandidateSuccess = !1, this.events = new c.default, this.sdk = e, this.socketController = t, this.cPeerSocketID = r, this.isOfferPeer = n, this.isSameIP = s, this.path = i, this.sdk.state.rtcStatistic || (this.sdk.state.rtcStatistic = {}), this.stateRTCStatistic = this.sdk.state.rtcStatistic, this.socketController.on(o.default.SOCKET_MESSAGE, this.onSocketMessage), this.init()
            }
            getGetDataParam() {
                return this.getDataParam
            }
            get dataChannelState() {
                var e;
                return null === (e = this.dataChannel) || void 0 === e ? void 0 : e.readyState
            }
            init() {
                var e;
                i.default.getInstance().log(`init ${this.path} webRTCController -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), this.peerConnection = new RTCPeerConnection({
                    iceServers: [{
                        urls: ["stun:web-player-tracker.biliapi.net:3478", "stun:120.92.137.82:3478", "stun:120.92.137.240:3478"]
                    }]
                }), this.isOfferPeer ? (this.stateRTCStatistic.offerInit = this.stateRTCStatistic.offerInit ? this.stateRTCStatistic.offerInit + 1 : 1, this.dataChannel = this.peerConnection.createDataChannel("sendDataChannel"), this.openTimeoutTimer = window.setTimeout(() => {
                    var e, t, r, n, s;
                    const i = {
                        range: (null === (e = this.getDataInternalParam) || void 0 === e ? void 0 : e.rangeStart) + "-" + (null === (t = this.getDataInternalParam) || void 0 === t ? void 0 : t.rangeEnd),
                        from: 0,
                        path: null === (r = this.getDataInternalParam) || void 0 === r ? void 0 : r.path,
                        getDataTime: Date.now() - (null === (n = this.getDataInternalParam) || void 0 === n ? void 0 : n.startTime),
                        data: null === (s = this.receivedU8Buffer) || void 0 === s ? void 0 : s.buffer,
                        gotDataByte: this.receivedDataByte,
                        rtcDataChannelState: this.dataChannelState,
                        cPeerSID: this.cPeerSocketID
                    };
                    let o = a.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT,
                        c = "webrtc data channel open timeout";
                    this.hasLocalDescription ? this.hasRemoteDescription ? this.hasReceivedCandidate ? this.hasAddCandidateSuccess || (o = a.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_ACS, c = "no addCandidateSuccess webrtc data channel open timeout") : (o = a.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_RC, c = "no receivedCandidate webrtc data channel open timeout") : (o = a.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_RDP, c = "no remoteDescription webrtc data channel open timeout") : (o = a.default.RESPONSE_CODE.WEBRTC_OPEN_TIMEOUT_BY_NO_LDP, c = "no localDescription webrtc data channel open timeout"), this.getDataOnReject && this.getDataOnReject({
                        code: o,
                        msg: c,
                        responseData: i
                    })
                }, this.openTimeoutTime)) : (this.answerTimeoutTimer = window.setTimeout(() => {
                    this.trigger(o.default.WEBRTC_ANSWER_TIMEOUT, this.cPeerSocketID)
                }, this.answerTimeoutTime), this.stateRTCStatistic.answerInit = this.stateRTCStatistic.answerInit ? this.stateRTCStatistic.answerInit + 1 : 1, this.peerConnection.ondatachannel = e => {
                    i.default.getInstance().log(`${this.path} webRTCController received dataChannel -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), this.dataChannel = e.channel, this.dataChannelBindEvent()
                }), this.peerConnection.onicecandidate = e => {
                    var t, r;
                    if ((!this.dataChannel || "connecting" === (null === (t = this.dataChannel) || void 0 === t ? void 0 : t.readyState)) && e.candidate) {
                        if (this.filterIceCandidate(e.candidate)) return;
                        let t = {
                            type: "candidate",
                            data: JSON.stringify(e.candidate)
                        };
                        null === (r = this.socketController) || void 0 === r || r.sendMessage(this.cPeerSocketID, t)
                    }
                }, this.isOfferPeer && this.dataChannelBindEvent(), null === (e = this.socketController) || void 0 === e || e.reportRTCState(this.cPeerSocketID, this.isOfferPeer, a.default.RTC_STATE_CODE.INIT)
            }
            onSocketMessage(e) {
                var t, r, n, s, o, a, c, d;
                if (e && e.fromSocketID && e.fromSocketID === this.cPeerSocketID && e.data)
                    if ("offer" === e.type);
                    else if ("answer" === e.type) this.isOfferPeer ? (i.default.getInstance().log(`${this.path} webRTCController received answer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), null === (t = this.peerConnection) || void 0 === t || t.setRemoteDescription(new RTCSessionDescription(JSON.parse(e.data))).then(() => {
                    this.hasRemoteDescription = !0, i.default.getInstance().log(`${this.path} webRTCController received answer setRemoteDescription success from createOffer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                }).catch(e => {
                    i.default.getInstance().warn(`${this.path} webRTCController received answer setRemoteDescription error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, errorMessage: ${""+e}`)
                })) : i.default.getInstance().warn(`${this.path} webRTCController answer peer received answer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`);
                else if ("candidate" === e.type) {
                    if ("open" === (null === (r = this.dataChannel) || void 0 === r ? void 0 : r.readyState)) return;
                    this.hasReceivedCandidate = !0;
                    let t = JSON.parse(e.data),
                        s = new RTCIceCandidate(t);
                    null === (n = this.peerConnection) || void 0 === n || n.addIceCandidate(s).then(() => {
                        this.isDestroyed || (this.hasAddCandidateSuccess = !0)
                    }, e => {
                        this.isDestroyed || i.default.getInstance().warn(`${this.path} webRTCController addIceCandidate error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, error: ` + e.toString())
                    }).catch(e => {
                        this.isDestroyed || i.default.getInstance().warn(`${this.path} webRTCController addIceCandidate error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, error: ` + e)
                    })
                } else if ("getData" === e.type) {
                    let t = JSON.parse(e.data);
                    this.getDataParam = t, this.getDataFromDB()
                } else if ("getDataFail" === e.type) {
                    const t = null == e ? void 0 : e.code,
                        r = {
                            range: (null === (s = this.getDataInternalParam) || void 0 === s ? void 0 : s.rangeStart) + "-" + (null === (o = this.getDataInternalParam) || void 0 === o ? void 0 : o.rangeEnd),
                            from: 0,
                            path: null === (a = this.getDataInternalParam) || void 0 === a ? void 0 : a.path,
                            getDataTime: Date.now() - (null === (c = this.getDataInternalParam) || void 0 === c ? void 0 : c.startTime),
                            data: null === (d = this.receivedU8Buffer) || void 0 === d ? void 0 : d.buffer,
                            gotDataByte: this.receivedDataByte,
                            rtcDataChannelState: this.dataChannelState,
                            cPeerSID: this.cPeerSocketID
                        };
                    this.getDataOnReject && this.getDataOnReject({
                        code: t,
                        msg: "answer peer get data fail",
                        responseData: r
                    }), i.default.getInstance().log(`answer peer get data fail -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                }
            }
            dataChannelBindEvent() {
                this.dataChannel.onmessage = e => {
                    var t, r, n, s, o, a, c, d, l, u;
                    if (!this.getDataInternalParam) return void(this.getDataOnReject && this.getDataOnReject({
                        code: -1,
                        msg: "webRTC onmessage no getDataInternalParam"
                    }));
                    const h = this.getDataInternalParam.rangeEnd - this.getDataInternalParam.rangeStart + 1;
                    if ("string" == typeof e.data) {
                        const r = parseInt(e.data, 10);
                        return r !== h ? (i.default.getInstance().warn(`${this.path} webRTCController received invalid totalSize -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + r), void(this.getDataOnReject && this.getDataOnReject({
                            code: -1,
                            msg: this.path + " webRTCController received invalid totalSize"
                        }))) : this.receivedU8Buffer ? (i.default.getInstance().warn(`${this.path} webRTCController received totalSize after receivedU8Buffer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + r), void(this.getDataOnReject && this.getDataOnReject({
                            code: -1,
                            msg: this.path + " webRTCController received totalSize after receivedU8Buffer"
                        }))) : (this.receivedU8Buffer = new Uint8Array(parseInt(e.data, 10)), this.receivedDataByte = 0, void i.default.getInstance().log(`${this.path} webRTCController received totalSize -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + (null === (t = this.receivedU8Buffer) || void 0 === t ? void 0 : t.byteLength)))
                    }
                    if (!this.receivedU8Buffer) return i.default.getInstance().warn(`${this.path} webRTCController received data before received totalSize -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), void(this.getDataOnReject && this.getDataOnReject({
                        code: -1,
                        msg: this.path + " webRTCController received data before received totalSize"
                    }));
                    let p = new Uint8Array(e.data);
                    if (!p.byteLength) return i.default.getInstance().warn(`${this.path} webRTCController received 0 byte data -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), void(this.getDataOnReject && this.getDataOnReject({
                        code: -1,
                        msg: this.path + " webRTCController received 0 byte data"
                    }));
                    if (this.receivedDataByte + p.byteLength > h) return i.default.getInstance().warn(`${this.path} webRTCController received data more than needed -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), void(this.getDataOnReject && this.getDataOnReject({
                        code: -1,
                        msg: this.path + " webRTCController received data more than needed"
                    }));
                    if (this.receivedU8Buffer.set(p, this.receivedDataByte), this.receivedDataByte += p.byteLength, this.receivedDataByte === (null === (r = this.receivedU8Buffer) || void 0 === r ? void 0 : r.byteLength)) {
                        if (i.default.getInstance().log(`${this.path} webRTCController received all data -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + (null === (n = this.receivedU8Buffer) || void 0 === n ? void 0 : n.byteLength)), (null === (s = this.receivedU8Buffer) || void 0 === s ? void 0 : s.byteLength) !== h) {
                            const e = {
                                range: (null === (o = this.getDataInternalParam) || void 0 === o ? void 0 : o.rangeStart) + "-" + (null === (a = this.getDataInternalParam) || void 0 === a ? void 0 : a.rangeEnd),
                                from: 0,
                                path: null === (c = this.getDataInternalParam) || void 0 === c ? void 0 : c.path,
                                getDataTime: Date.now() - (null === (d = this.getDataInternalParam) || void 0 === d ? void 0 : d.startTime),
                                data: null === (l = this.receivedU8Buffer) || void 0 === l ? void 0 : l.buffer,
                                gotDataByte: this.receivedDataByte,
                                rtcDataChannelState: this.dataChannelState,
                                cPeerSID: this.cPeerSocketID
                            };
                            return this.getDataOnReject && this.getDataOnReject({
                                code: -1,
                                msg: "webRTC get data not enough",
                                responseData: e
                            }), void i.default.getInstance().warn(`${this.path} webRTCController received data not enough -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + (null === (u = this.receivedU8Buffer) || void 0 === u ? void 0 : u.byteLength))
                        }
                        const e = {
                            range: this.getDataInternalParam.rangeStart + "-" + this.getDataInternalParam.rangeEnd,
                            from: 1,
                            path: this.getDataInternalParam.path,
                            getDataTime: Date.now() - this.getDataInternalParam.startTime,
                            data: this.receivedU8Buffer.buffer,
                            gotDataByte: this.receivedDataByte,
                            rtcDataChannelState: this.dataChannelState,
                            cPeerSID: this.cPeerSocketID
                        };
                        this.getDataOnResolve && this.getDataOnResolve({
                            code: 1,
                            msg: "success",
                            responseData: e
                        }), this.stateRTCStatistic.getSuccess = ++this.stateRTCStatistic.getSuccess || 1
                    }
                }, this.dataChannel.onopen = () => {
                    var e, t, r;
                    if ("open" === (null === (e = this.dataChannel) || void 0 === e ? void 0 : e.readyState)) {
                        const e = this.peerConnection.sctp;
                        if (e && e.maxMessageSize && (this.maxMessageSize = e.maxMessageSize), i.default.getInstance().log(`${this.path} webRTCController dataChannel open -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, maxMessageSize: ` + this.maxMessageSize), this.isOfferPeer && this.getDataParam) {
                            let e = {
                                type: "getData",
                                data: JSON.stringify(this.getDataParam)
                            };
                            null === (t = this.socketController) || void 0 === t || t.sendMessage(this.cPeerSocketID, e)
                        }
                        this.getDataFromDB(), null === (r = this.socketController) || void 0 === r || r.reportRTCState(this.cPeerSocketID, this.isOfferPeer, a.default.RTC_STATE_CODE.DATA_CHANNEL_OPEN_SUCCESS), this.isOfferPeer ? (this.stateRTCStatistic.offerDataChannelOpen = this.stateRTCStatistic.offerDataChannelOpen ? this.stateRTCStatistic.offerDataChannelOpen + 1 : 1, this.openTimeoutTimer && (window.clearTimeout(this.openTimeoutTimer), this.openTimeoutTimer = 0)) : this.stateRTCStatistic.answerDataChannelOpen = this.stateRTCStatistic.answerDataChannelOpen ? this.stateRTCStatistic.answerDataChannelOpen + 1 : 1
                    }
                }, this.dataChannel.onclose = () => {
                    this.trigger(o.default.WEBRTC_CHANNEL_CLOSE, this.path), i.default.getInstance().log(`${this.path} webRTCController dataChannel closed -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                }
            }
            getDataFromDB() {
                var e, t, r;
                !this.isOfferPeer && this.getDataParam && "open" === (null === (e = this.dataChannel) || void 0 === e ? void 0 : e.readyState) && (null === (r = null === (t = this.sdk) || void 0 === t ? void 0 : t.main) || void 0 === r || r.getData(this.getDataParam).then(e => {
                    var t;
                    this.isDestroyed || (i.default.getInstance().log(`answer peer getData success -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), this.sendData(null === (t = null == e ? void 0 : e.responseData) || void 0 === t ? void 0 : t.data))
                }, e => {
                    var t;
                    if (this.isDestroyed) return;
                    const r = null == e ? void 0 : e.code;
                    let n = {
                        type: "getDataFail",
                        data: JSON.stringify(this.getDataParam),
                        code: r
                    };
                    null === (t = this.socketController) || void 0 === t || t.sendMessage(this.cPeerSocketID, n), i.default.getInstance().log(`answer peer getData fail -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                }))
            }
            dataChannelRemoveEvent() {
                this.dataChannel && (this.dataChannel.onmessage = null, this.dataChannel.onopen = null, this.dataChannel.onclose = null)
            }
            createOffer() {
                var e;
                null === (e = this.peerConnection) || void 0 === e || e.createOffer().then(e => {
                    var t, r;
                    if (this.isDestroyed) return;
                    null === (t = this.peerConnection) || void 0 === t || t.setLocalDescription(e).then(() => {
                        this.hasLocalDescription = !0, i.default.getInstance().log(`${this.path} webRTCController setLocalDescription success from createOffer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                    }).catch(e => {
                        i.default.getInstance().warn(`${this.path} webRTCController createOffer setLocalDescription error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, errorMessage: ${""+e}`)
                    }), i.default.getInstance().log(`${this.path} webRTCController setLocalDescription from createOffer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`);
                    let n = {
                        type: "offer",
                        data: JSON.stringify(e),
                        isSameIP: this.isSameIP
                    };
                    null === (r = this.socketController) || void 0 === r || r.sendMessage(this.cPeerSocketID, n)
                }, e => {
                    this.isDestroyed || i.default.getInstance().warn(`${this.path} webRTCController createOffer error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, error: ` + e.toString())
                })
            }
            getData(e) {
                return new Promise((t, r) => {
                    var n, s, i;
                    this.reset(), this.getDataParam = e, this.getDataOnResolve = t, this.getDataOnReject = r;
                    let o = {
                        type: "getData",
                        data: JSON.stringify(e)
                    };
                    null === (n = this.socketController) || void 0 === n || n.sendMessage(this.cPeerSocketID, o), this.getDataInternalParam = null === (i = null === (s = this.sdk) || void 0 === s ? void 0 : s.main) || void 0 === i ? void 0 : i.handleDataParam("get", this.getDataParam), this.getDataInternalParam || this.getDataOnReject && this.getDataOnReject({
                        code: -1,
                        msg: "webRTC getData data param invalid"
                    })
                })
            }
            reset() {
                this.receivedDataByte = 0, this.receivedU8Buffer = null
            }
            createAnswer(e) {
                e && this.peerConnection && (this.peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(e))).then(() => {
                    this.hasRemoteDescription = !0, i.default.getInstance().log(`${this.path} webRTCController createAnswer setRemoteDescription success from createOffer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                }).catch(e => {
                    i.default.getInstance().warn(`${this.path} webRTCController createAnswer setRemoteDescription error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, errorMessage: ${""+e}`)
                }), this.peerConnection.createAnswer().then(e => {
                    var t, r;
                    if (this.isDestroyed) return;
                    null === (t = this.peerConnection) || void 0 === t || t.setLocalDescription(e).then(() => {
                        this.hasLocalDescription = !0, i.default.getInstance().log(`${this.path} webRTCController setLocalDescription success from createAnswer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`)
                    }).catch(e => {
                        i.default.getInstance().warn(`${this.path} webRTCController createAnswer setLocalDescription error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, errorMessage: ${""+e}`)
                    }), i.default.getInstance().log(`${this.path} webRTCController setLocalDescription from createAnswer -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`);
                    let n = {
                        type: "answer",
                        data: JSON.stringify(e)
                    };
                    null === (r = this.socketController) || void 0 === r || r.sendMessage(this.cPeerSocketID, n)
                }, e => {
                    this.isDestroyed || i.default.getInstance().warn(`${this.path} webRTCController createAnswer error -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, error: ` + e.toString())
                }))
            }
            sendData(e) {
                var t;
                if (!(null == e ? void 0 : e.byteLength) || "open" !== (null === (t = this.dataChannel) || void 0 === t ? void 0 : t.readyState)) return;
                const r = e.byteLength,
                    n = r / this.maxMessageSize;
                i.default.getInstance().log(`${this.path} webRTCController sendData -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}, totalSize: ` + r), this.dataChannel.send("" + r);
                for (let t = 0; t < n; t++) {
                    let r = t * this.maxMessageSize,
                        n = (t + 1) * this.maxMessageSize;
                    this.dataChannel.send(e.slice(r, n))
                }
                this.stateRTCStatistic.sendSuccess = ++this.stateRTCStatistic.sendSuccess || 1
            }
            getReceivedU8Buffer() {
                return this.receivedU8Buffer
            }
            getReceivedDataByte() {
                return this.receivedDataByte
            }
            on(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.on(e, t)
            }
            off(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.off(e, t)
            }
            trigger(e, t) {
                var r;
                null === (r = this.events) || void 0 === r || r.trigger(e, t)
            }
            filterIceCandidate(e) {
                if (this.isSameIP) return !1;
                try {
                    if ("host" === (null == e ? void 0 : e.type)) return !0
                } catch (e) {
                    i.default.getInstance().warn("filterIceCandidate filter error: " + e)
                }
                return !1
            }
            destroy() {
                i.default.getInstance().log(`${this.path} webRTCController destroy -- cPeerSocketID: ${this.cPeerSocketID}, isOfferPeer: ${this.isOfferPeer}`), this.isDestroyed = !0, this.isOfferPeer = !0, this.maxMessageSize = 64e3, this.getDataParam = null, this.getDataInternalParam = null, this.receivedDataByte = 0, this.receivedU8Buffer = null, this.hasLocalDescription = !1, this.hasRemoteDescription = !1, this.hasReceivedCandidate = !1, this.hasAddCandidateSuccess = !1, this.openTimeoutTimer && (window.clearTimeout(this.openTimeoutTimer), this.openTimeoutTimer = 0), this.answerTimeoutTimer && (window.clearTimeout(this.answerTimeoutTimer), this.answerTimeoutTimer = 0), this.getDataOnResolve = this.getDataOnReject = null, this.stateRTCStatistic = {}, this.cPeerSocketID = "", this.socketController && (this.socketController.off(o.default.SOCKET_MESSAGE, this.onSocketMessage), this.socketController = null), this.sdk = null, this.dataChannel && (this.dataChannelRemoveEvent(), this.dataChannel.close(), this.dataChannel = null), this.peerConnection && (this.peerConnection.ondatachannel = null, this.peerConnection.onicecandidate = null, this.peerConnection.close(), this.peerConnection = null), this.events && (this.events.destroy(), this.events = null)
            }
        }
        n.__decorate([s.default], d.prototype, "onSocketMessage", null), t.default = d
    }, function(e, t, r) {
        "use strict";
        r.r(t);
        var n = {};
        r.r(n), r.d(n, "shimGetUserMedia", (function() {
            return b
        })), r.d(n, "shimGetDisplayMedia", (function() {
            return S
        })), r.d(n, "shimMediaStream", (function() {
            return P
        })), r.d(n, "shimOnTrack", (function() {
            return T
        })), r.d(n, "shimGetSendersWithDtmf", (function() {
            return _
        })), r.d(n, "shimGetStats", (function() {
            return R
        })), r.d(n, "shimSenderReceiverGetStats", (function() {
            return D
        })), r.d(n, "shimAddTrackRemoveTrackWithNative", (function() {
            return k
        })), r.d(n, "shimAddTrackRemoveTrack", (function() {
            return E
        })), r.d(n, "shimPeerConnection", (function() {
            return w
        })), r.d(n, "fixNegotiationNeeded", (function() {
            return O
        }));
        var s = {};
        r.r(s), r.d(s, "shimGetUserMedia", (function() {
            return x
        })), r.d(s, "shimGetDisplayMedia", (function() {
            return A
        })), r.d(s, "shimPeerConnection", (function() {
            return B
        })), r.d(s, "shimReplaceTrack", (function() {
            return M
        }));
        var i = {};
        r.r(i), r.d(i, "shimGetUserMedia", (function() {
            return j
        })), r.d(i, "shimGetDisplayMedia", (function() {
            return L
        })), r.d(i, "shimOnTrack", (function() {
            return F
        })), r.d(i, "shimPeerConnection", (function() {
            return U
        })), r.d(i, "shimSenderGetStats", (function() {
            return G
        })), r.d(i, "shimReceiverGetStats", (function() {
            return $
        })), r.d(i, "shimRemoveStream", (function() {
            return z
        })), r.d(i, "shimRTCDataChannel", (function() {
            return V
        })), r.d(i, "shimAddTransceiver", (function() {
            return K
        })), r.d(i, "shimGetParameters", (function() {
            return W
        })), r.d(i, "shimCreateOffer", (function() {
            return q
        })), r.d(i, "shimCreateAnswer", (function() {
            return J
        }));
        var o = {};
        r.r(o), r.d(o, "shimLocalStreamsAPI", (function() {
            return Y
        })), r.d(o, "shimRemoteStreamsAPI", (function() {
            return H
        })), r.d(o, "shimCallbacksAPI", (function() {
            return Z
        })), r.d(o, "shimGetUserMedia", (function() {
            return X
        })), r.d(o, "shimConstraints", (function() {
            return Q
        })), r.d(o, "shimRTCIceServerUrls", (function() {
            return ee
        })), r.d(o, "shimTrackEventTransceiver", (function() {
            return te
        })), r.d(o, "shimCreateOfferLegacy", (function() {
            return re
        })), r.d(o, "shimAudioContext", (function() {
            return ne
        }));
        var a = {};
        r.r(a), r.d(a, "shimRTCIceCandidate", (function() {
            return oe
        })), r.d(a, "shimMaxMessageSize", (function() {
            return ae
        })), r.d(a, "shimSendThrowTypeError", (function() {
            return ce
        })), r.d(a, "shimConnectionState", (function() {
            return de
        })), r.d(a, "removeAllowExtmapMixed", (function() {
            return le
        }));
        let c = !0,
            d = !0;

        function l(e, t, r) {
            const n = e.match(t);
            return n && n.length >= r && parseInt(n[r], 10)
        }

        function u(e, t, r) {
            if (!e.RTCPeerConnection) return;
            const n = e.RTCPeerConnection.prototype,
                s = n.addEventListener;
            n.addEventListener = function(e, n) {
                if (e !== t) return s.apply(this, arguments);
                const i = e => {
                    const t = r(e);
                    t && (n.handleEvent ? n.handleEvent(t) : n(t))
                };
                return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(n, i), s.apply(this, [e, i])
            };
            const i = n.removeEventListener;
            n.removeEventListener = function(e, r) {
                if (e !== t || !this._eventMap || !this._eventMap[t]) return i.apply(this, arguments);
                if (!this._eventMap[t].has(r)) return i.apply(this, arguments);
                const n = this._eventMap[t].get(r);
                return this._eventMap[t].delete(r), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, i.apply(this, [e, n])
            }, Object.defineProperty(n, "on" + t, {
                get() {
                    return this["_on" + t]
                },
                set(e) {
                    this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                },
                enumerable: !0,
                configurable: !0
            })
        }

        function h(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (c = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
        }

        function p(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (d = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
        }

        function f() {
            if ("object" == typeof window) {
                if (c) return;
                "undefined" != typeof console && console.log
            }
        }

        function m(e) {
            const t = {
                browser: null,
                version: null
            };
            if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
            const {
                navigator: r
            } = e;
            if (r.mozGetUserMedia) t.browser = "firefox", t.version = l(r.userAgent, /Firefox\/(\d+)\./, 1);
            else if (r.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = l(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = l(r.userAgent, /Edge\/(\d+).(\d+)$/, 2);
            else {
                if (!e.RTCPeerConnection || !r.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                t.browser = "safari", t.version = l(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
            }
            return t
        }

        function g(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }

        function v(e) {
            return g(e) ? Object.keys(e).reduce((function(t, r) {
                const n = g(e[r]),
                    s = n ? v(e[r]) : e[r],
                    i = n && !Object.keys(s).length;
                return void 0 === s || i ? t : Object.assign(t, {
                    [r]: s
                })
            }), {}) : e
        }

        function y(e, t, r) {
            const n = r ? "outbound-rtp" : "inbound-rtp",
                s = new Map;
            if (null === t) return s;
            const i = [];
            return e.forEach(e => {
                "track" === e.type && e.trackIdentifier === t.id && i.push(e)
            }), i.forEach(t => {
                e.forEach(r => {
                    r.type === n && r.trackId === t.id && function e(t, r, n) {
                        r && !n.has(r.id) && (n.set(r.id, r), Object.keys(r).forEach(s => {
                            s.endsWith("Id") ? e(t, t.get(r[s]), n) : s.endsWith("Ids") && r[s].forEach(r => {
                                e(t, t.get(r), n)
                            })
                        }))
                    }(e, r, s)
                })
            }), s
        }
        const C = f;

        function b(e) {
            const t = e && e.navigator;
            if (!t.mediaDevices) return;
            const r = m(e),
                n = function(e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    const t = {};
                    return Object.keys(e).forEach(r => {
                        if ("require" === r || "advanced" === r || "mediaSource" === r) return;
                        const n = "object" == typeof e[r] ? e[r] : {
                            ideal: e[r]
                        };
                        void 0 !== n.exact && "number" == typeof n.exact && (n.min = n.max = n.exact);
                        const s = function(e, t) {
                            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                        };
                        if (void 0 !== n.ideal) {
                            t.optional = t.optional || [];
                            let e = {};
                            "number" == typeof n.ideal ? (e[s("min", r)] = n.ideal, t.optional.push(e), e = {}, e[s("max", r)] = n.ideal, t.optional.push(e)) : (e[s("", r)] = n.ideal, t.optional.push(e))
                        }
                        void 0 !== n.exact && "number" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[s("", r)] = n.exact) : ["min", "max"].forEach(e => {
                            void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[s(e, r)] = n[e])
                        })
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                s = function(e, s) {
                    if (r.version >= 61) return s(e);
                    if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                        const t = function(e, t, r) {
                            t in e && !(r in e) && (e[r] = e[t], delete e[t])
                        };
                        t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = n(e.audio)
                    }
                    if (e && "object" == typeof e.video) {
                        let i = e.video.facingMode;
                        i = i && ("object" == typeof i ? i : {
                            ideal: i
                        });
                        const o = r.version < 66;
                        if (i && ("user" === i.exact || "environment" === i.exact || "user" === i.ideal || "environment" === i.ideal) && (!t.mediaDevices.getSupportedConstraints || !t.mediaDevices.getSupportedConstraints().facingMode || o)) {
                            let r;
                            if (delete e.video.facingMode, "environment" === i.exact || "environment" === i.ideal ? r = ["back", "rear"] : "user" !== i.exact && "user" !== i.ideal || (r = ["front"]), r) return t.mediaDevices.enumerateDevices().then(t => {
                                let o = (t = t.filter(e => "videoinput" === e.kind)).find(e => r.some(t => e.label.toLowerCase().includes(t)));
                                return !o && t.length && r.includes("back") && (o = t[t.length - 1]), o && (e.video.deviceId = i.exact ? {
                                    exact: o.deviceId
                                } : {
                                    ideal: o.deviceId
                                }), e.video = n(e.video), C("chrome: " + JSON.stringify(e)), s(e)
                            })
                        }
                        e.video = n(e.video)
                    }
                    return C("chrome: " + JSON.stringify(e)), s(e)
                },
                i = function(e) {
                    return r.version >= 64 ? e : {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            PermissionDismissedError: "NotAllowedError",
                            InvalidStateError: "NotAllowedError",
                            DevicesNotFoundError: "NotFoundError",
                            ConstraintNotSatisfiedError: "OverconstrainedError",
                            TrackStartError: "NotReadableError",
                            MediaDeviceFailedDueToShutdown: "NotAllowedError",
                            MediaDeviceKillSwitchOn: "NotAllowedError",
                            TabCaptureError: "AbortError",
                            ScreenCaptureError: "AbortError",
                            DeviceCaptureError: "AbortError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint || e.constraintName,
                        toString() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                };
            if (t.getUserMedia = function(e, r, n) {
                    s(e, e => {
                        t.webkitGetUserMedia(e, r, e => {
                            n && n(i(e))
                        })
                    })
                }.bind(t), t.mediaDevices.getUserMedia) {
                const e = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
                t.mediaDevices.getUserMedia = function(t) {
                    return s(t, t => e(t).then(e => {
                        if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {
                            e.stop()
                        }), new DOMException("", "NotFoundError");
                        return e
                    }, e => Promise.reject(i(e))))
                }
            }
        }

        function S(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && "function" == typeof t && (e.navigator.mediaDevices.getDisplayMedia = function(r) {
                return t(r).then(t => {
                    const n = r.video && r.video.width,
                        s = r.video && r.video.height,
                        i = r.video && r.video.frameRate;
                    return r.video = {
                        mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: t,
                            maxFrameRate: i || 3
                        }
                    }, n && (r.video.mandatory.maxWidth = n), s && (r.video.mandatory.maxHeight = s), e.navigator.mediaDevices.getUserMedia(r)
                })
            })
        }

        function P(e) {
            e.MediaStream = e.MediaStream || e.webkitMediaStream
        }

        function T(e) {
            if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                    get() {
                        return this._ontrack
                    },
                    set(e) {
                        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                    },
                    enumerable: !0,
                    configurable: !0
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    return this._ontrackpoly || (this._ontrackpoly = t => {
                        t.stream.addEventListener("addtrack", r => {
                            let n;
                            n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === r.track.id) : {
                                track: r.track
                            };
                            const s = new Event("track");
                            s.track = r.track, s.receiver = n, s.transceiver = {
                                receiver: n
                            }, s.streams = [t.stream], this.dispatchEvent(s)
                        }), t.stream.getTracks().forEach(r => {
                            let n;
                            n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === r.id) : {
                                track: r
                            };
                            const s = new Event("track");
                            s.track = r, s.receiver = n, s.transceiver = {
                                receiver: n
                            }, s.streams = [t.stream], this.dispatchEvent(s)
                        })
                    }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                }
            } else u(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                value: {
                    receiver: e.receiver
                }
            }), e))
        }

        function _(e) {
            if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                const t = function(e, t) {
                    return {
                        track: t,
                        get dtmf() {
                            return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                        },
                        _pc: e
                    }
                };
                if (!e.RTCPeerConnection.prototype.getSenders) {
                    e.RTCPeerConnection.prototype.getSenders = function() {
                        return this._senders = this._senders || [], this._senders.slice()
                    };
                    const r = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                        let s = r.apply(this, arguments);
                        return s || (s = t(this, e), this._senders.push(s)), s
                    };
                    const n = e.RTCPeerConnection.prototype.removeTrack;
                    e.RTCPeerConnection.prototype.removeTrack = function(e) {
                        n.apply(this, arguments);
                        const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                    }
                }
                const r = e.RTCPeerConnection.prototype.addStream;
                e.RTCPeerConnection.prototype.addStream = function(e) {
                    this._senders = this._senders || [], r.apply(this, [e]), e.getTracks().forEach(e => {
                        this._senders.push(t(this, e))
                    })
                };
                const n = e.RTCPeerConnection.prototype.removeStream;
                e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {
                        const t = this._senders.find(t => t.track === e);
                        t && this._senders.splice(this._senders.indexOf(t), 1)
                    })
                }
            } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                    get() {
                        return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                    }
                })
            }
        }

        function R(e) {
            if (!e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, r, n] = arguments;
                if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                const s = function(e) {
                        const t = {};
                        return e.result().forEach(e => {
                            const r = {
                                id: e.id,
                                timestamp: e.timestamp,
                                type: {
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                }[e.type] || e.type
                            };
                            e.names().forEach(t => {
                                r[t] = e.stat(t)
                            }), t[r.id] = r
                        }), t
                    },
                    i = function(e) {
                        return new Map(Object.keys(e).map(t => [t, e[t]]))
                    };
                if (arguments.length >= 2) {
                    const n = function(e) {
                        r(i(s(e)))
                    };
                    return t.apply(this, [n, e])
                }
                return new Promise((e, r) => {
                    t.apply(this, [function(t) {
                        e(i(s(t)))
                    }, r])
                }).then(r, n)
            }
        }

        function D(e) {
            if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
            if (!("getStats" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                t && (e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                });
                const r = e.RTCPeerConnection.prototype.addTrack;
                r && (e.RTCPeerConnection.prototype.addTrack = function() {
                    const e = r.apply(this, arguments);
                    return e._pc = this, e
                }), e.RTCRtpSender.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => y(t, e.track, !0))
                }
            }
            if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                const t = e.RTCPeerConnection.prototype.getReceivers;
                t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }), u(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => y(t, e.track, !1))
                }
            }
            if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                    const e = arguments[0];
                    let t, r, n;
                    return this.getSenders().forEach(r => {
                        r.track === e && (t ? n = !0 : t = r)
                    }), this.getReceivers().forEach(t => (t.track === e && (r ? n = !0 : r = t), t.track === e)), n || t && r ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : r ? r.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                }
                return t.apply(this, arguments)
            }
        }

        function k(e) {
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0])
            };
            const t = e.RTCPeerConnection.prototype.addTrack;
            e.RTCPeerConnection.prototype.addTrack = function(e, r) {
                if (!r) return t.apply(this, arguments);
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                const n = t.apply(this, arguments);
                return this._shimmedLocalStreams[r.id] ? -1 === this._shimmedLocalStreams[r.id].indexOf(n) && this._shimmedLocalStreams[r.id].push(n) : this._shimmedLocalStreams[r.id] = [r, n], n
            };
            const r = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(e) {
                this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {
                    if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                });
                const t = this.getSenders();
                r.apply(this, arguments);
                const n = this.getSenders().filter(e => -1 === t.indexOf(e));
                this._shimmedLocalStreams[e.id] = [e].concat(n)
            };
            const n = e.RTCPeerConnection.prototype.removeStream;
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments)
            };
            const s = e.RTCPeerConnection.prototype.removeTrack;
            e.RTCPeerConnection.prototype.removeTrack = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {
                    const r = this._shimmedLocalStreams[t].indexOf(e); - 1 !== r && this._shimmedLocalStreams[t].splice(r, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                }), s.apply(this, arguments)
            }
        }

        function E(e) {
            if (!e.RTCPeerConnection) return;
            const t = m(e);
            if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return k(e);
            const r = e.RTCPeerConnection.prototype.getLocalStreams;
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                const e = r.apply(this);
                return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id])
            };
            const n = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(t) {
                if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {
                        if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                    }), !this._reverseStreams[t.id]) {
                    const r = new e.MediaStream(t.getTracks());
                    this._streams[t.id] = r, this._reverseStreams[r.id] = t, t = r
                }
                n.apply(this, [t])
            };
            const s = e.RTCPeerConnection.prototype.removeStream;

            function i(e, t) {
                let r = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const n = e._reverseStreams[t],
                        s = e._streams[n.id];
                    r = r.replace(new RegExp(s.id, "g"), n.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: r
                })
            }

            function o(e, t) {
                let r = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const n = e._reverseStreams[t],
                        s = e._streams[n.id];
                    r = r.replace(new RegExp(n.id, "g"), s.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: r
                })
            }
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, s.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
            }, e.RTCPeerConnection.prototype.addTrack = function(t, r) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                const n = [].slice.call(arguments, 1);
                if (1 !== n.length || !n[0].getTracks().find(e => e === t)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                const s = this.getSenders().find(e => e.track === t);
                if (s) throw new DOMException("Track already exists.", "InvalidAccessError");
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                const i = this._streams[r.id];
                if (i) i.addTrack(t), Promise.resolve().then(() => {
                    this.dispatchEvent(new Event("negotiationneeded"))
                });
                else {
                    const n = new e.MediaStream([t]);
                    this._streams[r.id] = n, this._reverseStreams[n.id] = r, this.addStream(n)
                }
                return this.getSenders().find(e => e.track === t)
            }, ["createOffer", "createAnswer"].forEach((function(t) {
                const r = e.RTCPeerConnection.prototype[t],
                    n = {
                        [t]() {
                            const e = arguments;
                            return arguments.length && "function" == typeof arguments[0] ? r.apply(this, [t => {
                                const r = i(this, t);
                                e[0].apply(null, [r])
                            }, t => {
                                e[1] && e[1].apply(null, t)
                            }, arguments[2]]) : r.apply(this, arguments).then(e => i(this, e))
                        }
                    };
                e.RTCPeerConnection.prototype[t] = n[t]
            }));
            const a = e.RTCPeerConnection.prototype.setLocalDescription;
            e.RTCPeerConnection.prototype.setLocalDescription = function() {
                return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
            };
            const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
            Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                get() {
                    const e = c.get.apply(this);
                    return "" === e.type ? e : i(this, e)
                }
            }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                let t;
                this._streams = this._streams || {}, Object.keys(this._streams).forEach(r => {
                    this._streams[r].getTracks().find(t => e.track === t) && (t = this._streams[r])
                }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
            }
        }

        function w(e) {
            const t = m(e);
            if (!e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !e.RTCPeerConnection) return;
            const r = 0 === e.RTCPeerConnection.prototype.addIceCandidate.length;
            t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                const r = e.RTCPeerConnection.prototype[t],
                    n = {
                        [t]() {
                            return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments)
                        }
                    };
                e.RTCPeerConnection.prototype[t] = n[t]
            }));
            const n = e.RTCPeerConnection.prototype.addIceCandidate;
            e.RTCPeerConnection.prototype.addIceCandidate = function() {
                return r || arguments[0] ? t.version < 78 && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
            }
        }

        function O(e) {
            const t = m(e);
            u(e, "negotiationneeded", e => {
                const r = e.target;
                if (!(t.version < 72 || r.getConfiguration && "plan-b" === r.getConfiguration().sdpSemantics) || "stable" === r.signalingState) return e
            })
        }
        var I = r(31),
            N = r.n(I);

        function x(e) {
            const t = e && e.navigator,
                r = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
            t.mediaDevices.getUserMedia = function(e) {
                return r(e).catch(e => Promise.reject(function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString() {
                            return this.name
                        }
                    }
                }(e)))
            }
        }

        function A(e) {
            "getDisplayMedia" in e.navigator && e.navigator.mediaDevices && (e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator)))
        }

        function B(e) {
            const t = m(e);
            if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function(e) {
                    return e
                }), e.RTCSessionDescription || (e.RTCSessionDescription = function(e) {
                    return e
                }), t.version < 15025)) {
                const t = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled");
                Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", {
                    set(e) {
                        t.set.call(this, e);
                        const r = new Event("enabled");
                        r.enabled = e, this.dispatchEvent(r)
                    }
                })
            }
            e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                get() {
                    return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = new e.RTCDtmfSender(this) : "video" === this.track.kind && (this._dtmf = null)), this._dtmf
                }
            }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender);
            const r = N()(e, t.version);
            e.RTCPeerConnection = function(e) {
                return e && e.iceServers && (e.iceServers = function(e, t) {
                    let r = !1;
                    return (e = JSON.parse(JSON.stringify(e))).filter(e => {
                        if (e && (e.urls || e.url)) {
                            let t = e.urls || e.url;
                            e.url && e.urls;
                            const n = "string" == typeof t;
                            return n && (t = [t]), t = t.filter(e => {
                                if (0 === e.indexOf("stun:")) return !1;
                                const t = e.startsWith("turn") && !e.startsWith("turn:[") && e.includes("transport=udp");
                                return t && !r ? (r = !0, !0) : t && !r
                            }), delete e.url, e.urls = n ? t[0] : t, !!t.length
                        }
                    })
                }(e.iceServers, t.version), f("ICE servers after filtering:", e.iceServers)), new r(e)
            }, e.RTCPeerConnection.prototype = r.prototype
        }

        function M(e) {
            e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack)
        }

        function j(e) {
            const t = m(e),
                r = e && e.navigator,
                n = e && e.MediaStreamTrack;
            if (r.getUserMedia = function(e, t, n) {
                    r.mediaDevices.getUserMedia(e).then(t, n)
                }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) {
                const e = function(e, t, r) {
                        t in e && !(r in e) && (e[r] = e[t], delete e[t])
                    },
                    t = r.mediaDevices.getUserMedia.bind(r.mediaDevices);
                if (r.mediaDevices.getUserMedia = function(r) {
                        return "object" == typeof r && "object" == typeof r.audio && (r = JSON.parse(JSON.stringify(r)), e(r.audio, "autoGainControl", "mozAutoGainControl"), e(r.audio, "noiseSuppression", "mozNoiseSuppression")), t(r)
                    }, n && n.prototype.getSettings) {
                    const t = n.prototype.getSettings;
                    n.prototype.getSettings = function() {
                        const r = t.apply(this, arguments);
                        return e(r, "mozAutoGainControl", "autoGainControl"), e(r, "mozNoiseSuppression", "noiseSuppression"), r
                    }
                }
                if (n && n.prototype.applyConstraints) {
                    const t = n.prototype.applyConstraints;
                    n.prototype.applyConstraints = function(r) {
                        return "audio" === this.kind && "object" == typeof r && (r = JSON.parse(JSON.stringify(r)), e(r, "autoGainControl", "mozAutoGainControl"), e(r, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [r])
                    }
                }
            }
        }

        function L(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(r) {
                if (!r || !r.video) {
                    const e = new DOMException("getDisplayMedia without video constraints is undefined");
                    return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                }
                return !0 === r.video ? r.video = {
                    mediaSource: t
                } : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r)
            })
        }

        function F(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function U(e) {
            const t = m(e);
            if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
            if (!e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                    const r = e.RTCPeerConnection.prototype[t],
                        n = {
                            [t]() {
                                return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments)
                            }
                        };
                    e.RTCPeerConnection.prototype[t] = n[t]
                })), t.version < 68) {
                const t = e.RTCPeerConnection.prototype.addIceCandidate;
                e.RTCPeerConnection.prototype.addIceCandidate = function() {
                    return arguments[0] ? arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : t.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                }
            }
            const r = {
                    inboundrtp: "inbound-rtp",
                    outboundrtp: "outbound-rtp",
                    candidatepair: "candidate-pair",
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                },
                n = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, s, i] = arguments;
                return n.apply(this, [e || null]).then(e => {
                    if (t.version < 53 && !s) try {
                        e.forEach(e => {
                            e.type = r[e.type] || e.type
                        })
                    } catch (t) {
                        if ("TypeError" !== t.name) throw t;
                        e.forEach((t, n) => {
                            e.set(n, Object.assign({}, t, {
                                type: r[t.type] || t.type
                            }))
                        })
                    }
                    return e
                }).then(s, i)
            }
        }

        function G(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
            const t = e.RTCPeerConnection.prototype.getSenders;
            t && (e.RTCPeerConnection.prototype.getSenders = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            });
            const r = e.RTCPeerConnection.prototype.addTrack;
            r && (e.RTCPeerConnection.prototype.addTrack = function() {
                const e = r.apply(this, arguments);
                return e._pc = this, e
            }), e.RTCRtpSender.prototype.getStats = function() {
                return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
            }
        }

        function $(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
            const t = e.RTCPeerConnection.prototype.getReceivers;
            t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            }), u(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                return this._pc.getStats(this.track)
            }
        }

        function z(e) {
            e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
                this.getSenders().forEach(t => {
                    t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                })
            })
        }

        function V(e) {
            e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
        }

        function K(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.addTransceiver;
            t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                this.setParametersPromises = [];
                const e = arguments[1],
                    r = e && "sendEncodings" in e;
                r && e.sendEncodings.forEach(e => {
                    if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
                    if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                    if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                });
                const n = t.apply(this, arguments);
                if (r) {
                    const {
                        sender: t
                    } = n, r = t.getParameters();
                    (!("encodings" in r) || 1 === r.encodings.length && 0 === Object.keys(r.encodings[0]).length) && (r.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(r).then(() => {
                        delete t.sendEncodings
                    }).catch(() => {
                        delete t.sendEncodings
                    })))
                }
                return n
            })
        }

        function W(e) {
            if ("object" != typeof e || !e.RTCRtpSender) return;
            const t = e.RTCRtpSender.prototype.getParameters;
            t && (e.RTCRtpSender.prototype.getParameters = function() {
                const e = t.apply(this, arguments);
                return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
            })
        }

        function q(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function J(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createAnswer;
            e.RTCPeerConnection.prototype.createAnswer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function Y(e) {
            if ("object" == typeof e && e.RTCPeerConnection) {
                if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                        return this._localStreams || (this._localStreams = []), this._localStreams
                    }), !("addStream" in e.RTCPeerConnection.prototype)) {
                    const t = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addStream = function(e) {
                        this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(r => t.call(this, r, e)), e.getVideoTracks().forEach(r => t.call(this, r, e))
                    }, e.RTCPeerConnection.prototype.addTrack = function(e, ...r) {
                        return r && r.forEach(e => {
                            this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                        }), t.apply(this, arguments)
                    }
                }
                "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._localStreams || (this._localStreams = []);
                    const t = this._localStreams.indexOf(e);
                    if (-1 === t) return;
                    this._localStreams.splice(t, 1);
                    const r = e.getTracks();
                    this.getSenders().forEach(e => {
                        r.includes(e.track) && this.removeTrack(e)
                    })
                })
            }
        }

        function H(e) {
            if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                    return this._remoteStreams ? this._remoteStreams : []
                }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                    get() {
                        return this._onaddstream
                    },
                    set(e) {
                        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                            e.streams.forEach(e => {
                                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                this._remoteStreams.push(e);
                                const t = new Event("addstream");
                                t.stream = e, this.dispatchEvent(t)
                            })
                        })
                    }
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    const e = this;
                    return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                        t.streams.forEach(t => {
                            if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                            e._remoteStreams.push(t);
                            const r = new Event("addstream");
                            r.stream = t, e.dispatchEvent(r)
                        })
                    }), t.apply(e, arguments)
                }
            }
        }

        function Z(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype,
                r = t.createOffer,
                n = t.createAnswer,
                s = t.setLocalDescription,
                i = t.setRemoteDescription,
                o = t.addIceCandidate;
            t.createOffer = function(e, t) {
                const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                    s = r.apply(this, [n]);
                return t ? (s.then(e, t), Promise.resolve()) : s
            }, t.createAnswer = function(e, t) {
                const r = arguments.length >= 2 ? arguments[2] : arguments[0],
                    s = n.apply(this, [r]);
                return t ? (s.then(e, t), Promise.resolve()) : s
            };
            let a = function(e, t, r) {
                const n = s.apply(this, [e]);
                return r ? (n.then(t, r), Promise.resolve()) : n
            };
            t.setLocalDescription = a, a = function(e, t, r) {
                const n = i.apply(this, [e]);
                return r ? (n.then(t, r), Promise.resolve()) : n
            }, t.setRemoteDescription = a, a = function(e, t, r) {
                const n = o.apply(this, [e]);
                return r ? (n.then(t, r), Promise.resolve()) : n
            }, t.addIceCandidate = a
        }

        function X(e) {
            const t = e && e.navigator;
            if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                const e = t.mediaDevices,
                    r = e.getUserMedia.bind(e);
                t.mediaDevices.getUserMedia = e => r(Q(e))
            }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, r, n) {
                t.mediaDevices.getUserMedia(e).then(r, n)
            }.bind(t))
        }

        function Q(e) {
            return e && void 0 !== e.video ? Object.assign({}, e, {
                video: v(e.video)
            }) : e
        }

        function ee(e) {
            if (!e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection;
            e.RTCPeerConnection = function(e, r) {
                if (e && e.iceServers) {
                    const t = [];
                    for (let r = 0; r < e.iceServers.length; r++) {
                        let n = e.iceServers[r];
                        !n.hasOwnProperty("urls") && n.hasOwnProperty("url") ? (n = JSON.parse(JSON.stringify(n)), n.urls = n.url, delete n.url, t.push(n)) : t.push(e.iceServers[r])
                    }
                    e.iceServers = t
                }
                return new t(e, r)
            }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                get: () => t.generateCertificate
            })
        }

        function te(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function re(e) {
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function(e) {
                if (e) {
                    void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                    const t = this.getTransceivers().find(e => "audio" === e.receiver.track.kind);
                    !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                    const r = this.getTransceivers().find(e => "video" === e.receiver.track.kind);
                    !1 === e.offerToReceiveVideo && r ? "sendrecv" === r.direction ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : "recvonly" === r.direction && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : !0 !== e.offerToReceiveVideo || r || this.addTransceiver("video")
                }
                return t.apply(this, arguments)
            }
        }

        function ne(e) {
            "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
        }
        var se = r(1),
            ie = r.n(se);

        function oe(e) {
            if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
            const t = e.RTCIceCandidate;
            e.RTCIceCandidate = function(e) {
                if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                    const r = new t(e),
                        n = ie.a.parseCandidate(e.candidate),
                        s = Object.assign(r, n);
                    return s.toJSON = function() {
                        return {
                            candidate: s.candidate,
                            sdpMid: s.sdpMid,
                            sdpMLineIndex: s.sdpMLineIndex,
                            usernameFragment: s.usernameFragment
                        }
                    }, s
                }
                return new t(e)
            }, e.RTCIceCandidate.prototype = t.prototype, u(e, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", {
                value: new e.RTCIceCandidate(t.candidate),
                writable: "false"
            }), t))
        }

        function ae(e) {
            if (!e.RTCPeerConnection) return;
            const t = m(e);
            "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                get() {
                    return void 0 === this._sctp ? null : this._sctp
                }
            });
            const r = function(e) {
                    if (!e || !e.sdp) return !1;
                    const t = ie.a.splitSections(e.sdp);
                    return t.shift(), t.some(e => {
                        const t = ie.a.parseMLine(e);
                        return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                    })
                },
                n = function(e) {
                    const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                    if (null === t || t.length < 2) return -1;
                    const r = parseInt(t[1], 10);
                    return r != r ? -1 : r
                },
                s = function(e) {
                    let r = 65536;
                    return "firefox" === t.browser && (r = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), r
                },
                i = function(e, r) {
                    let n = 65536;
                    "firefox" === t.browser && 57 === t.version && (n = 65535);
                    const s = ie.a.matchPrefix(e.sdp, "a=max-message-size:");
                    return s.length > 0 ? n = parseInt(s[0].substr(19), 10) : "firefox" === t.browser && -1 !== r && (n = 2147483637), n
                },
                o = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                    const {
                        sdpSemantics: e
                    } = this.getConfiguration();
                    "plan-b" === e && Object.defineProperty(this, "sctp", {
                        get() {
                            return void 0 === this._sctp ? null : this._sctp
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }
                if (r(arguments[0])) {
                    const e = n(arguments[0]),
                        t = s(e),
                        r = i(arguments[0], e);
                    let o;
                    o = 0 === t && 0 === r ? Number.POSITIVE_INFINITY : 0 === t || 0 === r ? Math.max(t, r) : Math.min(t, r);
                    const a = {};
                    Object.defineProperty(a, "maxMessageSize", {
                        get: () => o
                    }), this._sctp = a
                }
                return o.apply(this, arguments)
            }
        }

        function ce(e) {
            if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

            function t(e, t) {
                const r = e.send;
                e.send = function() {
                    const n = arguments[0],
                        s = n.length || n.size || n.byteLength;
                    if ("open" === e.readyState && t.sctp && s > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                    return r.apply(e, arguments)
                }
            }
            const r = e.RTCPeerConnection.prototype.createDataChannel;
            e.RTCPeerConnection.prototype.createDataChannel = function() {
                const e = r.apply(this, arguments);
                return t(e, this), e
            }, u(e, "datachannel", e => (t(e.channel, e.target), e))
        }

        function de(e) {
            if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
            const t = e.RTCPeerConnection.prototype;
            Object.defineProperty(t, "connectionState", {
                get() {
                    return {
                        completed: "connected",
                        checking: "connecting"
                    }[this.iceConnectionState] || this.iceConnectionState
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t, "onconnectionstatechange", {
                get() {
                    return this._onconnectionstatechange || null
                },
                set(e) {
                    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                },
                enumerable: !0,
                configurable: !0
            }), ["setLocalDescription", "setRemoteDescription"].forEach(e => {
                const r = t[e];
                t[e] = function() {
                    return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                        const t = e.target;
                        if (t._lastConnectionState !== t.connectionState) {
                            t._lastConnectionState = t.connectionState;
                            const r = new Event("connectionstatechange", e);
                            t.dispatchEvent(r)
                        }
                        return e
                    }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), r.apply(this, arguments)
                }
            })
        }

        function le(e) {
            if (!e.RTCPeerConnection) return;
            const t = m(e);
            if ("chrome" === t.browser && t.version >= 71) return;
            if ("safari" === t.browser && t.version >= 605) return;
            const r = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function(e) {
                return e && e.sdp && -1 !== e.sdp.indexOf("\na=extmap-allow-mixed") && (e.sdp = e.sdp.split("\n").filter(e => "a=extmap-allow-mixed" !== e.trim()).join("\n")), r.apply(this, arguments)
            }
        }
        const ue = function({
            window: e
        } = {}, t = {
            shimChrome: !0,
            shimFirefox: !0,
            shimEdge: !0,
            shimSafari: !0
        }) {
            const r = f,
                c = m(e),
                d = {
                    browserDetails: c,
                    commonShim: a,
                    extractVersion: l,
                    disableLog: h,
                    disableWarnings: p
                };
            switch (c.browser) {
                case "chrome":
                    if (!n || !w || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), d;
                    if (null === c.version) return r("Chrome shim can not determine version, not shimming."), d;
                    r("adapter.js shimming chrome."), d.browserShim = n, b(e), P(e), w(e), T(e), E(e), _(e), R(e), D(e), O(e), oe(e), de(e), ae(e), ce(e), le(e);
                    break;
                case "firefox":
                    if (!i || !U || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), d;
                    r("adapter.js shimming firefox."), d.browserShim = i, j(e), U(e), F(e), z(e), G(e), $(e), V(e), K(e), W(e), q(e), J(e), oe(e), de(e), ae(e), ce(e);
                    break;
                case "edge":
                    if (!s || !B || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), d;
                    r("adapter.js shimming edge."), d.browserShim = s, x(e), A(e), B(e), M(e), ae(e), ce(e);
                    break;
                case "safari":
                    if (!o || !t.shimSafari) return r("Safari shim is not included in this adapter release."), d;
                    r("adapter.js shimming safari."), d.browserShim = o, ee(e), re(e), Z(e), Y(e), H(e), te(e), X(e), ne(e), oe(e), ae(e), ce(e), le(e);
                    break;
                default:
                    r("Unsupported browser!")
            }
            return d
        }({
            window: "undefined" == typeof window ? void 0 : window
        });
        t.default = ue
    }, function(e, t, r) {
        "use strict";
        r.r(t);
        var n = function(e) {
                var t = this.constructor;
                return this.then((function(r) {
                    return t.resolve(e()).then((function() {
                        return r
                    }))
                }), (function(r) {
                    return t.resolve(e()).then((function() {
                        return t.reject(r)
                    }))
                }))
            },
            s = setTimeout;

        function i(e) {
            return Boolean(e && void 0 !== e.length)
        }

        function o() {}

        function a(e) {
            if (!(this instanceof a)) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof e) throw new TypeError("not a function");
            this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], p(e, this)
        }

        function c(e, t) {
            for (; 3 === e._state;) e = e._value;
            0 !== e._state ? (e._handled = !0, a._immediateFn((function() {
                var r = 1 === e._state ? t.onFulfilled : t.onRejected;
                if (null !== r) {
                    var n;
                    try {
                        n = r(e._value)
                    } catch (e) {
                        return void l(t.promise, e)
                    }
                    d(t.promise, n)
                } else(1 === e._state ? d : l)(t.promise, e._value)
            }))) : e._deferreds.push(t)
        }

        function d(e, t) {
            try {
                if (t === e) throw new TypeError("A promise cannot be resolved with itself.");
                if (t && ("object" == typeof t || "function" == typeof t)) {
                    var r = t.then;
                    if (t instanceof a) return e._state = 3, e._value = t, void u(e);
                    if ("function" == typeof r) return void p((n = r, s = t, function() {
                        n.apply(s, arguments)
                    }), e)
                }
                e._state = 1, e._value = t, u(e)
            } catch (t) {
                l(e, t)
            }
            var n, s
        }

        function l(e, t) {
            e._state = 2, e._value = t, u(e)
        }

        function u(e) {
            2 === e._state && 0 === e._deferreds.length && a._immediateFn((function() {
                e._handled || a._unhandledRejectionFn(e._value)
            }));
            for (var t = 0, r = e._deferreds.length; t < r; t++) c(e, e._deferreds[t]);
            e._deferreds = null
        }

        function h(e, t, r) {
            this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.promise = r
        }

        function p(e, t) {
            var r = !1;
            try {
                e((function(e) {
                    r || (r = !0, d(t, e))
                }), (function(e) {
                    r || (r = !0, l(t, e))
                }))
            } catch (e) {
                if (r) return;
                r = !0, l(t, e)
            }
        }
        a.prototype.catch = function(e) {
            return this.then(null, e)
        }, a.prototype.then = function(e, t) {
            var r = new this.constructor(o);
            return c(this, new h(e, t, r)), r
        }, a.prototype.finally = n, a.all = function(e) {
            return new a((function(t, r) {
                if (!i(e)) return r(new TypeError("Promise.all accepts an array"));
                var n = Array.prototype.slice.call(e);
                if (0 === n.length) return t([]);
                var s = n.length;

                function o(e, i) {
                    try {
                        if (i && ("object" == typeof i || "function" == typeof i)) {
                            var a = i.then;
                            if ("function" == typeof a) return void a.call(i, (function(t) {
                                o(e, t)
                            }), r)
                        }
                        n[e] = i, 0 == --s && t(n)
                    } catch (e) {
                        r(e)
                    }
                }
                for (var a = 0; a < n.length; a++) o(a, n[a])
            }))
        }, a.resolve = function(e) {
            return e && "object" == typeof e && e.constructor === a ? e : new a((function(t) {
                t(e)
            }))
        }, a.reject = function(e) {
            return new a((function(t, r) {
                r(e)
            }))
        }, a.race = function(e) {
            return new a((function(t, r) {
                if (!i(e)) return r(new TypeError("Promise.race accepts an array"));
                for (var n = 0, s = e.length; n < s; n++) a.resolve(e[n]).then(t, r)
            }))
        }, a._immediateFn = "function" == typeof setImmediate && function(e) {
            setImmediate(e)
        } || function(e) {
            s(e, 0)
        }, a._unhandledRejectionFn = function(e) {
            "undefined" != typeof console && console
        };
        var f = a,
            m = function() {
                if ("undefined" != typeof self) return self;
                if ("undefined" != typeof window) return window;
                if ("undefined" != typeof global) return global;
                throw new Error("unable to locate global object")
            }();
        "Promise" in m ? m.Promise.prototype.finally || (m.Promise.prototype.finally = n) : m.Promise = f
    }]).default
}, "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("BPP2PSDK", [], t) : "object" == typeof exports ? exports.BPP2PSDK = t() : e.BPP2PSDK = t();